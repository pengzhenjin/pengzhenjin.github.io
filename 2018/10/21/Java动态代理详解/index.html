<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-me.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-me.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="动态代理在 Java 中有着广泛的应用，比如 Spring AOP、Hibernate 数据查询、测试框架的后端 mock、RPC 远程调用、Java 注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。本文主要介绍 Java 中两种常见的动态代理方式：JDK 原生动态代理和 CGLIB 动态代理。">
<meta name="keywords" content="java,proxy,动态代理">
<meta property="og:type" content="article">
<meta property="og:title" content="Java动态代理详解">
<meta property="og:url" content="http://pengzhenjin.top/2018/10/21/Java动态代理详解/index.html">
<meta property="og:site_name" content="彭真进的博客">
<meta property="og:description" content="动态代理在 Java 中有着广泛的应用，比如 Spring AOP、Hibernate 数据查询、测试框架的后端 mock、RPC 远程调用、Java 注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。本文主要介绍 Java 中两种常见的动态代理方式：JDK 原生动态代理和 CGLIB 动态代理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://pengzhenjin.top/2018/10/21/Java动态代理详解/proxy-chapter/img1.jpg">
<meta property="og:image" content="http://pengzhenjin.top/2018/10/21/Java动态代理详解/proxy-chapter/img2.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/10/21/Java动态代理详解/proxy-chapter/img3.png">
<meta property="og:updated_time" content="2019-10-15T03:17:40.488Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java动态代理详解">
<meta name="twitter:description" content="动态代理在 Java 中有着广泛的应用，比如 Spring AOP、Hibernate 数据查询、测试框架的后端 mock、RPC 远程调用、Java 注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。本文主要介绍 Java 中两种常见的动态代理方式：JDK 原生动态代理和 CGLIB 动态代理。">
<meta name="twitter:image" content="http://pengzhenjin.top/2018/10/21/Java动态代理详解/proxy-chapter/img1.jpg">
  <link rel="canonical" href="http://pengzhenjin.top/2018/10/21/Java动态代理详解/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java动态代理详解 | 彭真进的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ede0ba70e7eb2eb800e94196368893eb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">彭真进的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">业精于勤荒于嬉，行成于思毁于随</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://pengzhenjin.top/2018/10/21/Java动态代理详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭真进">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="彭真进的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java动态代理详解

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-21T00:00:00+08:00">2018-10-21</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>19k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>17 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>动态代理在 Java 中有着广泛的应用，比如 Spring AOP、Hibernate 数据查询、测试框架的后端 mock、RPC 远程调用、Java 注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。</p><p>本文主要介绍 Java 中两种常见的动态代理方式：JDK 原生动态代理和 CGLIB 动态代理。</p><a id="more"></a>

<p>由于 Java 动态代理与 Java 反射机制关系紧密，请读者确保已经了解了 Java 反射机制，可参考上一篇文章<a href="https://pengzhenjin.top/2018/10/20/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3">《Java反射机制详解》</a>。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>本文将介绍的 Java 动态代理与设计模式中的代理模式有关，什么是代理模式呢？</p>
<p><strong>代理模式：</strong>给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p>
<p>代理模式角色分为 3 种：</p>
<p><strong>Subject（抽象主题角色）：</strong>定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p>
<p><strong>RealSubject（真实主题角色）：</strong>真正实现业务逻辑的类；</p>
<p><strong>Proxy（代理主题角色）：</strong>用来代理和封装真实主题；</p>
<p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p>
<p><img src="proxy-chapter/img1.jpg" alt></p>
<p>代理模式按照职责（使用场景）来分类，至少可以分为以下几类：1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。</p>
<p>如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：</p>
<ul>
<li>所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而动态代理的源码是在程序运行期间由 JVM 根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p>
<p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void select();   </span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;  </span><br><span class="line">    public void select() &#123;  </span><br><span class="line">        System.out.println(&quot;查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 select 和 update 之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceProxy implements UserService &#123;</span><br><span class="line">    private UserService target; // 被代理的对象</span><br><span class="line"></span><br><span class="line">    public UserServiceProxy(UserService target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    // 这里才实际调用真实主题角色的方法</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    // 这里才实际调用真实主题角色的方法</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before() &#123;     // 在执行方法之前执行</span><br><span class="line">        System.out.println(String.format(&quot;log start time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    private void after() &#123;      // 在执行方法之后执行</span><br><span class="line">        System.out.println(String.format(&quot;log end time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userServiceImpl = new UserServiceImpl();</span><br><span class="line">        UserService proxy = new UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 14:13:25 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 14:13:25 CST 2018]</span><br></pre></td></tr></table></figure>

<p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p>
<h4 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h4><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p>
<ol>
<li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</li>
</ol>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大。</li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类。</li>
</ul>
<ol start="2">
<li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。</li>
</ol>
<h4 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h4><p>当然是让代理类动态的生成啦，也就是动态代理。</p>
<p><strong>为什么类可以动态的生成？</strong><br>Java 虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下 3 件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于虚拟机规范对这 3 点要求并不具体，所以实际的实现是非常灵活的，关于第 1 点，获取类的二进制字节流（class字节码）就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是 JAR、EAR、WAR 等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li>运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是 JSP，即由 JSP 文件生成对应的 Class 类</li>
<li>从数据库中获取等等</li>
</ul>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到 JVM 中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p>
<h4 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h4><div class="note default">
            <p>这里有一些介绍：<a href="https://java-source.net/open-source/bytecode-libraries" target="_blank" rel="noopener">https://java-source.net/open-source/bytecode-libraries</a></p>
          </div>

<ul>
<li>Apache BCEL (Byte Code Engineering Library)：是 Java classworking 广泛使用的一种框架，它可以深入到 JVM 汇编语言进行类操作的细节。</li>
<li>ObjectWeb ASM：是一个 Java 字节码操作框架。它可以用于直接以二进制形式动态生成 stub 根类或其他代理类，或者在加载时动态修改类。</li>
<li>CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展 Java 类并在运行时实现接口。</li>
<li>Javassist：是 Java 的加载时反射系统，它是一个用于在 Java 中编辑字节码的类库; 它使 Java 程序能够在运行时定义新类，并在 JVM 加载之前修改类文件。</li>
<li>…</li>
</ul>
<h4 id="实现动态代理的思考方向"><a href="#实现动态代理的思考方向" class="headerlink" title="实现动态代理的思考方向"></a>实现动态代理的思考方向</h4><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p>
<ol>
<li>通过实现接口的方式 -&gt; JDK 动态代理</li>
<li>通过继承类的方式 -&gt; CGLIB 动态代理</li>
</ol>
<p>注：使用ASM对使用者要求比较高，使用 Javassist 会比较麻烦</p>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>JDK 动态代理主要涉及两个类：<strong>java.lang.reflect.Proxy</strong> 和 <strong>java.lang.reflect.InvocationHandler</strong>，我们仍然通过案例来学习。</p>
<p>编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 invoke 方法中编写方法调用的逻辑处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class LogHandler implements InvocationHandler &#123;</span><br><span class="line">    Object target;  // 被代理的对象，实际的方法执行者</span><br><span class="line"></span><br><span class="line">    public LogHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  // 调用 target 的 method 方法</span><br><span class="line">        after();</span><br><span class="line">        return result;  // 返回方法的执行结果</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用invoke方法之前执行</span><br><span class="line">    private void before() &#123;</span><br><span class="line">        System.out.println(String.format(&quot;log start time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用invoke方法之后执行</span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.out.println(String.format(&quot;log end time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import proxy.UserService;</span><br><span class="line">import proxy.UserServiceImpl;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">        // System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">        // 1. 创建被代理的对象，UserService接口的实现类</span><br><span class="line">        UserServiceImpl userServiceImpl = new UserServiceImpl();</span><br><span class="line">        // 2. 获取对应的 ClassLoader</span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span><br><span class="line">        //     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span><br><span class="line">        InvocationHandler logHandler = new LogHandler(userServiceImpl);</span><br><span class="line">        /*</span><br><span class="line">           5.根据上面提供的信息，创建代理对象 在这个过程中，</span><br><span class="line">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span><br><span class="line">               b.然后根据相应的字节码转换成对应的class，</span><br><span class="line">               c.然后调用newInstance()创建代理实例</span><br><span class="line">         */</span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        // 调用代理的方法</span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line"></span><br><span class="line">        // 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span><br><span class="line">        // ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">log start time [Thu Dec 20 16:55:19 CST 2018] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec 20 16:55:19 CST 2018]</span><br></pre></td></tr></table></figure>

<p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p>
<p><strong>java.lang.reflect.InvocationHandler：</strong></p>
<p>Object invoke(Object proxy, Method method, Object[] args) 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p>
<p><strong>java.lang.reflect.Proxy：</strong></p>
<p>static InvocationHandler getInvocationHandler(Object proxy) 用于获取指定代理对象所关联的调用处理器</p>
<p>static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces) 返回指定接口的代理类</p>
<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p>
<p>static boolean isProxyClass(Class&lt;?&gt; cl) 返回 cl 是否为一个代理类</p>
<h4 id="代理类的调用过程"><a href="#代理类的调用过程" class="headerlink" title="代理类的调用过程"></a>代理类的调用过程</h4><p>生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟<br>（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import sun.misc.ProxyGenerator;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ProxyUtils &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span><br><span class="line">     * params: clazz 需要生成动态代理类的类</span><br><span class="line">     * proxyName: 为动态生成的代理类的名称</span><br><span class="line">     */</span><br><span class="line">    public static void generateClassFile(Class clazz, String proxyName) &#123;</span><br><span class="line">        // 根据类信息和提供的代理类名称，生成字节码</span><br><span class="line">        byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        String paths = clazz.getResource(&quot;.&quot;).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        FileOutputStream out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //保留到硬盘中</span><br><span class="line">            out = new FileOutputStream(paths + proxyName + &quot;.class&quot;);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 Client2 测试类的 main 的最后面加入一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span><br><span class="line">ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span><br></pre></td></tr></table></figure>

<p>IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后 IDEA 的反编译插件会将该二进制 class 文件</p>
<p><img src="proxy-chapter/img2.png" alt></p>
<p>UserServiceProxy 的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line">import proxy.UserService;</span><br><span class="line"></span><br><span class="line">public final class UserServiceProxy extends Proxy implements UserService &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m0;</span><br><span class="line">    private static Method m3;</span><br><span class="line"></span><br><span class="line">    public UserServiceProxy(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void select() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void update() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;proxy.UserService&quot;).getMethod(&quot;select&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;proxy.UserService&quot;).getMethod(&quot;update&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 UserServiceProxy 的代码中我们可以发现：</p>
<ul>
<li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及 equals、hashCode、toString 等方法</li>
<li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li>
<li>类和所有方法都被 public final 修饰，所以代理类只可被使用，不可以再被继承</li>
<li>每个方法都有一个 Method 对象来描述，Method 对象在 static 静态代码块中创建，以 m + 数字 的格式命名</li>
<li>调用方法的时候通过 super.h.invoke(this, m1, (Object[])null); 调用，其中的 super.h.invoke 实际上是在创建代理的时候传递给<br>Proxy.newProxyInstance 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li>
</ul>
<p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    before();</span><br><span class="line">    Object result = method.invoke(target, args);       // 调用 target 的 method 方法</span><br><span class="line">    after();</span><br><span class="line">    return result;  // 返回方法的执行结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DK动态代理执行方法调用的过程简图如下：</p>
<p><img src="proxy-chapter/img3.png" alt></p>
<p>代理类的调用过程相信大家都明了了，而关于 Proxy 的源码解析，还请大家另外查阅其他文章或者直接看源码。</p>
<h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>maven 引入 CGLIB 包，然后编写一个 UserDao 类，它没有接口，只有两个方法，select() 和 update()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param object 表示要进行增强的对象</span><br><span class="line">     * @param method 表示拦截的方法</span><br><span class="line">     * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span><br><span class="line">     * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span><br><span class="line">     * @return 执行结果</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);   // 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span><br><span class="line">        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private void before() &#123;</span><br><span class="line">        System.out.println(String.format(&quot;log start time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.out.println(String.format(&quot;log end time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class CglibTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DaoProxy daoProxy = new DaoProxy(); </span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);  // 设置超类，cglib是通过继承来实现的</span><br><span class="line">        enhancer.setCallback(daoProxy);</span><br><span class="line"></span><br><span class="line">        Dao dao = (Dao)enhancer.create();   // 创建代理类</span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Dec 21 00:06:40 CST 2018] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec 21 00:06:40 CST 2018] </span><br><span class="line">log start time [Fri Dec 21 00:06:40 CST 2018] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Dec 21 00:06:40 CST 2018]</span><br></pre></td></tr></table></figure>

<p>还可以进一步多个 MethodInterceptor 进行过滤筛选</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor2 implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private void before() &#123;</span><br><span class="line">        System.out.println(String.format(&quot;log2 start time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.out.println(String.format(&quot;log2 end time [%s] &quot;, new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</span><br><span class="line">public class DaoFilter implements CallbackFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int accept(Method method) &#123;</span><br><span class="line">        if (&quot;select&quot;.equals(method.getName())) &#123;</span><br><span class="line">            return 0;   // Callback 列表第1个拦截器</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;   // Callback 列表第2个拦截器，return 2 则为第3个，以此类推</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CglibTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">        LogInterceptor2 logInterceptor2 = new LogInterceptor2();</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   // 设置超类，cglib是通过继承来实现的</span><br><span class="line">        enhancer.setCallbacks(new Callback[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;);   // 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理</span><br><span class="line">        enhancer.setCallbackFilter(new DaoFilter());</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) enhancer.create();   // 创建代理类</span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri Dec 21 00:22:39 CST 2018] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec 21 00:22:39 CST 2018] </span><br><span class="line">log2 start time [Fri Dec 21 00:22:39 CST 2018] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log2 end time [Fri Dec 21 00:22:39 CST 2018]</span><br></pre></td></tr></table></figure>

<p>CGLIB 创建动态代理类的模式是：</p>
<ol>
<li>查找目标类上的所有非 final 的 public 类型的方法定义；</li>
<li>将这些方法的定义转换成字节码；</li>
<li>将组成的字节码转换成相应的代理的 class 对象；</li>
<li>实现 MethodInterceptor 接口，用来处理对代理类上所有方法的请求；</li>
</ol>
<h3 id="JDK-动态代理与-CGLIB-动态代理对比"><a href="#JDK-动态代理与-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理与 CGLIB 动态代理对比"></a>JDK 动态代理与 CGLIB 动态代理对比</h3><p>JDK 动态代理：基于 Java 反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p>
<p>CGLIB 动态代理：基于 ASM 机制实现，通过生成业务类的子类作为代理类。</p>
<p>JDK Proxy 的优势：</p>
<ul>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 CGLIB 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ul>
<p>基于类似 CGLIB 框架的优势：</p>
<ul>
<li>无需实现接口，达到代理类无侵入。</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能。</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="描述动态代理的几种实现方式？分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式？分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式？分别说出相应的优缺点"></a>描述动态代理的几种实现方式？分别说出相应的优缺点</h4><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p>
<p><strong>静态代理：</strong>代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p>
<ul>
<li><strong>优点：</strong>可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li>
<li><strong>缺点：</strong>不同的接口要有不同的代理类实现，会很冗余</li>
</ul>
<p><strong>JDK 动态代理：</strong></p>
<ul>
<li><p>为了解决静态代理中，生成大量的代理类造成的冗余；</p>
</li>
<li><p>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</p>
</li>
<li><p>JDK 动态代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</p>
</li>
<li><p>JDK 动态代理之所以只能代理接口是因为代理类本身已经 extends 了 Proxy，而 java 是不允许多重继承的，但是允许实现多个接口</p>
</li>
<li><p><strong>优点：</strong>解决了静态代理中冗余的代理实现类问题。</p>
</li>
<li><p><strong>缺点：</strong>JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</p>
</li>
</ul>
<p><strong>CGLIB 代理：</strong></p>
<ul>
<li><p>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK 方式解决不了；</p>
</li>
<li><p>CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。</p>
</li>
<li><p>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</p>
</li>
<li><p>但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。</p>
</li>
<li><p>同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</p>
</li>
<li><p><strong>优点：</strong>没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p>
</li>
<li><p><strong>缺点：</strong>技术实现相对难理解些。</p>
</li>
</ul>
<h4 id="CGlib-对接口实现代理？"><a href="#CGlib-对接口实现代理？" class="headerlink" title="CGlib 对接口实现代理？"></a>CGlib 对接口实现代理？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import proxy.UserService;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。</span><br><span class="line"> * 该类中完成三样工作：</span><br><span class="line"> * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象</span><br><span class="line"> * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类</span><br><span class="line"> * （3）定义回调接口方法。对目标类的增强这在这里完成</span><br><span class="line"> */</span><br><span class="line">public class CGLibFactory implements MethodInterceptor &#123;</span><br><span class="line">    // 声明目标类的成员变量</span><br><span class="line">    private UserService target;</span><br><span class="line"></span><br><span class="line">    public CGLibFactory(UserService target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义代理的生成方法,用于创建代理对象</span><br><span class="line">    public UserService myCGLibCreator() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        // 为代理对象设置父类，即指定目标类</span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        /**</span><br><span class="line">         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，</span><br><span class="line">         * 是因为MethodIntecepter接口继承自Callback，是其子接口</span><br><span class="line">         */</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return (UserService) enhancer.create();// create用以生成CGLib代理对象</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;start invoke &quot; + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;end invoke &quot; + method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%B8%83%E5%8F%8D%E5%B0%84" target="_blank" rel="noopener">《Java核心技术》</a>卷一</p>
<p>《深入理解Java虚拟机》7.3</p>
<p>java docs: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html</a></p>
<p><a href="https://segmentfault.com/a/1190000011291179" target="_blank" rel="noopener">Java三种代理模式：静态代理、动态代理和cglib代理</a></p>
<p><a href="http://xzc.fun/w/index.php?title=%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F_%E5%88%86%E5%88%AB%E8%AF%B4%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">描述动态代理的几种实现方式 分别说出相应的优缺点</a></p>
<p><a href="https://my.oschina.net/robinyao/blog/811193" target="_blank" rel="noopener">JDK动态代理详解</a></p>
<p><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></p>
<p><a href="https://blog.csdn.net/WangQYoho/article/details/77584832" target="_blank" rel="noopener">静态代理和动态代理的理解</a></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\10\16\HashMap的实现原理\" rel="bookmark">HashMap的实现原理</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\10\20\Java反射机制详解\" rel="bookmark">Java反射机制详解</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\09\01\Java虚拟机（一）：Java内存区域与内存溢出异常\" rel="bookmark">Java虚拟机（一）：Java内存区域与内存溢出异常</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\10\06\Java多线程详解\" rel="bookmark">Java多线程详解</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\09\03\Java虚拟机（三）：Java内存模型与线程\" rel="bookmark">Java虚拟机（三）：Java内存模型与线程</a></div>
      
    </li>
  
  </ul>

        
      
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/uploads/wechatpay.png" alt="彭真进 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/uploads/alipay.png" alt="彭真进 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>彭真进</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://pengzhenjin.top/2018/10/21/Java动态代理详解/" title="Java动态代理详解">http://pengzhenjin.top/2018/10/21/Java动态代理详解/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
            
              <a href="/tags/proxy/" rel="tag"><i class="fa fa-tag"></i> proxy</a>
            
              <a href="/tags/动态代理/" rel="tag"><i class="fa fa-tag"></i> 动态代理</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2018/10/20/Java反射机制详解/" rel="next" title="Java反射机制详解">
                  <i class="fa fa-chevron-left"></i> Java反射机制详解
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/05/20/Android-Jetpack组件：Navigation/" rel="prev" title="Android-Jetpack组件：Navigation">
                  Android-Jetpack组件：Navigation <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#代理模式"><span class="nav-number">1.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态代理"><span class="nav-number">2.</span> <span class="nav-text">静态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态代理的缺点"><span class="nav-number">2.1.</span> <span class="nav-text">静态代理的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何改进？"><span class="nav-number">2.2.</span> <span class="nav-text">如何改进？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的字节码操作类库"><span class="nav-number">2.3.</span> <span class="nav-text">常见的字节码操作类库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现动态代理的思考方向"><span class="nav-number">2.4.</span> <span class="nav-text">实现动态代理的思考方向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-动态代理"><span class="nav-number">3.</span> <span class="nav-text">JDK 动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代理类的调用过程"><span class="nav-number">3.1.</span> <span class="nav-text">代理类的调用过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB-动态代理"><span class="nav-number">4.</span> <span class="nav-text">CGLIB 动态代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-动态代理与-CGLIB-动态代理对比"><span class="nav-number">5.</span> <span class="nav-text">JDK 动态代理与 CGLIB 动态代理对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题"><span class="nav-number">6.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#描述动态代理的几种实现方式？分别说出相应的优缺点"><span class="nav-number">6.1.</span> <span class="nav-text">描述动态代理的几种实现方式？分别说出相应的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CGlib-对接口实现代理？"><span class="nav-number">6.2.</span> <span class="nav-text">CGlib 对接口实现代理？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/uploads/avatar.png"
      alt="彭真进">
  <p class="site-author-name" itemprop="name">彭真进</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/pengzhenjin" title="GitHub &rarr; https://github.com/pengzhenjin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:562260994@qq.com" title="E-Mail &rarr; mailto:562260994@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://hexo.io/zh-cn" title="https://hexo.io/zh-cn" rel="noopener" target="_blank">Hexo</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://theme-next.org/docs" title="https://theme-next.org/docs" rel="noopener" target="_blank">NexT</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">彭真进 版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">454k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">6:53</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a0aefd8233242f4272c5',
      clientSecret: '89cbd8c8415d03a931cdeba5a9146e38803a1ad7',
      repo: 'pengzhenjin.github.io',
      owner: 'pengzhenjin',
      admin: ['pengzhenjin'],
      id: '64b838d9d709ff8190985f5203ccee0c',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
