<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-me.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-me.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。 你已经尝试了跟踪和提交文件的基本操作，并且发挥了暂存区和轻量级的分支及合并的威力。接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。选择修订版本Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。">
<meta name="keywords" content="Git">
<meta property="og:type" content="article">
<meta property="og:title" content="Git：工具">
<meta property="og:url" content="http://pengzhenjin.top/2018/06/10/Git：工具/index.html">
<meta property="og:site_name" content="彭真进的博客">
<meta property="og:description" content="现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。 你已经尝试了跟踪和提交文件的基本操作，并且发挥了暂存区和轻量级的分支及合并的威力。接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。选择修订版本Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-1/img1.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img1.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img2.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img3.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img4.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img5.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img6.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img7.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img8.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img9.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img10.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img11.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img12.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img13.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img14.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img15.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img16.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img17.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-7/img18.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-8/img1.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-8/img2.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-8/img3.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-8/img4.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-8/img5.png">
<meta property="og:updated_time" content="2019-08-29T10:52:06.577Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git：工具">
<meta name="twitter:description" content="现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。 你已经尝试了跟踪和提交文件的基本操作，并且发挥了暂存区和轻量级的分支及合并的威力。接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。选择修订版本Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。">
<meta name="twitter:image" content="http://pengzhenjin.top/2018/06/10/Git：工具/git-chapter-1/img1.png">
  <link rel="canonical" href="http://pengzhenjin.top/2018/06/10/Git：工具/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Git：工具 | 彭真进的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ede0ba70e7eb2eb800e94196368893eb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">彭真进的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">业精于勤荒于嬉，行成于思毁于随</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://pengzhenjin.top/2018/06/10/Git：工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭真进">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="彭真进的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Git：工具

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-10T00:00:00+08:00">2018-06-10</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>84k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1:16</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。 你已经尝试了跟踪和提交文件的基本操作，并且发挥了暂存区和轻量级的分支及合并的威力。</p><p>接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。</p><h3 id="选择修订版本"><a href="#选择修订版本" class="headerlink" title="选择修订版本"></a>选择修订版本</h3><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。</p><a id="more"></a>


<h4 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h4><p>你可以通过 Git 给出的 SHA-1 值来获取一次提交，不过还有很多更人性化的方式来做同样的事情。 本节将会介绍获取单个提交的多种方法。</p>
<h4 id="简短的-SHA-1"><a href="#简短的-SHA-1" class="headerlink" title="简短的 SHA-1"></a>简短的 SHA-1</h4><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说，当前仓库中只有一个对象以这段 SHA-1 开头。</p>
<p>例如查看一次指定的提交，假设你执行 <code>git log</code> 命令来查看之前新增一个功能的那次提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &apos;phedders/rdocs&apos;</span><br><span class="line"></span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br></pre></td></tr></table></figure>

<p>假设这个提交是 <code>1c002dd....</code>，如果你想 <code>git show</code> 这个提交，下面的命令是等价的（假设简短的版本没有歧义）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">$ git show 1c002dd4b536e7479f</span><br><span class="line">$ git show 1c002d</span><br></pre></td></tr></table></figure>

<p>Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 <code>git log</code> 后加上 <code>--abbrev-commit</code> 参数，输出结果里就会显示简短且唯一的值；默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --abbrev-commit --pretty=oneline</span><br><span class="line">ca82a6d changed the version number</span><br><span class="line">085bb3b removed unnecessary test code</span><br><span class="line">a11bef0 first commit</span><br></pre></td></tr></table></figure>

<p>通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。</p>
<p>比如 Linux 内核这个相当大的 Git 项目，目前有超过 45 万个提交，包含 360 万个对象，也只需要前 11 个字符就能保证唯一性。</p>
<h4 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h4><p>指明一次提交最直接的方法是有一个指向它的分支引用。 这样你就可以在任意一个 Git 命令中使用这个分支名来代替对应的提交对象或者 SHA-1 值。 例如，你想要查看一个分支的最后一次提交的对象，假设 <code>topic1</code> 分支指向 <code>ca82a6d</code> ，那么以下的命令是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">$ git show topic1</span><br></pre></td></tr></table></figure>

<p>如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1 ，你可以使用一个叫做 <code>rev-parse</code> 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。简单来说，<code>rev-parse</code> 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 <code>rev-parse</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-parse topic1</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure>

<h4 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用日志</h4><p>当你在工作时， Git 会在后台保存一个引用日志（reflog），引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p>
<p>你可以使用 <code>git reflog</code> 来查看引用日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">734713b HEAD@&#123;0&#125;: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">d921970 HEAD@&#123;1&#125;: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">1c002dd HEAD@&#123;2&#125;: commit: added some blame and merge stuff</span><br><span class="line">1c36188 HEAD@&#123;3&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">95df984 HEAD@&#123;4&#125;: commit: # This is a combination of two commits.</span><br><span class="line">1c36188 HEAD@&#123;5&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">7e05da5 HEAD@&#123;6&#125;: rebase -i (pick): updating HEAD</span><br></pre></td></tr></table></figure>

<p>每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 通过这些数据，你可以很方便地获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 <code>@{n}</code> 来引用 reflog 中输出的提交记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD@&#123;5&#125;</span><br></pre></td></tr></table></figure>

<p>你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 <code>master</code> 分支在昨天的时候指向了哪个提交，你可以输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show master@&#123;yesterday&#125;</span><br></pre></td></tr></table></figure>

<p>就会显示昨天该分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。</p>
<p>可以运行 <code>git log -g</code> 来查看类似于 <code>git log</code> 输出格式的引用日志信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log -g master</span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Reflog: master@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Reflog: master@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &apos;phedders/rdocs&apos;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，引用日志只存在于本地仓库，一个记录你在你自己的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 <code>git show HEAD@{2.months.ago}</code> 这条命令只有在你克隆了一个项目至少两个月时才会有用——如果你是五分钟前克隆的仓库，那么它将不会有结果返回。</p>
<h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h4><p>祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 <code>^</code>， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&apos;%h %s&apos; --graph</span><br><span class="line">* 734713b fixed refs handling, added gc auto, updated tests</span><br><span class="line">*   d921970 Merge commit &apos;phedders/rdocs&apos;</span><br><span class="line">|\</span><br><span class="line">| * 35cfb2b Some rdoc changes</span><br><span class="line">* | 1c002dd added some blame and merge stuff</span><br><span class="line">|/</span><br><span class="line">* 1c36188 ignore *.gem</span><br><span class="line">* 9b29157 add open3_detach to gemspec file list</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>HEAD^</code> 来查看上一个提交，也就是 “HEAD 的父提交”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^</span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &apos;phedders/rdocs&apos;</span><br></pre></td></tr></table></figure>

<p>你也可以在 <code>^</code> 后面添加一个数字——例如 <code>d921970^2</code> 代表 “d921970 的第二父提交” 这个语法只适用于合并（merge）的提交，因为合并提交会有多个父提交。 第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show d921970^</span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br><span class="line"></span><br><span class="line">$ git show d921970^2</span><br><span class="line">commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548</span><br><span class="line">Author: Paul Hedderly &lt;paul+git@mjr.org&gt;</span><br><span class="line">Date:   Wed Dec 10 22:22:03 2008 +0000</span><br><span class="line"></span><br><span class="line">    Some rdoc changes</span><br></pre></td></tr></table></figure>

<p>另一种指明祖先提交的方法是 <code>~</code>。 同样是指向第一父提交，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。 而区别在于你在后面加数字的时候。 <code>HEAD~2</code> 代表“第一父提交的第一父提交”，也就是“祖父提交”—— Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，<code>HEAD~3</code> 就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD~3</span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure>

<p>也可以写成 <code>HEAD^^^</code>，也是第一父提交的第一父提交的第一父提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^^^</span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure>

<p>你也可以组合使用这两个语法——你可以通过 <code>HEAD~3^2</code> 来取得之前引用的第二父提交（假设它是一个合并提交）。</p>
<h4 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h4><p>你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用，你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题</p>
<p><strong>双点</strong><br>最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.</p>
<p><img src="git-chapter-1/img1.png" alt></p>
<p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 <code>master..experiment</code> 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log master..experiment</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>反过来，如果你想查看在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交，你只要交换分支名即可。 <code>experiment..master</code> 会显示在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log experiment..master</span><br><span class="line">F</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<p>这可以让你保持 <code>experiment</code> 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin/master..HEAD</span><br></pre></td></tr></table></figure>

<p>这个命令会输出在你当前分支中而不在远程 <code>origin</code> 中的提交。 如果你执行 <code>git push</code> 并且你的当前分支正在跟踪 <code>origin/master</code>，由 <code>git log origin/master..HEAD</code> 所输出的提交就是会被传输到远端服务器的提交。 如果你留空了其中的一边， Git 会默认为 HEAD。 例如， <code>git log origin/master..</code> 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。</p>
<p><strong>多点</strong><br>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 <code>^</code> 字符或者 <code>--not</code> 来指明你不希望提交被包含其中的分支。 因此下列3个命令是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA..refB</span><br><span class="line">$ git log ^refA refB</span><br><span class="line">$ git log refB --not refA</span><br></pre></td></tr></table></figure>

<p>这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交，你可以输入下面中的任意一个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA refB ^refC</span><br><span class="line">$ git log refA refB --not refC</span><br></pre></td></tr></table></figure>

<p>这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。</p>
<p><strong>三点</strong><br>最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 <code>master</code> 或者 <code>experiment</code> 中包含的但不是两者共有的提交，你可以执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log master...experiment</span><br><span class="line">F</span><br><span class="line">E</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>这和通常 <code>log</code> 按日期排序的输出一样，仅仅给出了4个提交的信息。</p>
<p>这种情形下，<code>log</code> 命令的一个常用参数是 <code>--left-right</code>，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --left-right master...experiment</span><br><span class="line">&lt; F</span><br><span class="line">&lt; E</span><br><span class="line">&gt; D</span><br><span class="line">&gt; C</span><br></pre></td></tr></table></figure>

<p>有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。</p>
<h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><p>Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个交互命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 <code>git ad</code>d 时使用 <code>-i</code> 或者 <code>--interactive</code> 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add -i</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到这个命令以非常不同的视图显示了暂存区——基本上与 <code>git status</code> 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。</p>
<p>在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。</p>
<h4 id="暂存与取消暂存文件"><a href="#暂存与取消暂存文件" class="headerlink" title="暂存与取消暂存文件"></a>暂存与取消暂存文件</h4><p>如果在 <code>What now&gt;</code> 提示符后键入 <code>2</code> 或 <code>u</code>，脚本将会提示想要暂存哪个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 2</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>要暂存 TODO 与 index.html 文件，可以输入数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt; 1,2</span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:    unchanged        +0/-1 TODO</span><br><span class="line">* 2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>每个文件前面的 <code>*</code> 意味着选中的文件将会被暂存。 如果在 <code>Update&gt;&gt;</code> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt;</span><br><span class="line">updated 2 paths</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 <code>3</code> 或 <code>r</code>（撤消）选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 3</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; [enter]</span><br><span class="line">reverted one path</span><br></pre></td></tr></table></figure>

<p>再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>如果想要查看已暂存内容的区别，可以使用 <code>6</code> 或 <code>d</code>（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 <code>git diff --cached</code> 非常相似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 6</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +1/-1      nothing index.html</span><br><span class="line">Review diff&gt;&gt; 1</span><br><span class="line">diff --git a/index.html b/index.html</span><br><span class="line">index 4d07108..4335f49 100644</span><br><span class="line">--- a/index.html</span><br><span class="line">+++ b/index.html</span><br><span class="line">@@ -16,7 +16,7 @@ Date Finder</span><br><span class="line"></span><br><span class="line"> &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;</span><br><span class="line">+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。</p>
<h4 id="暂存补丁"><a href="#暂存补丁" class="headerlink" title="暂存补丁"></a>暂存补丁</h4><p>Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 <code>5</code> 或 <code>p</code>（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index dd5ecc4..57399e0 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -22,7 +22,7 @@ class SimpleGit</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def log(treeish = &apos;master&apos;)</span><br><span class="line">-    command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def blame(path)</span><br><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</span><br></pre></td></tr></table></figure>

<p>这时有很多选项。 输入 <code>?</code> 显示所有可以使用的命令列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">a - stage this and all the remaining hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure>

<p>通常情况下可以输入 <code>y</code> 或 <code>n</code> 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:        +1/-1        +4/-0 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 <code>git commit</code> 来提交部分暂存的文件。</p>
<p>也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code> 来启动同样的脚本。</p>
<p>更进一步地，可以使用 <code>reset --patch</code> 命令的补丁模式来部分重置文件，通过 <code>checkout --patch</code> 命令来部分检出文件与 <code>stash save --patch</code> 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。</p>
<h3 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h3><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p>
<p>储藏会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。</p>
<h4 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a>储藏工作</h4><p>为了演示，进入项目并改动几个文件，然后可能暂存其中的一个改动。 如果运行 <code>git status</code>，可以看到有改动的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   index.html</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>现在想要切换分支，但是还不想要提交之前的工作；所以储藏修改。 将新的储藏推送到栈上，运行 <code>git stash</code> 或 <code>git stash save</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \</span><br><span class="line">  &quot;WIP on master: 049d078 added the index file&quot;</span><br><span class="line">HEAD is now at 049d078 added the index file</span><br><span class="line">(To restore them type &quot;git stash apply&quot;)</span><br></pre></td></tr></table></figure>

<p>工作目录是干净的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p>在这时，你能够轻易地切换分支并在其他地方工作；你的修改被存储在栈上。 要查看储藏的东西，可以使用 <code>git stash list</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br></pre></td></tr></table></figure>

<p>在本例中，有两个之前做的储藏，所以你接触到了三个不同的储藏工作。 可以通过原来 <code>stash</code> 命令的帮助提示中的命令将你刚刚储藏的工作重新应用：<code>git stash apply</code>。 如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：<code>git stash apply stash@{2}</code>。 如果不指定一个储藏，Git 认为指定的是最近的储藏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line"># On branch master</span><br><span class="line"># Changed but not updated:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>可以看到 Git 重新修改了当你保存储藏时撤消的文件。 在本例中，当尝试应用储藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支；但是有一个干净的工作目录与应用在同一分支并不是成功应用储藏的充分必要条件。 可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用储藏时工作目录中也可以有修改与未提交的文件——如果有任何东西不能干净地应用，Git 会产生合并冲突。</p>
<p>文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 <code>--index</code> 选项来运行 <code>git stash apply</code> 命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply --index</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changed but not updated:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>应用选项只会尝试应用暂存的工作——在堆栈上还有它。 可以运行 <code>git stash drop</code> 加上将要移除的储藏的名字来移除它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure>

<p>也可以运行 <code>git stash pop</code> 来应用储藏然后立即从栈上扔掉它。</p>
<h4 id="创造性的储藏"><a href="#创造性的储藏" class="headerlink" title="创造性的储藏"></a>创造性的储藏</h4><p>有几个储藏的变种可能也很有用。 第一个非常流行的选项是 <code>stash save</code> 命令的 <code>--keep-index</code> 选项。 它告诉 Git 不要储藏任何你通过 <code>git add</code> 命令已暂存的东西。</p>
<p>当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  index.html</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">$ git stash --keep-index</span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br><span class="line">HEAD is now at 1b65b17 added the index file</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">M  index.html</span><br></pre></td></tr></table></figure>

<p>另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。 默认情况下，<code>git stash</code> 只会储藏已经在索引中的文件。 如果指定 <code>--include-untracked</code> 或 <code>-u</code> 标记，Git 也会储藏任何创建的未跟踪文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  index.html</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line">?? new-file.txt</span><br><span class="line"></span><br><span class="line">$ git stash -u</span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br><span class="line">HEAD is now at 1b65b17 added the index file</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>最终，如果指定了 <code>--patch</code> 标记，Git 不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git stash --patch</span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index 66d332e..8bb5674 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -16,6 +16,10 @@ class SimpleGit</span><br><span class="line">         return `#&#123;git_cmd&#125; 2&gt;&amp;1`.chomp</span><br><span class="line">       end</span><br><span class="line">     end</span><br><span class="line">+</span><br><span class="line">+    def show(treeish = &apos;master&apos;)</span><br><span class="line">+      command(&quot;git show #&#123;treeish&#125;&quot;)</span><br><span class="line">+    end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line"> test</span><br><span class="line">Stash this hunk [y,n,q,a,d,/,e,?]? y</span><br><span class="line"></span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br></pre></td></tr></table></figure>

<h4 id="从储藏创建一个分支"><a href="#从储藏创建一个分支" class="headerlink" title="从储藏创建一个分支"></a>从储藏创建一个分支</h4><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash branch testchanges</span><br><span class="line">Switched to a new branch &quot;testchanges&quot;</span><br><span class="line"># On branch testchanges</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changed but not updated:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure>

<p>这是在新分支轻松恢复储藏工作并继续工作的一个很不错的途径。</p>
<h4 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h4><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。 <code>git clean</code> 命令会帮你做这些事。</p>
<p>有一些通用的原因比如说为了移除由合并或外部工具生成的东西，或是为了运行一个干净的构建而移除之前构建的残留。</p>
<p>你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 <code>git stash --all</code> 来移除每一样东西并存放在栈中。</p>
<p>你可以使用 <code>git clean</code> 命令去除冗余文件或者清理工作目录。 使用 <code>git clean -f -d</code> 命令来移除工作目录中所有未追踪的文件以及空的子目录。 <code>-f</code> 意味着 强制 或 “确定移除”。</p>
<p>如果只是想要看看它会做什么，可以使用 <code>-n</code> 选项来运行命令，这意味着 “做一次演习然后告诉你 将要 移除什么”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -d -n</span><br><span class="line">Would remove test.o</span><br><span class="line">Would remove tmp/</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>git clean</code> 命令只会移除没有忽略的未跟踪文件。 任何与 <code>.gitiignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 <code>.o</code> 文件，可以给 <code>clean</code> 命令增加一个 <code>-x</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line">?? build.TMP</span><br><span class="line">?? tmp/</span><br><span class="line"></span><br><span class="line">$ git clean -n -d</span><br><span class="line">Would remove build.TMP</span><br><span class="line">Would remove tmp/</span><br><span class="line"></span><br><span class="line">$ git clean -n -d -x</span><br><span class="line">Would remove build.TMP</span><br><span class="line">Would remove test.o</span><br><span class="line">Would remove tmp/</span><br></pre></td></tr></table></figure>

<p>如果不知道 <code>git clean</code> 命令将会做什么，在将 <code>-n</code> 改为 <code>-f</code> 来真正做之前总是先用 <code>-n</code> 来运行它做双重检查。 另一个小心处理过程的方式是使用 <code>-i</code> 或 “interactive” 标记来运行它。</p>
<p>这将会以交互模式运行 <code>clean</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -x -i</span><br><span class="line">Would remove the following items:</span><br><span class="line">  build.TMP  test.o</span><br><span class="line">*** Commands ***</span><br><span class="line">    1: clean    2: filter by pattern    3: select by numbers    4: ask each    5: quit    6: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure>

<p>这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。</p>
<h3 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h3><p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<h4 id="GPG-介绍"><a href="#GPG-介绍" class="headerlink" title="GPG 介绍"></a>GPG 介绍</h4><p>首先，在开始签名之前你需要先配置 GPG 并安装个人密钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line">/Users/schacon/.gnupg/pubring.gpg</span><br><span class="line">---------------------------------</span><br><span class="line">pub   2048R/0A46826A 2014-06-04</span><br><span class="line">uid                  Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line">sub   2048R/874529A9 2014-06-04</span><br></pre></td></tr></table></figure>

<p>如果你还没有安装一个密钥，可以使用 <code>gpg --gen-key</code> 生成一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure>

<p>一旦你有一个可以签署的私钥，可以通过设置 Git 的 <code>user.signingkey</code> 选项来签署。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.signingkey 0A46826A</span><br></pre></td></tr></table></figure>

<p>现在 Git 默认使用你的密钥来签署标签与提交。</p>
<h4 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h4><p>如果已经设置好一个 GPG 私钥，可以使用它来签署新的标签。 所有需要做的只是使用 <code>-s</code> 代替 <code>-a</code> 即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Ben Straub &lt;ben@straub.cc&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 800430EB, created 2014-05-04</span><br></pre></td></tr></table></figure>

<p>如果在那个标签上运行 <code>git show</code>，会看到你的 GPG 签名附属在后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.5</span><br><span class="line">tag v1.5</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:29:41 2014 -0700</span><br><span class="line"></span><br><span class="line">my signed 1.5 tag</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut</span><br><span class="line">LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b</span><br><span class="line">hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm</span><br><span class="line">ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp</span><br><span class="line">8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi</span><br><span class="line">RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=</span><br><span class="line">=EFTF</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>

<h4 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h4><p>要验证一个签署的标签，可以运行 <code>git tag -v [tag-name]</code>。 这个命令使用 GPG 来验证签名。 为了验证能正常工作，签署者的公钥需要在你的钥匙链中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -v v1.4.2.1</span><br><span class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line">type commit</span><br><span class="line">tag v1.4.2.1</span><br><span class="line">tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700</span><br><span class="line"></span><br><span class="line">GIT 1.4.2.1</span><br><span class="line"></span><br><span class="line">Minor fixes since 1.4.2, including git-mv and git-http with alternates.</span><br><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;</span><br><span class="line">gpg:                 aka &quot;[jpeg image of size 1513]&quot;</span><br><span class="line">Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</span><br></pre></td></tr></table></figure>

<p>如果没有签署者的公钥，那么你将会得到类似下面的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can&apos;t check signature: public key not found</span><br><span class="line">error: could not verify the tag &apos;v1.4.2.1&apos;</span><br></pre></td></tr></table></figure>

<h4 id="签署提交"><a href="#签署提交" class="headerlink" title="签署提交"></a>签署提交</h4><p>在最新版本的 Git 中（v1.7.9 及以上），也可以签署个人提交。 如果相对于标签而言你对直接签署到提交更感兴趣的话，所有要做的只是增加一个 <code>-S</code> 到 <code>git commit</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -S -m &apos;signed commit&apos;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 0A46826A, created 2014-06-04</span><br><span class="line"></span><br><span class="line">[master 5c3386c] signed commit</span><br><span class="line"> 4 files changed, 4 insertions(+), 24 deletions(-)</span><br><span class="line"> rewrite Rakefile (100%)</span><br><span class="line"> create mode 100644 lib/git.rb</span><br><span class="line">git log 也有一个 --show-signature 选项来查看及验证这些签名。</span><br><span class="line"></span><br><span class="line">$ git log --show-signature -1</span><br><span class="line">commit 5c3386cf54bba0a33a32da706aa52bc0155503c2</span><br><span class="line">gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A</span><br><span class="line">gpg: Good signature from &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Jun 4 19:49:17 2014 -0700</span><br><span class="line"></span><br><span class="line">    signed commit</span><br></pre></td></tr></table></figure>

<p>另外，也可以配置 <code>git log</code> 来验证任何找到的签名并将它们以 <code>%G?</code> 格式列在输出中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=&quot;format:%h %G? %aN  %s&quot;</span><br><span class="line"></span><br><span class="line">5c3386c G Scott Chacon  signed commit</span><br><span class="line">ca82a6d N Scott Chacon  changed the version number</span><br><span class="line">085bb3b N Scott Chacon  removed unnecessary test code</span><br><span class="line">a11bef0 N Scott Chacon  first commit</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到只有最后一次提交是签署并有效的，而之前的提交都不是。</p>
<p>在 Git 1.8.3 及以后的版本中，“git merge” 与“git pull” 可以使用 <code>--verify-signatures</code> 选项来检查并拒绝没有携带可信 GPG 签名的提交。</p>
<p>如果使用这个选项来合并一个包含未签名或有效的提交的分支时，合并不会生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --verify-signatures non-verify</span><br><span class="line">fatal: Commit ab06180 does not have a GPG signature.</span><br></pre></td></tr></table></figure>

<p>如果合并包含的只有有效的签名的提交，合并命令会提示所有的签名它已经检查过了然后会继续向前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --verify-signatures signed-branch</span><br><span class="line">Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line">Updating 5c3386c..13ad65e</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p>也可以给 <code>git merge</code> 命令附加 <code>-S</code> 选项来签署自己生成的合并提交。 下面的例子演示了验证将要合并的分支的每一个提交都是签名的并且签署最后生成的合并提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --verify-signatures -S  signed-branch</span><br><span class="line">Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 0A46826A, created 2014-06-04</span><br><span class="line"></span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> README | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<h4 id="每个人必须签署"><a href="#每个人必须签署" class="headerlink" title="每个人必须签署"></a>每个人必须签署</h4><p>签署标签与提交很棒，但是如果决定在正常的工作流程中使用它，你必须确保团队中的每一个人都理解如何这样做。 如果没有，你将会花费大量时间帮助其他人找出并用签名的版本重写提交。 在采用签署成为标准工作流程的一部分前，确保你完全理解 GPG 及签署带来的好处。</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。 我们来简单的看一下。</p>
<h4 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h4><p>Git 提供了一个 <code>grep</code> 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。</p>
<p>默认情况下 Git 会查找你工作目录的文件。 你可以传入 <code>-n</code> 参数来输出 Git 所找到的匹配行行号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -n gmtime_r</span><br><span class="line">compat/gmtime.c:3:#undef gmtime_r</span><br><span class="line">compat/gmtime.c:8:      return git_gmtime_r(timep, &amp;result);</span><br><span class="line">compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)</span><br><span class="line">compat/gmtime.c:16:     ret = gmtime_r(timep, result);</span><br><span class="line">compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm *result)</span><br><span class="line">compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm *result);</span><br><span class="line">date.c:429:             if (gmtime_r(&amp;now, &amp;now_tm))</span><br><span class="line">date.c:492:             if (gmtime_r(&amp;time, tm)) &#123;</span><br><span class="line">git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm *);</span><br><span class="line">git-compat-util.h:723:#define gmtime_r git_gmtime_r</span><br></pre></td></tr></table></figure>

<p><code>grep</code> 命令有一些有趣的选项。</p>
<p>例如，你可以使用 <code>--count</code> 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git grep --count gmtime_r</span><br><span class="line">compat/gmtime.c:4</span><br><span class="line">compat/mingw.c:1</span><br><span class="line">compat/mingw.h:1</span><br><span class="line">date.c:2</span><br><span class="line">git-compat-util.h:2</span><br></pre></td></tr></table></figure>

<p>如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 <code>-p</code> 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -p gmtime_r *.c</span><br><span class="line">date.c=static int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)</span><br><span class="line">date.c:         if (gmtime_r(&amp;now, &amp;now_tm))</span><br><span class="line">date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)</span><br><span class="line">date.c:         if (gmtime_r(&amp;time, tm)) &#123;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到在 date.c 文件中有 <code>match_multi_number</code> 和 <code>match_digit</code> 两个函数调用了 <code>gmtime_r</code>。</p>
<p>你还可以使用 <code>--and</code> 标志来查看复杂的字符串组合，也就是在同一行同时包含多个匹配。 比如，我们要查看在旧版本 1.8.0 的 Git 代码库中定义了常量名包含 “LINK” 或者 “BUF_MAX” 这两个字符串所在的行。</p>
<p>这里我们也用到了 <code>--break</code> 和 <code>--heading</code> 选项来使输出更加容易阅读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git grep --break --heading \</span><br><span class="line">    -n -e &apos;#define&apos; --and \( -e LINK -e BUF_MAX \) v1.8.0</span><br><span class="line">v1.8.0:builtin/index-pack.c</span><br><span class="line">62:#define FLAG_LINK (1u&lt;&lt;20)</span><br><span class="line"></span><br><span class="line">v1.8.0:cache.h</span><br><span class="line">73:#define S_IFGITLINK  0160000</span><br><span class="line">74:#define S_ISGITLINK(m)       (((m) &amp; S_IFMT) == S_IFGITLINK)</span><br><span class="line"></span><br><span class="line">v1.8.0:environment.c</span><br><span class="line">54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS</span><br><span class="line"></span><br><span class="line">v1.8.0:strbuf.c</span><br><span class="line">326:#define STRBUF_MAXLINK (2*PATH_MAX)</span><br><span class="line"></span><br><span class="line">v1.8.0:symlinks.c</span><br><span class="line">53:#define FL_SYMLINK  (1 &lt;&lt; 2)</span><br><span class="line"></span><br><span class="line">v1.8.0:zlib.c</span><br><span class="line">30:/* #define ZLIB_BUF_MAX ((uInt)-1) */</span><br><span class="line">31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</span><br></pre></td></tr></table></figure>

<p>相比于一些常用的搜索命令比如 <code>grep</code> 和 <code>ack</code>，<code>git grep</code> 命令有一些的优点。 第一就是速度非常快，第二是你不仅仅可以可以搜索工作目录，还可以搜索任意的 Git 树。 在上一个例子中，我们在一个旧版本的 Git 源代码中查找，而不是当前检出的版本。</p>
<h4 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h4><p>或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。 <code>git log</code> 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p>
<p>例如，如果我们想找到 <code>ZLIB_BUF_MAX</code> 常量是什么时候引入的，我们可以使用 <code>-S</code> 选项来显示新增和删除该字符串的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log -SZLIB_BUF_MAX --oneline</span><br><span class="line">e01503b zlib: allow feeding more than 4GB in one go</span><br><span class="line">ef49a7a zlib: zlib can only process 4GB at a time</span><br></pre></td></tr></table></figure>

<p>如果我们查看这些提交的 diff，我们可以看到在 <code>ef49a7a</code> 这个提交引入了常量，并且在 <code>e01503b</code> 这个提交中被修改了。</p>
<p>如果你希望得到更精确的结果，你可以使用 <code>-G</code> 选项来使用正则表达式搜索。</p>
<p><strong>行日志搜索</strong><br>行日志搜索是另一个相当高级并且有用的日志搜索功能。 这是一个最近新增的不太知名的功能，但却是十分有用。 在 <code>git log</code> 后加上 <code>-L</code> 选项即可调用，它可以展示代码中一行或者一个函数的历史。</p>
<p>例如，假设我们想查看 <code>zlib.c</code> 文件中<code>git_deflate_bound</code> 函数的每一次变更，我们可以执行 <code>git log -L :git_deflate_bound:zlib.c</code>。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ git log -L :git_deflate_bound:zlib.c</span><br><span class="line">commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca</span><br><span class="line">Author: Junio C Hamano &lt;gitster@pobox.com&gt;</span><br><span class="line">Date:   Fri Jun 10 11:52:15 2011 -0700</span><br><span class="line"></span><br><span class="line">    zlib: zlib can only process 4GB at a time</span><br><span class="line"></span><br><span class="line">diff --git a/zlib.c b/zlib.c</span><br><span class="line">--- a/zlib.c</span><br><span class="line">+++ b/zlib.c</span><br><span class="line">@@ -85,5 +130,5 @@</span><br><span class="line">-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)</span><br><span class="line">+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)</span><br><span class="line"> &#123;</span><br><span class="line">-       return deflateBound(strm, size);</span><br><span class="line">+       return deflateBound(&amp;strm-&gt;z, size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit 225a6f1068f71723a910e8565db4e252b3ca21fa</span><br><span class="line">Author: Junio C Hamano &lt;gitster@pobox.com&gt;</span><br><span class="line">Date:   Fri Jun 10 11:18:17 2011 -0700</span><br><span class="line"></span><br><span class="line">    zlib: wrap deflateBound() too</span><br><span class="line"></span><br><span class="line">diff --git a/zlib.c b/zlib.c</span><br><span class="line">--- a/zlib.c</span><br><span class="line">+++ b/zlib.c</span><br><span class="line">@@ -81,0 +85,5 @@</span><br><span class="line">+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)</span><br><span class="line">+&#123;</span><br><span class="line">+       return deflateBound(strm, size);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<p>如果 Git 无法计算出如何匹配你代码中的函数或者方法，你可以提供一个正则表达式。 例如，这个命令和上面的是等同的：<code>git log -L &#39;/unsigned long git_deflate_bound/&#39;,/^}/:zlib.c</code>。 你也可以提供单行或者一个范围的行号来获得相同的输出。</p>
<h3 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h3><p>许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，或完全地移除提交——在将你的工作成果与他人共享之前。</p>
<p>在本节中，你可以学到如何完成这些非常有用的工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。</p>
<h4 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h4><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。</p>
<p>如果，你只是想修改最近一次提交的提交信息，那么很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。 当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。</p>
<p>如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行 <code>git add</code> 或 <code>git rm</code> 一个已追踪的文件，随后运行 <code>git commit --amend</code> 拿走当前的暂存区域并使其做为新提交的快照。</p>
<p>使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。</p>
<h4 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h4><p>为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 <code>git rebase</code> 增加 <code>-i</code> 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。</p>
<p>例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给 <code>git rebase -i</code> 命令，即 <code>HEAD~2^</code> 或 <code>HEAD~3</code>。 记住 <code>~3</code> 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>再次记住这是一个变基命令——在 <code>HEAD~3..HEAD</code> 范围内的每一个提交都会被重写，无论你是否修改信息。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。</p>
<p>运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"></span><br><span class="line"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure>

<p>需要重点注意的是相对于正常使用的 <code>log</code> 命令，这些提交显示的顺序是相反的。 运行一次 <code>log</code> 命令，会看到类似这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEAD</span><br><span class="line">a5f4a0d added cat-file</span><br><span class="line">310154e updated README formatting and added blame</span><br><span class="line">f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（<code>HEAD~3</code>）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。</p>
<p>你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br><span class="line">Stopped at f7f3f6d... changed my name a bit</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">       git commit --amend</span><br><span class="line"></span><br><span class="line">Once you’re satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">       git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这些指令准确地告诉你该做什么。 输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>修改提交信息，然后退出编辑器。 然后，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。</p>
<h4 id="重新排序提交"><a href="#重新排序提交" class="headerlink" title="重新排序提交"></a>重新排序提交</h4><p>也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>改为这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 <code>310154e</code> 然后应用 <code>f7f3f6d</code>，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。</p>
<h4 id="压缩提交"><a href="#压缩提交" class="headerlink" title="压缩提交"></a>压缩提交</h4><p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure>

<p>如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">squash 310154e updated README formatting and added blame</span><br><span class="line">squash a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># The first commit&apos;s message is:</span><br><span class="line">changed my name a bit</span><br><span class="line"></span><br><span class="line"># This is the 2nd commit message:</span><br><span class="line"></span><br><span class="line">updated README formatting and added blame</span><br><span class="line"></span><br><span class="line"># This is the 3rd commit message:</span><br><span class="line"></span><br><span class="line">added cat-file</span><br></pre></td></tr></table></figure>

<p>当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。</p>
<h4 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h4><p>拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 <code>rebase -i</code> 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">edit 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>然后，当脚本将你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（<code>f7f3f6d</code>），应用第二个提交（<code>310154e</code>），然后让你进入命令行。 那里，可以通过 <code>git reset HEAD^</code> 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件未暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 <code>git rebase --continue</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &apos;updated README formatting&apos;</span><br><span class="line">$ git add lib/simplegit.rb</span><br><span class="line">$ git commit -m &apos;added blame&apos;</span><br><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure>

<p>Git 在脚本中应用最后一次提交（<code>a5f4a0d</code>），历史记录看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log -4 --pretty=format:&quot;%h %s&quot;</span><br><span class="line">1c002dd added cat-file</span><br><span class="line">9b29157 added blame</span><br><span class="line">35cfb2b updated README formatting</span><br><span class="line">f3cc40e changed my name a bit</span><br></pre></td></tr></table></figure>

<p>再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。</p>
<h4 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h4><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 <code>filter-branch</code>，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。</p>
<p><strong>从每一个提交移除一个文件</strong><br>这经常发生。 有人粗心地通过 <code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除它。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 <code>filter-branch</code> 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 <code>--tree-filter</code> 选项给 <code>filter-branch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</span><br><span class="line">Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)</span><br><span class="line">Ref &apos;refs/heads/master&apos; was rewritten</span><br></pre></td></tr></table></figure>

<p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 <code>git filter-branch --tree-filter &#39;rm -f *~&#39; HEAD</code> 的命令。</p>
<p>最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 <code>filter-branch</code> 在所有分支上运行，可以给命令传递 <code>--all</code> 选项。</p>
<p><strong>使一个子目录做为新的根目录</strong><br>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，<code>filter-branch</code> 也可以帮助你那么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --subdirectory-filter trunk HEAD</span><br><span class="line">Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)</span><br><span class="line">Ref &apos;refs/heads/master&apos; was rewritten</span><br></pre></td></tr></table></figure>

<p>现在新项目根目录是 <code>trunk</code> 子目录了。 Git 会自动移除所有不影响子目录的提交。</p>
<p><strong>全局修改邮箱地址</strong><br>另一个常见的情形是在你开始工作时忘记运行 <code>git config</code> 来设置你的名字与邮箱地址，或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 <code>filter-branch</code> 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 <code>--commit-filter</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --commit-filter &apos;</span><br><span class="line">        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&apos; HEAD</span><br></pre></td></tr></table></figure>

<p>这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和，而不仅仅只是那些匹配邮箱地址的提交。</p>
<h3 id="重置揭密"><a href="#重置揭密" class="headerlink" title="重置揭密"></a>重置揭密</h3><p>在继续了解更专业的工具前，我们先讨论一下 <code>reset</code> 与 <code>checkout</code>。 在你初次遇到的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。</p>
<h4 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h4><p>理解 <code>reset</code> 和 <code>checkout</code> 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）</p>
<p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p>
<table>
<thead>
<tr>
<th>树</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>HEAD</td>
<td>上一次提交的快照，下一次提交的父结点</td>
</tr>
<tr>
<td>Index</td>
<td>预期的下一次提交的快照</td>
</tr>
<tr>
<td>Working Directory</td>
<td>沙盒</td>
</tr>
</tbody></table>
<p><strong>HEAD</strong><br>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。</p>
<p>其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">author Scott Chacon  1301511835 -0700</span><br><span class="line">committer Scott Chacon  1301511835 -0700</span><br><span class="line"></span><br><span class="line">initial commit</span><br><span class="line"></span><br><span class="line">$ git ls-tree -r HEAD</span><br><span class="line">100644 blob a906cb2a4a904a152...   README</span><br><span class="line">100644 blob 8f94139338f9404f2...   Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19...   lib</span><br></pre></td></tr></table></figure>

<p><code>cat-file</code> 与 <code>ls-tree</code> 是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。</p>
<p><strong>索引</strong><br>索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区域”，这就是当你运行 <code>git commit</code> 时 Git 看起来的样子。</p>
<p>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 <code>git commit</code> 将它们转换为树来用作新的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README</span><br><span class="line">100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile</span><br><span class="line">100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>再说一次，我们在这里又用到了 <code>ls-files</code> 这个幕后的命令，它会显示出索引当前的样子。</p>
<p>确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。</p>
<p><strong>工作目录</strong><br>最后，你就有了自己的工作目录。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 <code>.git</code> 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── README</span><br><span class="line">├── Rakefile</span><br><span class="line">└── lib</span><br><span class="line">    └── simplegit.rb</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>Git 主要的目的是通过操纵这三棵树来以更加连续的状态记录项目的快照。</p>
<p><img src="git-chapter-7/img1.png" alt></p>
<p>让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 <code>git init</code>，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（<code>master</code> 还不存在）。</p>
<p><img src="git-chapter-7/img2.png" alt></p>
<p>此时，只有工作目录有内容。</p>
<p>现在我们想要提交这个文件，所以用 <code>git add</code> 来获取工作目录中的内容，并将其复制到索引中。</p>
<p><img src="git-chapter-7/img3.png" alt></p>
<p>接着运行 <code>git commit</code>，它会取得索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 <code>master</code> 来指向本次提交。</p>
<p><img src="git-chapter-7/img4.png" alt></p>
<p>此时如果我们运行 <code>git status</code>，会发现没有任何改动，因为现在三棵树完全相同。</p>
<p>现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。</p>
<p><img src="git-chapter-7/img5.png" alt></p>
<p>如果现在运行 <code>git status</code>，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 <code>git add</code> 来将它暂存到索引中。</p>
<p><img src="git-chapter-7/img6.png" alt></p>
<p>此时，由于索引和 HEAD 不同，若运行 <code>git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 <code>git commit</code> 来完成提交。</p>
<p><img src="git-chapter-7/img7.png" alt></p>
<p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了。</p>
<p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。</p>
<h4 id="重置的作用"><a href="#重置的作用" class="headerlink" title="重置的作用"></a>重置的作用</h4><p>在以下情景中观察 <code>reset</code> 命令会更有意义。</p>
<p>为了演示这些例子，假设我们再次修改了 <code>file.txt</code> 文件并第三次提交它。 现在的历史看起来是这样的：</p>
<p><img src="git-chapter-7/img8.png" alt></p>
<p>让我们跟着 <code>reset</code> 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。</p>
<p><strong>第 1 步：移动 HEAD</strong><br><code>reset</code> 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（<code>checkout</code> 所做的）；<code>reset</code> 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 <code>master</code> 分支（例如，你正在 <code>master</code> 分支上），运行 <code>git reset 9e5e6a4</code> 将会使 <code>master</code> 指向 <code>9e5e6a4</code>。</p>
<p><img src="git-chapter-7/img9.png" alt></p>
<p>无论你调用了何种形式的带有一个提交的 <code>reset</code>，它首先都会尝试这样做。 使用 <code>reset --soft</code>，它将仅仅停在那儿。</p>
<p>现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code>git commit</code> 命令。 当你在运行 <code>git commit</code> 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 <code>reset</code> 回 <code>HEAD~</code>（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit --amend</code> 所要做的事情了（见 修改最后一次提交）。</p>
<p><strong>第 2 步：更新索引（–mixed）</strong><br>注意，如果你现在运行 <code>git status</code> 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。</p>
<p>接下来，<code>reset</code> 会用 HEAD 指向的当前快照的内容来更新索引。</p>
<p><img src="git-chapter-7/img10.png" alt></p>
<p>如果指定 <code>--mixed</code> 选项，<code>reset</code> 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 <code>git reset HEAD~</code>），这就是命令将会停止的地方。</p>
<p>现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 <code>git add</code> 和 <code>git commit</code> 的命令执行之前。</p>
<p><strong>第 3 步：更新工作目录（–hard）</strong><br><code>reset</code> 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 <code>--hard</code> 选项，它将会继续这一步。</p>
<p><img src="git-chapter-7/img11.png" alt></p>
<p>现在让我们回想一下刚才发生的事情。 你撤销了最后的提交 <code>git add</code> 和 <code>git commit</code> 命令以及工作目录中的所有工作。</p>
<p>必须注意，<code>--hard</code> 标记是 <code>reset</code> 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 <code>reset</code> 调用都可以轻松撤消，但是 <code>--hard</code> 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本，我们可以通过 <code>reflog</code> 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。</p>
<p><strong>回顾</strong><br><code>reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p>
<ol>
<li><p>移动 HEAD 分支的指向 （若指定了 <code>--soft</code>，则到此停止）</p>
</li>
<li><p>使索引看起来像 HEAD （若未指定 <code>--hard</code>，则到此停止）</p>
</li>
<li><p>使工作目录看起来像索引</p>
</li>
</ol>
<h4 id="通过路径来重置"><a href="#通过路径来重置" class="headerlink" title="通过路径来重置"></a>通过路径来重置</h4><p>前面讲述了 <code>reset</code> 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，<code>reset</code> 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。</p>
<p>现在，假如我们运行 <code>git reset file.txt</code> （这其实是 <code>git reset --mixed HEAD file.txt</code> 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 <code>--soft</code> 或 <code>--hard</code>），它会：</p>
<ol>
<li><p>移动 HEAD 分支的指向 （已跳过）</p>
</li>
<li><p>让索引看起来像 HEAD （到此处停止）</p>
</li>
</ol>
<p>所以它本质上只是将 <code>file.txt</code> 从 HEAD 复制到索引中。</p>
<p><img src="git-chapter-7/img12.png" alt></p>
<p>它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 <code>git add</code> 所做的事，就会发现它们正好相反。</p>
<p><img src="git-chapter-7/img13.png" alt></p>
<p>这就是为什么 <code>git status</code> 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）</p>
<p>我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 <code>git reset eb43bf file.txt</code> 的命令即可。</p>
<p><img src="git-chapter-7/img14.png" alt></p>
<p>它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 <code>git add</code> 添加它，然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 <code>git commit</code>，它就会记录一条“将该文件恢复到 v1 版本”的更改，尽管我们并未在工作目录中真正地再次拥有它。</p>
<p>还有一点同 <code>git add</code> 一样，就是 <code>reset</code> 命令也可以接受一个 <code>--patch</code> 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。</p>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。</p>
<p>假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 <code>reset</code> 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）</p>
<p>假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。</p>
<p><img src="git-chapter-7/img15.png" alt></p>
<p>那么可以运行 <code>git reset --soft HEAD~2</code> 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的第一个提交）：</p>
<p><img src="git-chapter-7/img16.png" alt></p>
<p>然后只需再次运行 <code>git commit</code>：</p>
<p><img src="git-chapter-7/img17.png" alt></p>
<p>现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 <code>file-a.txt</code> 的提交，接着第二个提交将 <code>file-a.txt</code> 修改成了 v3 版并增加了 <code>file-b.txt</code>。 包含 v2 版本的文件已经不在历史中了。</p>
<h4 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h4><p>最后，你大概还想知道 <code>checkout</code> 和 <code>reset</code> 之间的区别。 和 <code>reset</code> 一样，<code>checkout</code> 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p>
<p><strong>不带路径</strong><br>运行 <code>git checkout [branch]</code> 与运行 <code>git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code>[branch]</code>，不过有两点重要的区别。</p>
<p>首先不同于 <code>reset --hard</code>，<code>checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。</p>
<p>第二个重要的区别是如何更新 HEAD。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 只会移动 HEAD 自身来指向另一个分支。</p>
<p>例如，假设我们有 <code>master</code> 和 <code>develop</code> 分支，它们分别指向不同的提交；我们现在在 <code>develop</code> 上（所以 HEAD 指向它）。 如果我们运行 <code>git reset master</code>，那么 <code>develop</code> 自身现在会和 <code>master</code> 指向同一个提交。 而如果我们运行 <code>git checkout master</code> 的话，<code>develop</code> 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 <code>master</code>。</p>
<p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 则移动 HEAD 自身。</p>
<p><img src="git-chapter-7/img18.png" alt></p>
<p><strong>带路径</strong><br>运行 <code>checkout</code> 的另一种方式就是指定一个文件路径，这会像 <code>reset</code> 一样不会移动 HEAD。 它就像 <code>git reset [branch] file</code> 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 <code>git reset --hard [branch] file</code>（如果 <code>reset</code> 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。</p>
<p>此外，同 <code>git reset</code> 和 <code>git add</code> 一样，<code>checkout</code> 也接受一个 <code>--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>希望你现在熟悉并理解了 <code>reset</code> 命令，不过关于它和 <code>checkout</code> 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。</p>
<p>下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。</p>
<table>
<thead>
<tr>
<th></th>
<th>HEAD</th>
<th>Index</th>
<th>Workdir</th>
<th>WD Safe?</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Commit Level</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset –soft [commit]</td>
<td>REF</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>reset  [commit]</td>
<td>REF</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>reset –hard [commit]</td>
<td>REF</td>
<td>YES</td>
<td>YES</td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>checkout [commit]</td>
<td>HEAD</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td><strong>File  Level</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset (commit) [file]</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>checkout (commit) [file]</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td><strong>NO</strong></td>
</tr>
</tbody></table>
<h3 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h3><p>在 Git 中合并是相当容易的。 因为 Git 使多次合并另一个分支变得很容易，这意味着你可以有一个始终保持最新的长期分支，经常解决小的冲突，比在一系列提交后解决一个巨大的冲突要好。</p>
<p>然而，有时也会有棘手的冲突。 不像其他的版本控制系统，Git 并不会尝试过于聪明的合并冲突解决方案。 Git 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。 因此，如果很久之后才合并两个分叉的分支，你可能会撞上一些问题。</p>
<p>在本节中，我们将会仔细查看那些问题是什么以及 Git 给了我们什么工具来帮助我们处理这些更难办的情形。我们也会了解你可以做的不同的、非标准类型的合并，也会看到如何后退到合并之前。</p>
<h4 id="高级合并-1"><a href="#高级合并-1" class="headerlink" title="高级合并"></a>高级合并</h4><p>我们在 遇到冲突时的分支合并 介绍了解决合并冲突的一些基础知识，对于更复杂的冲突，Git 提供了几个工具来帮助你指出将会发生什么以及如何更好地处理冲突。</p>
<p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。 如果你有正在做的工作，要么提交到一个临时分支要么储藏它。 这使你可以撤消在这里尝试做的 任何事情 。 如果在你尝试一次合并时工作目录中有未保存的改动，下面的这些技巧可能会使你丢失那些工作。</p>
<p>让我们通过一个非常简单的例子来了解一下。 我们有一个超级简单的打印 hello world 的 Ruby 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">  puts &apos;hello world&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>在我们的仓库中，创建一个名为 <code>whitespace</code> 的新分支并将所有 Unix 换行符修改为 DOS 换行符，实质上虽然改变了文件的每一行，但改变的都只是空白字符。 然后我们修改行 “hello world” 为 “hello mundo”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b whitespace</span><br><span class="line">Switched to a new branch &apos;whitespace&apos;</span><br><span class="line"></span><br><span class="line">$ unix2dos hello.rb</span><br><span class="line">unix2dos: converting file hello.rb to DOS format ...</span><br><span class="line">$ git commit -am &apos;converted hello.rb to DOS&apos;</span><br><span class="line">[whitespace 3270f76] converted hello.rb to DOS</span><br><span class="line"> 1 file changed, 7 insertions(+), 7 deletions(-)</span><br><span class="line"></span><br><span class="line">$ vim hello.rb</span><br><span class="line">$ git diff -b</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..e85207e 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,7 +1,7 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line"> def hello</span><br><span class="line">-  puts &apos;hello world&apos;</span><br><span class="line">+  puts &apos;hello mundo&apos;^M</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br><span class="line"></span><br><span class="line">$ git commit -am &apos;hello mundo change&apos;</span><br><span class="line">[whitespace 6d338d2] hello mundo change</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>现在我们切换回我们的 <code>master</code> 分支并为函数增加一些注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line"></span><br><span class="line">$ vim hello.rb</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..36c06c8 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">   puts &apos;hello world&apos;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line">$ git commit -am &apos;document the function&apos;</span><br><span class="line">[master bec6336] document the function</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在我们尝试合并入我们的 <code>whitespace</code> 分支，因为修改了空白字符，所以合并会出现冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge whitespace</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<h5 id="中断一次合并"><a href="#中断一次合并" class="headerlink" title="中断一次合并"></a>中断一次合并</h5><p>我们现在有几个选项。 首先，让我们介绍如何摆脱这个情况。 你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status -sb</span><br><span class="line">## master</span><br><span class="line">UU hello.rb</span><br><span class="line"></span><br><span class="line">$ git merge --abort</span><br><span class="line"></span><br><span class="line">$ git status -sb</span><br><span class="line">## master</span><br></pre></td></tr></table></figure>

<p><code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p>
<p>如果因为某些原因你发现自己处在一个混乱的状态中然后只是想要重来一次，也可以运行 <code>git reset --hard HEAD</code> 回到之前的状态或其他你想要恢复的状态。 请牢记这会将清除工作目录中的所有内容，所以确保你不需要保存这里的任意改动。</p>
<h5 id="忽略空白"><a href="#忽略空白" class="headerlink" title="忽略空白"></a>忽略空白</h5><p>在这个特定的例子中，冲突与空白有关。 我们知道这点是因为这个例子很简单，但是在实际的例子中发现这样的冲突也很容易，因为每一行都被移除而在另一边每一行又被加回来了。 默认情况下，Git 认为所有这些行都改动了，所以它不会合并文件。</p>
<p>默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。 如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用 <code>-Xignore-all-space</code> 或 <code>-Xignore-space-change</code> 选项。 第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -Xignore-space-change whitespace</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> hello.rb | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>因为在本例中，实际上文件修改并没有冲突，一旦我们忽略空白修改，每一行都能被很好地合并。</p>
<p>如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草。</p>
<h5 id="手动文件再合并"><a href="#手动文件再合并" class="headerlink" title="手动文件再合并"></a>手动文件再合并</h5><p>虽然 Git 对空白的预处理做得很好，还有很多其他类型的修改，Git 也许无法自动处理，但是脚本可以处理它们。 例如，假设 Git 无法处理空白修改因此我们需要手动处理。</p>
<p>我们真正想要做的是对将要合并入的文件在真正合并前运行 <code>dos2unix</code> 程序。 所以如果那样的话，我们该如何做？</p>
<p>首先，我们进入到了合并冲突状态。 然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。 然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。</p>
<p>获得这三个文件版本实际上相当容易。 Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。 Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 <code>MERGE_HEAD</code>，即你将要合并入的版本（“theirs”）。</p>
<p>通过 git show 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git show :1:hello.rb &gt; hello.common.rb</span><br><span class="line">$ git show :2:hello.rb &gt; hello.ours.rb</span><br><span class="line">$ git show :3:hello.rb &gt; hello.theirs.rb</span><br></pre></td></tr></table></figure>

<p>如果你想要更专业一点，也可以使用 <code>ls-files -u</code> 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -u</span><br><span class="line">100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb</span><br><span class="line">100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb</span><br><span class="line">100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</span><br></pre></td></tr></table></figure>

<p><code>:1:hello.rb</code> 只是查找那个 blob 对象 SHA-1 值的简写。</p>
<p>既然在我们的工作目录中已经有这所有三个阶段的内容，我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 <code>git merge-file</code> 命令来重新合并那个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ dos2unix hello.theirs.rb</span><br><span class="line">dos2unix: converting file hello.theirs.rb to Unix format ...</span><br><span class="line"></span><br><span class="line">$ git merge-file -p \</span><br><span class="line">    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb</span><br><span class="line"></span><br><span class="line">$ git diff -b</span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 36c06c8,e85207e..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,8 -1,7 +1,8 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line"> +# prints out a greeting</span><br><span class="line">  def hello</span><br><span class="line">-   puts &apos;hello world&apos;</span><br><span class="line">+   puts &apos;hello mundo&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<p>在这时我们已经漂亮地合并了那个文件。 实际上，这比使用 <code>ignore-space-change</code> 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。 在使用 <code>ignore-space-change</code> 进行合并操作后，我们最终得到了有几行是 DOS 行尾的文件，从而使提交内容混乱了。</p>
<p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 <code>git diff</code> 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。 让我们看看它们。</p>
<p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --ours</span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index 36c06c8..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -2,7 +2,7 @@</span><br><span class="line"></span><br><span class="line"> # prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">-  puts &apos;hello world&apos;</span><br><span class="line">+  puts &apos;hello mundo&apos;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br></pre></td></tr></table></figure>

<p>这里我们可以很容易地看到在我们的分支上发生了什么，在这次合并中我们实际引入到这个文件的改动，是修改了其中一行。</p>
<p>如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code>。 在本例及后续的例子中，我们会使用 <code>-b</code> 来去除空白，因为我们将它与 Git 中的，而不是我们清理过的 <code>hello.theirs.rb</code> 文件比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --theirs -b</span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index e85207e..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">   puts &apos;hello mundo&apos;</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>

<p>最终，你可以通过 <code>git diff --base</code> 来查看文件在两边是如何改动的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --base -b</span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,7 +1,8 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">-  puts &apos;hello world&apos;</span><br><span class="line">+  puts &apos;hello mundo&apos;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br></pre></td></tr></table></figure>

<p>在这时我们可以使用 <code>git clean</code> 命令来清理我们为手动合并而创建但不再有用的额外文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -f</span><br><span class="line">Removing hello.common.rb</span><br><span class="line">Removing hello.ours.rb</span><br><span class="line">Removing hello.theirs.rb</span><br></pre></td></tr></table></figure>

<h5 id="检出冲突"><a href="#检出冲突" class="headerlink" title="检出冲突"></a>检出冲突</h5><p>也许有时我们并不满意这样的解决方案，或许有时还要手动编辑一边或者两边的冲突，但还是依旧无法正常工作，这时我们需要更多的上下文关联来解决这些冲突。</p>
<p>让我们来稍微改动下例子。 对于本例，我们有两个长期分支，每一个分支都有几个提交，但是在合并时却创建了一个合理的冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --oneline --decorate --all</span><br><span class="line">* f1270f7 (HEAD, master) update README</span><br><span class="line">* 9af9d3b add a README</span><br><span class="line">* 694971d update phrase to hola world</span><br><span class="line">| * e3eb223 (mundo) add more tests</span><br><span class="line">| * 7cff591 add testing script</span><br><span class="line">| * c3ffff1 changed text to hello mundo</span><br><span class="line">|/</span><br><span class="line">* b7dcc89 initial hello world code</span><br></pre></td></tr></table></figure>

<p>现在有只在 <code>master</code> 分支上的三次单独提交，还有其他三次提交在 <code>mundo</code> 分支上。 如果我们尝试将 <code>mundo</code> 分支合并入 <code>master</code> 分支，我们得到一个冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge mundo</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>我们想要看一下合并冲突是什么。 如果我们打开这个文件，我们将会看到类似下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">  puts &apos;hola world&apos;</span><br><span class="line">=======</span><br><span class="line">  puts &apos;hello mundo&apos;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>合并的两边都向这个文件增加了内容，但是导致冲突的原因是其中一些提交修改了文件的同一个地方。</p>
<p>让我们探索一下现在你手边可用来查明这个冲突是如何产生的工具。 应该如何修复这个冲突看起来或许并不明显。 这时你需要更多上下文。</p>
<p>一个很有用的工具是带 <code>--conflict</code> 选项的 <code>git checkout</code>。 这会重新检出文件并替换合并冲突标记。 如果想要重置标记并尝试再次解决它们的话这会很有用。</p>
<p>可以传递给 <code>--conflict</code> 参数 <code>diff3</code> 或 <code>merge</code>（默认选项）。 如果传给它 <code>diff3</code>，Git 会使用一个略微不同版本的冲突标记：不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --conflict=diff3 hello.rb</span><br></pre></td></tr></table></figure>

<p>一旦我们运行它，文件看起来会像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours</span><br><span class="line">  puts &apos;hola world&apos;</span><br><span class="line">||||||| base</span><br><span class="line">  puts &apos;hello world&apos;</span><br><span class="line">=======</span><br><span class="line">  puts &apos;hello mundo&apos;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>如果你喜欢这种格式，可以通过设置 <code>merge.conflictstyle</code> 选项为 <code>diff3</code> 来做为以后合并冲突的默认选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.conflictstyle diff3</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code> 命令也可以使用 <code>--ours</code> 和 <code>--theirs</code> 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。</p>
<p>当有二进制文件冲突时这可能会特别有用，因为可以简单地选择一边，或者可以只合并另一个分支的特定文件——可以做一次合并然后在提交前检出一边或另一边的特定文件。</p>
<h5 id="合并日志"><a href="#合并日志" class="headerlink" title="合并日志"></a>合并日志</h5><p>另一个解决合并冲突有用的工具是 <code>git log</code>。 这可以帮助你得到那些对冲突有影响的上下文。 回顾一点历史来记起为什么两条线上的开发会触碰同一片代码有时会很有用。</p>
<p>为了得到此次合并中包含的每一个分支的所有独立提交的列表，我们可以使用之前在 三点 学习的“三点”语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --left-right HEAD...MERGE_HEAD</span><br><span class="line">&lt; f1270f7 update README</span><br><span class="line">&lt; 9af9d3b add a README</span><br><span class="line">&lt; 694971d update phrase to hola world</span><br><span class="line">&gt; e3eb223 add more tests</span><br><span class="line">&gt; 7cff591 add testing script</span><br><span class="line">&gt; c3ffff1 changed text to hello mundo</span><br></pre></td></tr></table></figure>

<p>这个漂亮的列表包含 6 个提交和每一个提交所在的不同开发路径。</p>
<p>我们可以通过更加特定的上下文来进一步简化这个列表。 如果我们添加 <code>--merge</code> 选项到 <code>git log</code> 中，它会只显示任何一边接触了合并冲突文件的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --left-right --merge</span><br><span class="line">&lt; 694971d update phrase to hola world</span><br><span class="line">&gt; c3ffff1 changed text to hello mundo</span><br></pre></td></tr></table></figure>

<p>如果你运行命令时用 <code>-p</code> 选项代替，你会得到所有冲突文件的区别。 快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 非常 有用。</p>
<h5 id="组合式差异格式"><a href="#组合式差异格式" class="headerlink" title="组合式差异格式"></a>组合式差异格式</h5><p>因为 Git 暂存合并成功的结果，当你在合并冲突状态下运行 <code>git diff</code> 时，只会得到现在还在冲突状态的区别。 当需要查看你还需要解决哪些冲突时这很有用。</p>
<p>在合并冲突后直接运行的 <code>git diff</code> 会给你一个相当独特的输出格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,11 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> +  puts &apos;hola world&apos;</span><br><span class="line">++=======</span><br><span class="line">+   puts &apos;hello mundo&apos;</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<p>这种叫作“组合式差异”的格式会在每一行给你两列数据。 第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除），第二列显示 “theirs” 分支与工作目录的拷贝区别。</p>
<p>所以在上面的例子中可以看到 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 与 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 行在工作拷贝中但是并不在合并的任意一边中。 这很有意义，合并工具因为我们的上下文被困住了，它期望我们去移除它们。</p>
<p>如果我们解决冲突再次运行 <code>git diff</code>，我们将会看到同样的事情，但是它有一点帮助。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.rb</span><br><span class="line">$ git diff</span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &apos;hola world&apos;</span><br><span class="line"> -  puts &apos;hello mundo&apos;</span><br><span class="line">++  puts &apos;hola mundo&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<p>这里显示出 “hola world” 在我们这边但不在工作拷贝中，那个 “hello mundo” 在他们那边但不在工作拷贝中，最终 “hola mundo” 不在任何一边但是现在在工作拷贝中。 在提交解决方案前这对审核很有用。</p>
<p>也可以在合并后通过 <code>git log</code> 来获取相同信息，并查看冲突是如何解决的。 如果你对一个合并提交运行 <code>git show</code> 命令 Git 将会输出这种格式，或者你也可以在 <code>git log -p</code>（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 <code>--cc</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git log --cc -p -1</span><br><span class="line">commit 14f41939956d80b9e17bb8721354c33f8d5b5a79</span><br><span class="line">Merge: f1270f7 e3eb223</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 19 18:14:49 2014 +0200</span><br><span class="line"></span><br><span class="line">    Merge branch &apos;mundo&apos;</span><br><span class="line"></span><br><span class="line">    Conflicts:</span><br><span class="line">        hello.rb</span><br><span class="line"></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..e1d0799</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &apos;hola world&apos;</span><br><span class="line"> -  puts &apos;hello mundo&apos;</span><br><span class="line">++  puts &apos;hola mundo&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<h4 id="撤消合并"><a href="#撤消合并" class="headerlink" title="撤消合并"></a>撤消合并</h4><p>虽然你已经知道如何创建一个合并提交，但有时出错是在所难免的。 使用 Git 最棒的一件事情是犯错是可以的，因为有可能（大多数情况下都很容易）修复它们。</p>
<p>合并提交并无不同。 假设现在在一个特性分支上工作，不小心将其合并到 <code>master</code> 中，现在提交历史看起来是这样：</p>
<p><img src="git-chapter-8/img1.png" alt></p>
<p>有两种方法来解决这个问题，这取决于你想要的结果是什么。</p>
<h5 id="修复引用"><a href="#修复引用" class="headerlink" title="修复引用"></a>修复引用</h5><p>如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 <code>git merge</code> 后运行 <code>git reset --hard HEAD~</code>，这会重置分支指向所以它们看起来像这样：</p>
<p><img src="git-chapter-8/img2.png" alt></p>
<p>我们之前在 重置揭密 已经介绍了 <code>reset</code>，所以现在指出这里发生了什么并不是很困难。 让我们快速复习下：<code>reset --hard</code> 通常会经历三步：</p>
<ol>
<li><p>移动 HEAD 指向的分支。 在本例中，我们想要移动 <code>master</code> 到合并提交（<code>C6</code>）之前所在的位置。</p>
</li>
<li><p>使索引看起来像 HEAD。</p>
</li>
<li><p>使工作目录看起来像索引。</p>
</li>
</ol>
<p>这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 查阅 变基的风险 来了解更多可能发生的事情；用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 <code>reset</code>。 如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。</p>
<h5 id="还原提交"><a href="#还原提交" class="headerlink" title="还原提交"></a>还原提交</h5><p>如果移动分支指针并不适合你，Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。 Git 称这个操作为“还原”，在这个特定的场景下，你可以像这样调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git revert -m 1 HEAD</span><br><span class="line">[master b1d8379] Revert &quot;Merge branch &apos;topic&apos;&quot;</span><br></pre></td></tr></table></figure>

<p><code>-m 1</code> 标记指出 “mainline” 需要被保留下来的父结点。 当你引入一个合并到 <code>HEAD（git merge topic）</code>，新提交有两个父结点：第一个是 <code>HEAD</code>（<code>C6</code>），第二个是将要合并入分支的最新提交（<code>C4</code>）。 在本例中，我们想要撤消所有由父结点 #2（<code>C4</code>）合并引入的修改，同时保留从父结点 #1（<code>C4</code>）开始的所有内容。</p>
<p>有还原提交的历史看起来像这样：</p>
<p><img src="git-chapter-8/img3.png" alt></p>
<p>新的提交 <code>^M</code> 与 <code>C6</code> 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 <code>HEAD</code> 的历史中。 如果你尝试再次合并 <code>topic</code> 到 <code>master</code> Git 会感到困惑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge topic</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>

<p><code>topic</code> 中并没有东西不能从 <code>master</code> 中追踪到达。 更糟的是，如果你在 <code>topic</code> 中增加工作然后再次合并，Git 只会引入被还原的合并 之后 的修改。</p>
<p><img src="git-chapter-8/img4.png" alt></p>
<p>解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，然后 创建一个新的合并提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git revert ^M</span><br><span class="line">[master 09f0126] Revert &quot;Revert &quot;Merge branch &apos;topic&apos;&quot;&quot;</span><br><span class="line">$ git merge topic</span><br></pre></td></tr></table></figure>

<p><img src="git-chapter-8/img5.png" alt></p>
<p>在本例中，<code>M</code> 与 <code>^M</code> 抵消了。 <code>^^M</code> 事实上合并入了 <code>C3</code> 与 <code>C4</code> 的修改，<code>C8</code> 合并了 <code>C7</code> 的修改，所以现在 <code>topic</code> 已经完全被合并了。</p>
<h4 id="其他类型的合并"><a href="#其他类型的合并" class="headerlink" title="其他类型的合并"></a>其他类型的合并</h4><p>到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。 然而还有其他方式来合并两个分支到一起。 让我们来快速介绍其中的几个。</p>
<h5 id="我们的或他们的偏好"><a href="#我们的或他们的偏好" class="headerlink" title="我们的或他们的偏好"></a>我们的或他们的偏好</h5><p>首先，有另一种我们可以通过 “recursive” 合并模式做的有用工作。 我们之前已经看到传递给 <code>-X</code> 的 <code>ignore-all-space</code> 与 <code>ignore-space-change</code> 选项，但是我们也可以告诉 Git 当它看见一个冲突时直接选择一边。</p>
<p>默认情况下，当 Git 看到两个分支合并中的冲突时，它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决。 如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动合并冲突，你可以传递给 <code>merge</code> 命令一个 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数。</p>
<p>如果 Git 看到这个，它并不会增加冲突标记。 任何可以合并的区别，它会直接合并。 任何有冲突的区别，它会简单地选择你全局指定的一边，包括二进制文件。</p>
<p>如果我们回到之前我们使用的 “hello world” 例子中，我们可以看到合并入我们的分支时引发了冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge mundo</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Resolved &apos;hello.rb&apos; using previous resolution.</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>然而如果我们运行时增加 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数就不会有冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -Xours mundo</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> hello.rb | 2 +-</span><br><span class="line"> test.sh  | 2 ++</span><br><span class="line"> 2 files changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 test.sh</span><br></pre></td></tr></table></figure>

<p>在上例中，它并不会为 “hello mundo” 与 “hola world” 标记合并冲突，它只会简单地选取 “hola world”。 然而，在那个分支上所有其他非冲突的改动都可以被成功地合并入。</p>
<p>这个选项也可以传递给我们之前看到的 <code>git merge-file</code> 命令，通过运行类似 <code>git merge-file --ours</code> 的命令来合并单个文件。</p>
<p>如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改，有一个更严格的选项，它是 “ours” 合并 策略。 这与 “ours” recursive 合并 选项 不同。</p>
<p>这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -s ours mundo</span><br><span class="line">Merge made by the &apos;ours&apos; strategy.</span><br><span class="line">$ git diff HEAD HEAD~</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>你可以看到合并后与合并前我们的分支并没有任何区别。</p>
<p>当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。 例如，假设你有一个分叉的 <code>release</code> 分支并且在上面做了一些你想要在未来某个时候合并回 <code>master</code> 的工作。 与此同时 <code>master</code> 分支上的某些 <code>bugfix</code> 需要向后移植回 <code>release</code> 分支。 你可以合并 <code>bugfix</code> 分支进入 <code>release</code> 分支同时也 <code>merge -s ours</code> 合并进入你的 <code>master</code> 分支（即使那个修复已经在那儿了）这样当你之后再次合并 <code>release</code> 分支时，就不会有来自 <code>bugfix</code> 的冲突。</p>
<h5 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h5><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。 当你执行一个子树合并时，Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。</p>
<p>我们来看一个例子如何将一个项目加入到一个已存在的项目中，然后将第二个项目的代码合并到第一个项目的子目录中。</p>
<p>首先，我们将 Rack 应用添加到你的项目里。 我们把 Rack 项目作为一个远程的引用添加到我们的项目里，然后检出到它自己的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add rack_remote https://github.com/rack/rack</span><br><span class="line">$ git fetch rack_remote</span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 3184, done.</span><br><span class="line">remote: Compressing objects: 100% (1465/1465), done.</span><br><span class="line">remote: Total 3184 (delta 1952), reused 2770 (delta 1675)</span><br><span class="line">Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1952/1952), done.</span><br><span class="line">From https://github.com/rack/rack</span><br><span class="line"> * [new branch]      build      -&gt; rack_remote/build</span><br><span class="line"> * [new branch]      master     -&gt; rack_remote/master</span><br><span class="line"> * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4</span><br><span class="line"> * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9</span><br><span class="line">$ git checkout -b rack_branch rack_remote/master</span><br><span class="line">Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.</span><br><span class="line">Switched to a new branch &quot;rack_branch&quot;</span><br></pre></td></tr></table></figure>

<p>现在在我们的 <code>rack_branch</code> 分支里就有 Rack 项目的根目录，而我们的项目则在 <code>master</code> 分支里。 如果你从一个分支切换到另一个分支，你可以看到它们的项目根目录是不同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib</span><br><span class="line">COPYING         README         bin           example         test</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &quot;master&quot;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure>

<p>这个是一个比较奇怪的概念。 并不是仓库中的所有分支都是必须属于同一个项目的分支. 这并不常见，因为没啥用，但是却是在不同分支里包含两条完全不同提交历史的最简单的方法。</p>
<p>在这个例子中，我们希望将 Rack 项目拉到 <code>master</code> 项目中作为一个子目录。 我们可以在 Git 中执行 <code>git read-tree</code> 来实现。 你可以在 Git 内部原理 中查看更多 <code>read-tree</code> 的相关信息，现在你只需要知道它会读取一个分支的根目录树到当前的暂存区和工作目录里。 先切回你的 <code>master</code> 分支，将 <code>rack_back</code> 分支拉取到我们项目的 <code>master</code> 分支中的 <code>rack</code> 子目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=rack/ -u rack_branch</span><br></pre></td></tr></table></figure>

<p>当我们提交时，那个子目录中拥有所有 Rack 项目的文件 —— 就像我们直接从压缩包里复制出来的一样。 有趣的是你可以很容易地将一个分支的变更合并到另一个分支里。 所以，当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout rack_branch</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>接着，我们可以将这些变更合并回我们的 <code>master</code> 分支。 使用 <code>--squash</code> 选项和使用 <code>-Xsubtree</code> 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。 （递归策略在这里是默认的，提到它是为了让读者有个清晰的概念。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --squash -s recursive -Xsubtree=rack rack_branch</span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line">Automatic merge went well; stopped before committing as requested</span><br></pre></td></tr></table></figure>

<p>Rack 项目中所有的改动都被合并了，等待被提交到本地。 你也可以用相反的方法——在 <code>master</code> 分支上的 <code>rack</code> 子目录中做改动然后将它们合并入你的 <code>rack_branch</code> 分支中，之后你可能将其提交给项目维护着或者将它们推送到上游。</p>
<p>这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块（有关子模块的内容我们会在 子模块 中介绍）。 我们可以在自己的仓库中保持一些和其他项目相关的分支，偶尔使用子树合并将它们合并到我们的项目中。 某些时候这种方式很有用，例如当所有的代码都提交到一个地方的时候。 然而，它同时也有缺点，它更加复杂且更容易让人犯错，例如重复合并改动或者不小心将分支提交到一个无关的仓库上去。</p>
<p>另外一个有点奇怪的地方是，当你想查看 <code>rack</code> 子目录和 <code>rack_branch</code> 分支的差异——来确定你是否需要合并它们——你不能使用普通的 <code>diff</code> 命令。 取而代之的是，你必须使用 <code>git diff-tree</code> 来和你的目标分支做比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff-tree -p rack_branch</span><br></pre></td></tr></table></figure>

<p>或者，将你的 <code>rack</code> 子目和最近一次从服务器上抓取的 <code>master</code> 分支进行比较，你可以运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff-tree -p rack_remote/master</span><br></pre></td></tr></table></figure>

<h3 id="使用-Git-调试"><a href="#使用-Git-调试" class="headerlink" title="使用 Git 调试"></a>使用 Git 调试</h3><p>Git 也提供了两个工具来辅助你调试项目中的问题。 由于 Git 被设计成适用于几乎所有类型的项目，这些工具是比较通用的，但它们可以在出现问题的时候帮助你找到 bug 或者错误。</p>
<h4 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h4><p>如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。 它展示了文件中每一行最后一次修改的提交。 所以，如果你在代码中看到一个有问题的方法，你可以使用 <code>git blame</code> 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。 这个例子使用 <code>-L</code> 选项来限制输出范围在第12至22行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git blame -L 12,22 simplegit.rb</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &apos;master&apos;)</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #&#123;tree&#125;&quot;)</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &apos;master&apos;)</span><br><span class="line">79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #&#123;tree&#125;&quot;)</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #&#123;path&#125;&quot;)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</span><br></pre></td></tr></table></figure>

<p>请注意，第一个字段是最后一次修改该行的提交的部分 SHA-1 值。 接下来两个字段的值是从提交中提取出来的——作者的名字以及提交的时间——所以你就可以很轻易地找到是谁在什么时候修改了那一行。 接下来就是行号和文件内容。 注意一下 <code>^4832fe2</code> 这个提交的那些行，这些指的是这个文件第一次提交的那些行。 这个提交是这个文件第一次加入到这个项目时的提交，并且这些行从未被修改过。 这会带来小小的困惑，因为你已经至少看到三种 Git 使用 <code>^</code> 来修饰一个提交的 SHA-1 值的不同含义，但这里确实就是这个意思。</p>
<p>另一件比较酷的事情是 Git 不会显式地记录文件的重命名。 它会记录快照，然后在事后尝试计算出重命名的动作。 这其中有一个很有意思的特性就是你可以让 Git 找出所有的代码移动。 如果你在 <code>git blame</code> 后面加上一个 <code>-C</code>，Git 会分析你正在标注的文件，并且尝试找出文件中从别的地方复制过来的代码片段的原始出处。 比如，你将 <code>GITServerHandler.m</code> 这个文件拆分为数个文件，其中一个文件是 <code>GITPackUpload.m</code>。 对 <code>GITPackUpload.m</code> 执行带 <code>-C</code> 参数的 <code>blame</code> 命令，你就可以看到代码块的原始出处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git blame -C -L 141,153 GITPackUpload.m</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 141)</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 143) &#123;</span><br><span class="line">70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) &#123;</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</span><br></pre></td></tr></table></figure>

<p>这个功能很有用。 通常来说，你会认为复制代码过来的那个提交是最原始的提交，因为那是你第一次在这个文件中修改了这几行。 但 Git 会告诉你，你第一次写这几行代码的那个提交才是原始提交，即使这是在另外一个文件里写的。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。 如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 <code>git bisect</code> 来帮助查找。 <code>bisect</code> 命令会对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题。</p>
<p>假设你刚刚在线上环境部署了你的代码，接着收到一些 bug 反馈，但这些 bug 在你之前的开发环境里没有出现过，这让你百思不得其解。 你重新查看了你的代码，发现这个问题是可以被重现的，但是你不知道哪里出了问题。 你可以用二分法来找到这个问题。 首先执行 <code>git bisect start</code> 来启动，接着执行 <code>git bisect bad</code> 来告诉系统当前你所在的提交是有问题的。 然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用 <code>git bisect good [good_commit]</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect start</span><br><span class="line">$ git bisect bad</span><br><span class="line">$ git bisect good v1.0</span><br><span class="line">Bisecting: 6 revisions left to test after this</span><br><span class="line">[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</span><br></pre></td></tr></table></figure>

<p>Git 发现在你标记为正常的提交（v1.0）和当前的错误版本之间有大约12次提交，于是 Git 检出中间的那个提交。 现在你可以执行测试，看看在这个提交下问题是不是还是存在。 如果还存在，说明问题是在这个提交之前引入的；如果问题不存在，说明问题是在这个提交之后引入的。 假设测试结果是没有问题的，你可以通过 <code>git bisect good</code> 来告诉 Git，然后继续寻找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect good</span><br><span class="line">Bisecting: 3 revisions left to test after this</span><br><span class="line">[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</span><br></pre></td></tr></table></figure>

<p>现在你在另一个提交上了，这个提交是刚刚那个测试通过的提交和有问题的提交的中点。 你再一次执行测试，发现这个提交下是有问题的，因此你可以通过 <code>git bisect bad</code> 告诉 Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect bad</span><br><span class="line">Bisecting: 1 revisions left to test after this</span><br><span class="line">[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</span><br></pre></td></tr></table></figure>

<p>这个提交是正常的，现在 Git 拥有的信息已经可以确定引入问题的位置在哪里。 它会告诉你第一个错误提交的 SHA-1 值并显示一些提交说明，以及哪些文件在那次提交里修改过，这样你可以找出引入 bug 的根源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect good</span><br><span class="line">b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit</span><br><span class="line">commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04</span><br><span class="line">Author: PJ Hyett &lt;pjhyett@example.com&gt;</span><br><span class="line">Date:   Tue Jan 27 14:48:32 2009 -0800</span><br><span class="line"></span><br><span class="line">    secure this thing</span><br><span class="line"></span><br><span class="line">:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730</span><br><span class="line">f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</span><br></pre></td></tr></table></figure>

<p>当你完成这些操作之后，你应该执行 <code>git bisect reset</code> 重置你的 HEAD 指针到最开始的位置，否则你会停留在一个很奇怪的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect reset</span><br></pre></td></tr></table></figure>

<p>这是一个可以帮助你在几分钟内从数百个提交中找到 bug 的强大工具。 事实上，如果你有一个脚本在项目是正常的情况下返回 0，在不正常的情况下返回非 0，你可以使 <code>git bisect</code> 自动化这些操作。 首先，你设定好项目正常以及不正常所在提交的二分查找范围。 你可以通过 <code>bisect start</code> 命令的参数来设定这两个提交，第一个参数是项目不正常的提交，第二个参数是项目正常的提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect start HEAD v1.0</span><br><span class="line">$ git bisect run test-error.sh</span><br></pre></td></tr></table></figure>

<p>Git 会自动在每个被检出的提交里执行 <code>test-error.sh</code> 直到找到第一个项目不正常的提交。 你也可以执行 <code>make</code> 或者 <code>make tests</code> 或者其他东西来进行自动化测试。</p>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p>
<p>我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。 如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。</p>
<p>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<h4 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h4><p>我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。</p>
<p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 <code>git submodule add</code> 命令后面加上想要跟踪的项目 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">Cloning into &apos;DbConnector&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure>

<p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
<p>如果这时运行 <code>git status</code>，你会注意到几件事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   DbConnector</span><br></pre></td></tr></table></figure>

<p>首先应当注意到新的 <code>.gitmodules</code> 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitmodules</span><br><span class="line">[submodule &quot;DbConnector&quot;]</span><br><span class="line">	path = DbConnector</span><br><span class="line">	url = https://github.com/chaconinc/DbConnector</span><br></pre></td></tr></table></figure>

<p>如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p>
<p>在 <code>git status</code> 输出中列出的另一个是项目文件夹记录。 如果你运行 <code>git diff</code>，会看到类似下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached DbConnector</span><br><span class="line">diff --git a/DbConnector b/DbConnector</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..c3f01dc</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</span><br></pre></td></tr></table></figure>

<p>虽然 <code>DbConnector</code> 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作该仓库中的一个特殊提交。</p>
<p>如果你想看到更漂亮的差异输出，可以给 <code>git diff</code> 传递 <code>--submodule</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached --submodule</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..71fc376</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+[submodule &quot;DbConnector&quot;]</span><br><span class="line">+       path = DbConnector</span><br><span class="line">+       url = https://github.com/chaconinc/DbConnector</span><br><span class="line">Submodule DbConnector 0000000...c3f01dc (new submodule)</span><br></pre></td></tr></table></figure>

<p>当你提交时，会看到类似下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;added DbConnector module&apos;</span><br><span class="line">[master fb9093c] added DbConnector module</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 DbConnector</span><br></pre></td></tr></table></figure>

<p>注意 DbConnector 记录的 <code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p>
<h4 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h4><p>接下来我们将会克隆一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into &apos;MainProject&apos;...</span><br><span class="line">remote: Counting objects: 14, done.</span><br><span class="line">remote: Compressing objects: 100% (13/13), done.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">$ cd MainProject</span><br><span class="line">$ ls -la</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .</span><br><span class="line">drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..</span><br><span class="line">drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git</span><br><span class="line">-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules</span><br><span class="line">drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector</span><br><span class="line">-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile</span><br><span class="line">drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src</span><br><span class="line">$ cd DbConnector/</span><br><span class="line">$ ls</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>其中有 <code>DbConnector</code> 目录，不过是空的。 你必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule &apos;DbConnector&apos; (https://github.com/chaconinc/DbConnector) registered for path &apos;DbConnector&apos;</span><br><span class="line">$ git submodule update</span><br><span class="line">Cloning into &apos;DbConnector&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;c3f01dc8862123d317dd46284b05b6892c7b29bc&apos;</span><br></pre></td></tr></table></figure>

<p>现在 <code>DbConnector</code> 子目录是处在和之前提交时相同的状态了。</p>
<p>不过还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recursive</code> 选项，它就会自动初始化并更新仓库中的每一个子模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --recursive https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into &apos;MainProject&apos;...</span><br><span class="line">remote: Counting objects: 14, done.</span><br><span class="line">remote: Compressing objects: 100% (13/13), done.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule &apos;DbConnector&apos; (https://github.com/chaconinc/DbConnector) registered for path &apos;DbConnector&apos;</span><br><span class="line">Cloning into &apos;DbConnector&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;c3f01dc8862123d317dd46284b05b6892c7b29bc&apos;</span><br></pre></td></tr></table></figure>

<h4 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h4><p>现在我们有一份包含子模块的项目副本，我们将会同时在主项目和子模块项目上与队员协作。</p>
<h5 id="拉取上游修改"><a href="#拉取上游修改" class="headerlink" title="拉取上游修改"></a>拉取上游修改</h5><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。 我们来看一个简单的例子。</p>
<p>如果想要在子模块中查看新工作，可以进入到目录中运行 <code>git fetch</code> 与 <code>git merge</code>，合并上游分支来更新本地代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c3f01dc..d0354fc  master     -&gt; origin/master</span><br><span class="line">$ git merge origin/master</span><br><span class="line">Updating c3f01dc..d0354fc</span><br><span class="line">Fast-forward</span><br><span class="line"> scripts/connect.sh | 1 +</span><br><span class="line"> src/db.c           | 1 +</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p>如果你现在返回到主项目并运行 <code>git diff --submodule</code>，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。 如果你不想每次运行 <code>git diff</code> 时都输入 <code>--submodle</code>，那么可以将 <code>diff.submodule</code> 设置为 “log” 来将其作为默认行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global diff.submodule log</span><br><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c3f01dc..d0354fc:</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>

<p>如果在此时提交，那么你会将子模块锁定为其他人更新时的新代码。</p>
<p>如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 <code>git submodule update --remote</code>，Git 将会进入子模块然后抓取并更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote DbConnector</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   3f19983..d0354fc  master     -&gt; origin/master</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;d0354fc054692d3906c85c3af05ddce39a1c0644&apos;</span><br></pre></td></tr></table></figure>

<p>此命令默认会假定你想要更新并检出子模块仓库的 <code>master</code> 分支。 不过你也可以设置为想要的其他分支。 例如，你想要 DbConnector 子模块跟踪仓库的 “stable” 分支，那么既可以在 <code>.gitmodules</code> 文件中设置（这样其他人也可以跟踪它），也可以只在本地的 <code>.git/config</code> 文件中设置。 让我们在 <code>.gitmodules</code> 文件中设置它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git config -f .gitmodules submodule.DbConnector.branch stable</span><br><span class="line"></span><br><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   27cf5d3..c87d55d  stable -&gt; origin/stable</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687&apos;</span><br></pre></td></tr></table></figure>

<p>如果不用 <code>-f .gitmodules</code> 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。</p>
<p>这时我们运行 <code>git status</code>，Git 会显示子模块中有“新提交”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   .gitmodules</span><br><span class="line">  modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>如果你设置了配置选项 <code>status.submodulesummary</code>，Git 也会显示你的子模块的更改摘要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git config status.submodulesummary 1</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   .gitmodules</span><br><span class="line">	modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">Submodules changed but not updated:</span><br><span class="line"></span><br><span class="line">* DbConnector c3f01dc...c87d55d (4):</span><br><span class="line">  &gt; catch non-null terminated lines</span><br></pre></td></tr></table></figure>

<p>这时如果运行 <code>git diff</code>，可以看到我们修改了 <code>.gitmodules</code> 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule &quot;DbConnector&quot;]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line"> Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>

<p>这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 <code>git log -p</code> 查看这个信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p --submodule</span><br><span class="line">commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Sep 17 16:37:02 2014 +0200</span><br><span class="line"></span><br><span class="line">    updating DbConnector for bug fixes</span><br><span class="line"></span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule &quot;DbConnector&quot;]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line">Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>

<p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新所有子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。</p>
<h5 id="在子模块上工作"><a href="#在子模块上工作" class="headerlink" title="在子模块上工作"></a>在子模块上工作</h5><p>你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。</p>
<p>现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。</p>
<p>到目前为止，当我们运行 <code>git submodule update</code> 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支（例如 “master” ）跟踪改动。 所以你做的任何改动都不会被跟踪。</p>
<p>为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 <code>git submodule update --remote</code> 来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。</p>
<p>首先，让我们进入子模块目录然后检出一个分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout stable</span><br><span class="line">Switched to branch &apos;stable&apos;</span><br></pre></td></tr></table></figure>

<p>然后尝试用 “merge” 选项。 为了手动指定它，我们只需给 <code>update</code> 添加 <code>--merge</code> 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --merge</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c87d55d..92c7337  stable     -&gt; origin/stable</span><br><span class="line">Updating c87d55d..92c7337</span><br><span class="line">Fast-forward</span><br><span class="line"> src/main.c | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">Submodule path &apos;DbConnector&apos;: merged in &apos;92c7337b30ef9e0893e758dac2459d07362ab5ea&apos;</span><br></pre></td></tr></table></figure>

<p>如果我们进入 DbConnector 目录，可以发现新的改动已经合并入本地 <code>stable</code> 分支。 现在让我们看看当我们对库做一些本地的改动而同时其他人推送另外一个修改到上游时会发生什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd DbConnector/</span><br><span class="line">$ vim src/db.c</span><br><span class="line">$ git commit -am &apos;unicode support&apos;</span><br><span class="line">[stable f906e16] unicode support</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: unicode support</span><br><span class="line">Submodule path &apos;DbConnector&apos;: rebased into &apos;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&apos;</span><br></pre></td></tr></table></figure>

<p>如果你忘记 <code>--rebase</code> 或 <code>--merge</code>，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&apos;</span><br></pre></td></tr></table></figure>

<p>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 <code>origin/stable</code>（或任何一个你想要的远程分支）就行了。</p>
<p>如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 4 (delta 0), reused 4 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   5d60ef9..c75e92a  stable     -&gt; origin/stable</span><br><span class="line">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class="line">	scripts/setup.sh</span><br><span class="line">Please, commit your changes or stash them before you can switch branches.</span><br><span class="line">Aborting</span><br><span class="line">Unable to checkout &apos;c75e92a2b3855c9e5b66f915308390d9db204aca&apos; in submodule path &apos;DbConnector&apos;</span><br></pre></td></tr></table></figure>

<p>如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --merge</span><br><span class="line">Auto-merging scripts/setup.sh</span><br><span class="line">CONFLICT (content): Merge conflict in scripts/setup.sh</span><br><span class="line">Recorded preimage for &apos;scripts/setup.sh&apos;</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line">Unable to merge &apos;c75e92a2b3855c9e5b66f915308390d9db204aca&apos; in submodule path &apos;DbConnector&apos;</span><br></pre></td></tr></table></figure>

<p>你可以进入子模块目录中然后就像平时那样修复冲突。</p>
<h5 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h5><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c87d55d..82d2ad3:</span><br><span class="line">  &gt; Merge from origin/stable</span><br><span class="line">  &gt; updated setup script</span><br><span class="line">  &gt; unicode support</span><br><span class="line">  &gt; remove unnecessary method</span><br><span class="line">  &gt; add new option for conn pooling</span><br></pre></td></tr></table></figure>

<p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。</p>
<p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 <code>git push</code> 命令接受可以设置为 “check” 或 “on-demand” 的 <code>--recurse-submodules</code> 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 <code>push</code> 操作失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=check</span><br><span class="line">The following submodule paths contain changes that can</span><br><span class="line">not be found on any remote:</span><br><span class="line">  DbConnector</span><br><span class="line"></span><br><span class="line">Please try</span><br><span class="line"></span><br><span class="line">	git push --recurse-submodules=on-demand</span><br><span class="line"></span><br><span class="line">or cd to the path and use</span><br><span class="line"></span><br><span class="line">	git push</span><br><span class="line"></span><br><span class="line">to push them to a remote.</span><br></pre></td></tr></table></figure>

<p>如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。</p>
<p>另一个选项是使用 “on-demand” 值，它会尝试为你这样做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=on-demand</span><br><span class="line">Pushing submodule &apos;DbConnector&apos;</span><br><span class="line">Counting objects: 9, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (8/8), done.</span><br><span class="line">Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.</span><br><span class="line">Total 9 (delta 3), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/DbConnector</span><br><span class="line">   c75e92a..82d2ad3  stable -&gt; stable</span><br><span class="line">Counting objects: 2, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/MainProject</span><br><span class="line">   3d6d338..9a377d1  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。 如果那个子模块因为某些原因推送失败，主项目也会推送失败。</p>
<h5 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h5><p>如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。</p>
<p>如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。</p>
<p>不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 2, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1)</span><br><span class="line">Unpacking objects: 100% (2/2), done.</span><br><span class="line">From https://github.com/chaconinc/MainProject</span><br><span class="line">   9a377d1..eb974f8  master     -&gt; origin/master</span><br><span class="line">Fetching submodule DbConnector</span><br><span class="line">warning: Failed to merge submodule DbConnector (merge following commits not found)</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict in DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found” （未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。</p>
<p>为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 <code>git diff</code>，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br></pre></td></tr></table></figure>

<p>所以，在本例中，<code>eb41d76</code> 是我们的子模块中大家共有的提交，而 <code>c771610</code> 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 <code>eb41d76</code> 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。</p>
<p>来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。</p>
<p>所以，我们将会进入子模块目录，基于 <code>git diff</code> 的第二个 SHA 创建一个分支然后手动合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd DbConnector</span><br><span class="line"></span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"></span><br><span class="line">$ git branch try-merge c771610</span><br><span class="line">(DbConnector) $ git merge try-merge</span><br><span class="line">Auto-merging src/main.c</span><br><span class="line">CONFLICT (content): Merge conflict in src/main.c</span><br><span class="line">Recorded preimage for &apos;src/main.c&apos;</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>我们在这儿得到了一个真正的合并冲突，所以如果想要解决并提交它，那么只需简单地通过结果来更新主项目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ vim src/main.c (1)</span><br><span class="line">$ git add src/main.c</span><br><span class="line">$ git commit -am &apos;merged our changes&apos;</span><br><span class="line">Recorded resolution for &apos;src/main.c&apos;.</span><br><span class="line">[master 9fd905e] merged our changes</span><br><span class="line"></span><br><span class="line">$ cd .. (2)</span><br><span class="line">$ git diff (3)</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@@ -1,1 -1,1 +1,1 @@@</span><br><span class="line">- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"> -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d</span><br><span class="line">++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a</span><br><span class="line">$ git add DbConnector (4)</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;Merge Tom&apos;s Changes&quot; (5)</span><br><span class="line">[master 10d2c60] Merge Tom&apos;s Changes</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先解决冲突</p>
</li>
<li><p>然后返回到主项目目录中</p>
</li>
<li><p>再次检查 SHA-1 值</p>
</li>
<li><p>解决冲突的子模块记录</p>
</li>
<li><p>提交我们的合并</p>
</li>
</ol>
<p>这可能会让你有点儿困惑，但它确实不难。</p>
<p>有趣的是，Git 还能处理另一种情况。 如果子模块目录中存在着这样一个合并提交，它的历史中包含了的两边的提交，那么 Git 会建议你将它作为一个可行的解决方案。 它看到有人在子模块项目的某一点上合并了包含这两次提交的分支，所以你可能想要那个。</p>
<p>这就是为什么前面的错误信息是 “merge following commits not found”，因为它不能 这样 做。 它让人困惑是因为谁能想到它会尝试这样做？</p>
<p>如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">warning: Failed to merge submodule DbConnector (not fast-forward)</span><br><span class="line">Found a possible merge resolution for the submodule:</span><br><span class="line"> 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes</span><br><span class="line">If this is correct simply add it to the index for example</span><br><span class="line">by using:</span><br><span class="line"></span><br><span class="line">  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a &quot;DbConnector&quot;</span><br><span class="line"></span><br><span class="line">which will accept this suggestion.</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict in DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>它会建议你更新索引，就像你运行了 <code>git add</code> 那样，这样会清除冲突然后提交。不过你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd DbConnector/</span><br><span class="line">$ git merge 9fd905e</span><br><span class="line">Updating eb41d76..9fd905e</span><br><span class="line">Fast-forward</span><br><span class="line"></span><br><span class="line">$ cd ..</span><br><span class="line">$ git add DbConnector</span><br><span class="line">$ git commit -am &apos;Fast forwarded to a common submodule child&apos;</span><br></pre></td></tr></table></figure>

<p>这些命令完成了同一件事，但是通过这种方式你至少可以验证工作是否有效，以及当你在完成时可以确保子模块目录中有你的代码。</p>
<h4 id="子模块技巧"><a href="#子模块技巧" class="headerlink" title="子模块技巧"></a>子模块技巧</h4><p>你可以做几件事情来让用子模块工作轻松一点儿。</p>
<h5 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h5><p>有一个 <code>foreach</code> 子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p>
<p>例如，假设我们想要开始开发一项新功能或者修复一些错误，并且需要在几个子模块内工作。 我们可以轻松地保存所有子模块的工作进度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach &apos;git stash&apos;</span><br><span class="line">Entering &apos;CryptoLibrary&apos;</span><br><span class="line">No local changes to save</span><br><span class="line">Entering &apos;DbConnector&apos;</span><br><span class="line">Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable</span><br><span class="line">HEAD is now at 82d2ad3 Merge from origin/stable</span><br></pre></td></tr></table></figure>

<p>然后我们可以创建一个新分支，并将所有子模块都切换过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach &apos;git checkout -b featureA&apos;</span><br><span class="line">Entering &apos;CryptoLibrary&apos;</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br><span class="line">Entering &apos;DbConnector&apos;</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br></pre></td></tr></table></figure>

<p>你应该明白。 能够生成一个主项目与所有子项目的改动的统一差异是非常有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git diff; git submodule foreach &apos;git diff&apos;</span><br><span class="line">Submodule DbConnector contains modified content</span><br><span class="line">diff --git a/src/main.c b/src/main.c</span><br><span class="line">index 210f1ae..1f0acdc 100644</span><br><span class="line">--- a/src/main.c</span><br><span class="line">+++ b/src/main.c</span><br><span class="line">@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)</span><br><span class="line"></span><br><span class="line">      commit_pager_choice();</span><br><span class="line"></span><br><span class="line">+     url = url_decode(url_orig);</span><br><span class="line">+</span><br><span class="line">      /* build alias_argv */</span><br><span class="line">      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));</span><br><span class="line">      alias_argv[0] = alias_string + 1;</span><br><span class="line">Entering &apos;DbConnector&apos;</span><br><span class="line">diff --git a/src/db.c b/src/db.c</span><br><span class="line">index 1aaefb6..5297645 100644</span><br><span class="line">--- a/src/db.c</span><br><span class="line">+++ b/src/db.c</span><br><span class="line">@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)</span><br><span class="line">        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+char *url_decode(const char *url)</span><br><span class="line">+&#123;</span><br><span class="line">+       return url_decode_mem(url, strlen(url));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> char *url_decode_parameter_name(const char **query)</span><br><span class="line"> &#123;</span><br><span class="line">        struct strbuf out = STRBUF_INIT;</span><br></pre></td></tr></table></figure>

<p>在这里，我们看到子模块中定义了一个函数并在主项目中调用了它。 这明显是个简化了的例子，但是希望它能让你明白这种方法的用处。</p>
<h5 id="有用的别名"><a href="#有用的别名" class="headerlink" title="有用的别名"></a>有用的别名</h5><p>你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 Git 别名 介绍了设置 Git 别名，但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config alias.sdiff &apos;!&apos;&quot;git diff &amp;&amp; git submodule foreach &apos;git diff&apos;&quot;</span><br><span class="line">$ git config alias.spush &apos;push --recurse-submodules=on-demand&apos;</span><br><span class="line">$ git config alias.supdate &apos;submodule update --remote --merge&apos;</span><br></pre></td></tr></table></figure>

<p>这样当你想要更新子模块时可以简单地运行 <code>git supdate</code>，或 <code>git spush</code> 检查子模块依赖后推送。</p>
<h4 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h4><p>然而使用子模块还是有一些小问题。</p>
<p>例如在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b add-crypto</span><br><span class="line">Switched to a new branch &apos;add-crypto&apos;</span><br><span class="line"></span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into &apos;CryptoLibrary&apos;...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git commit -am &apos;adding crypto library&apos;</span><br><span class="line">[add-crypto 4445836] adding crypto library</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 160000 CryptoLibrary</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	CryptoLibrary/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。 如果你移除它然后切换回有那个子模块的分支，需要运行 <code>submodule update --init</code> 来重新建立和填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -fdx</span><br><span class="line">Removing CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git checkout add-crypto</span><br><span class="line">Switched to branch &apos;add-crypto&apos;</span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git submodule update --init</span><br><span class="line">Submodule path &apos;CryptoLibrary&apos;: checked out &apos;b8dda6aa182ea4464f3f3264b11e0268545172af&apos;</span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line">Makefile	includes	scripts		src</span><br></pre></td></tr></table></figure>

<p>再说一遍，这真的不难，只是会让人有点儿困惑。</p>
<p>另一个主要的告诫是许多人遇到了将子目录转换为子模块的问题。 如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行 <code>submodule add</code>，Git 会朝你大喊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf CryptoLibrary/</span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">&apos;CryptoLibrary&apos; already exists in the index</span><br></pre></td></tr></table></figure>

<p>你必须要先取消暂存 <code>CryptoLibrary</code> 目录。 然后才可以添加子模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r CryptoLibrary</span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into &apos;CryptoLibrary&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure>

<p>现在假设你在一个分支下做了这样的工作。 如果尝试切换回的分支中那些文件还在子目录而非子模块中时——你会得到这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">  CryptoLibrary/Makefile</span><br><span class="line">  CryptoLibrary/includes/crypto.h</span><br><span class="line">  ...</span><br><span class="line">Please move or remove them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>

<p>你可以通过 <code>checkout -f</code> 来强制切换，但是要小心，如果其中还有未保存的修改，这个命令会把它们覆盖掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -f master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>

<p>当你切换回来之后，因为某些原因你得到了一个空的 <code>CryptoLibrary</code> 目录，并且 <code>git submodule update</code> 也无法修复它。 你需要进入到子模块目录中运行 <code>git checkout .</code> 来找回所有的文件。 你也可以通过 <code>submodule foreach</code> 脚本来为多个子模块运行它。</p>
<p>要特别注意的是，近来子模块会将它们的所有 Git 数据保存在顶级项目的 <code>.git</code> 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失任何提交或分支。</p>
<p>拥有了这些工具，使用子模块会成为可以在几个相关但却分离的项目上同时开发的相当简单有效的方法。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\08\Git：服务器\" rel="bookmark">Git：服务器</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\07\Git：分支\" rel="bookmark">Git：分支</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\11\Git：自定义\" rel="bookmark">Git：自定义</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\09\Git：分布式\" rel="bookmark">Git：分布式</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\06\Git：基础\" rel="bookmark">Git：基础</a></div>
      
    </li>
  
  </ul>

        
      
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/uploads/wechatpay.png" alt="彭真进 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/uploads/alipay.png" alt="彭真进 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>彭真进</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://pengzhenjin.top/2018/06/10/Git：工具/" title="Git：工具">http://pengzhenjin.top/2018/06/10/Git：工具/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Git/" rel="tag"><i class="fa fa-tag"></i> Git</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2018/06/09/Git：分布式/" rel="next" title="Git：分布式">
                  <i class="fa fa-chevron-left"></i> Git：分布式
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2018/06/11/Git：自定义/" rel="prev" title="Git：自定义">
                  Git：自定义 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择修订版本"><span class="nav-number">1.</span> <span class="nav-text">选择修订版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单个修订版本"><span class="nav-number">1.1.</span> <span class="nav-text">单个修订版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简短的-SHA-1"><span class="nav-number">1.2.</span> <span class="nav-text">简短的 SHA-1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分支引用"><span class="nav-number">1.3.</span> <span class="nav-text">分支引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用日志"><span class="nav-number">1.4.</span> <span class="nav-text">引用日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#祖先引用"><span class="nav-number">1.5.</span> <span class="nav-text">祖先引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提交区间"><span class="nav-number">1.6.</span> <span class="nav-text">提交区间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交互式暂存"><span class="nav-number">2.</span> <span class="nav-text">交互式暂存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#暂存与取消暂存文件"><span class="nav-number">2.1.</span> <span class="nav-text">暂存与取消暂存文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暂存补丁"><span class="nav-number">2.2.</span> <span class="nav-text">暂存补丁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#储藏与清理"><span class="nav-number">3.</span> <span class="nav-text">储藏与清理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#储藏工作"><span class="nav-number">3.1.</span> <span class="nav-text">储藏工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创造性的储藏"><span class="nav-number">3.2.</span> <span class="nav-text">创造性的储藏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从储藏创建一个分支"><span class="nav-number">3.3.</span> <span class="nav-text">从储藏创建一个分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清理工作目录"><span class="nav-number">3.4.</span> <span class="nav-text">清理工作目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#签署工作"><span class="nav-number">4.</span> <span class="nav-text">签署工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GPG-介绍"><span class="nav-number">4.1.</span> <span class="nav-text">GPG 介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#签署标签"><span class="nav-number">4.2.</span> <span class="nav-text">签署标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证标签"><span class="nav-number">4.3.</span> <span class="nav-text">验证标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#签署提交"><span class="nav-number">4.4.</span> <span class="nav-text">签署提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#每个人必须签署"><span class="nav-number">4.5.</span> <span class="nav-text">每个人必须签署</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索"><span class="nav-number">5.</span> <span class="nav-text">搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-Grep"><span class="nav-number">5.1.</span> <span class="nav-text">Git Grep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-日志搜索"><span class="nav-number">5.2.</span> <span class="nav-text">Git 日志搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写历史"><span class="nav-number">6.</span> <span class="nav-text">重写历史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改最后一次提交"><span class="nav-number">6.1.</span> <span class="nav-text">修改最后一次提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改多个提交信息"><span class="nav-number">6.2.</span> <span class="nav-text">修改多个提交信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新排序提交"><span class="nav-number">6.3.</span> <span class="nav-text">重新排序提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩提交"><span class="nav-number">6.4.</span> <span class="nav-text">压缩提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拆分提交"><span class="nav-number">6.5.</span> <span class="nav-text">拆分提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核武器级选项：filter-branch"><span class="nav-number">6.6.</span> <span class="nav-text">核武器级选项：filter-branch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重置揭密"><span class="nav-number">7.</span> <span class="nav-text">重置揭密</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三棵树"><span class="nav-number">7.1.</span> <span class="nav-text">三棵树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作流程"><span class="nav-number">7.2.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重置的作用"><span class="nav-number">7.3.</span> <span class="nav-text">重置的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过路径来重置"><span class="nav-number">7.4.</span> <span class="nav-text">通过路径来重置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩"><span class="nav-number">7.5.</span> <span class="nav-text">压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检出"><span class="nav-number">7.6.</span> <span class="nav-text">检出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">7.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级合并"><span class="nav-number">8.</span> <span class="nav-text">高级合并</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高级合并-1"><span class="nav-number">8.1.</span> <span class="nav-text">高级合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#中断一次合并"><span class="nav-number">8.1.1.</span> <span class="nav-text">中断一次合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#忽略空白"><span class="nav-number">8.1.2.</span> <span class="nav-text">忽略空白</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#手动文件再合并"><span class="nav-number">8.1.3.</span> <span class="nav-text">手动文件再合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检出冲突"><span class="nav-number">8.1.4.</span> <span class="nav-text">检出冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并日志"><span class="nav-number">8.1.5.</span> <span class="nav-text">合并日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组合式差异格式"><span class="nav-number">8.1.6.</span> <span class="nav-text">组合式差异格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#撤消合并"><span class="nav-number">8.2.</span> <span class="nav-text">撤消合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#修复引用"><span class="nav-number">8.2.1.</span> <span class="nav-text">修复引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#还原提交"><span class="nav-number">8.2.2.</span> <span class="nav-text">还原提交</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他类型的合并"><span class="nav-number">8.3.</span> <span class="nav-text">其他类型的合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#我们的或他们的偏好"><span class="nav-number">8.3.1.</span> <span class="nav-text">我们的或他们的偏好</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子树合并"><span class="nav-number">8.3.2.</span> <span class="nav-text">子树合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Git-调试"><span class="nav-number">9.</span> <span class="nav-text">使用 Git 调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件标注"><span class="nav-number">9.1.</span> <span class="nav-text">文件标注</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找"><span class="nav-number">9.2.</span> <span class="nav-text">二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子模块"><span class="nav-number">10.</span> <span class="nav-text">子模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开始使用子模块"><span class="nav-number">10.1.</span> <span class="nav-text">开始使用子模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆含有子模块的项目"><span class="nav-number">10.2.</span> <span class="nav-text">克隆含有子模块的项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在包含子模块的项目上工作"><span class="nav-number">10.3.</span> <span class="nav-text">在包含子模块的项目上工作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拉取上游修改"><span class="nav-number">10.3.1.</span> <span class="nav-text">拉取上游修改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在子模块上工作"><span class="nav-number">10.3.2.</span> <span class="nav-text">在子模块上工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#发布子模块改动"><span class="nav-number">10.3.3.</span> <span class="nav-text">发布子模块改动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并子模块改动"><span class="nav-number">10.3.4.</span> <span class="nav-text">合并子模块改动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子模块技巧"><span class="nav-number">10.4.</span> <span class="nav-text">子模块技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#子模块遍历"><span class="nav-number">10.4.1.</span> <span class="nav-text">子模块遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有用的别名"><span class="nav-number">10.4.2.</span> <span class="nav-text">有用的别名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子模块的问题"><span class="nav-number">10.5.</span> <span class="nav-text">子模块的问题</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="彭真进">
  <p class="site-author-name" itemprop="name">彭真进</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/pengzhenjin" title="GitHub &rarr; https://github.com/pengzhenjin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:562260994@qq.com" title="E-Mail &rarr; mailto:562260994@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://hexo.io/zh-cn" title="https://hexo.io/zh-cn" rel="noopener" target="_blank">Hexo</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://theme-next.org/docs" title="https://theme-next.org/docs" rel="noopener" target="_blank">NexT</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">彭真进 版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">417k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">6:19</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a0aefd8233242f4272c5',
      clientSecret: '89cbd8c8415d03a931cdeba5a9146e38803a1ad7',
      repo: 'pengzhenjin.github.io',
      owner: 'pengzhenjin',
      admin: ['pengzhenjin'],
      id: '9b55dd8f000b78e1ba6fbd4ec86056bd',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
