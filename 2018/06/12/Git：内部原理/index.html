<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-me.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-me.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。 我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。 因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。">
<meta name="keywords" content="Git">
<meta property="og:type" content="article">
<meta property="og:title" content="Git：内部原理">
<meta property="og:url" content="http://pengzhenjin.top/2018/06/12/Git：内部原理/index.html">
<meta property="og:site_name" content="彭真进的博客">
<meta property="og:description" content="无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。 我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。 因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/12/Git：内部原理/git-chapter-2/img1.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/12/Git：内部原理/git-chapter-2/img2.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/12/Git：内部原理/git-chapter-2/img3.png">
<meta property="og:image" content="http://pengzhenjin.top/2018/06/12/Git：内部原理/git-chapter-3/img1.png">
<meta property="og:updated_time" content="2019-08-31T02:44:25.650Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git：内部原理">
<meta name="twitter:description" content="无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。 我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。 因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。">
<meta name="twitter:image" content="http://pengzhenjin.top/2018/06/12/Git：内部原理/git-chapter-2/img1.png">
  <link rel="canonical" href="http://pengzhenjin.top/2018/06/12/Git：内部原理/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Git：内部原理 | 彭真进的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ede0ba70e7eb2eb800e94196368893eb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">彭真进的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">业精于勤荒于嬉，行成于思毁于随</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://pengzhenjin.top/2018/06/12/Git：内部原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭真进">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="彭真进的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Git：内部原理

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-12T00:00:00+08:00">2018-06-12</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>46k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>42 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。 我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。 因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。</p><a id="more"></a>
<p>无论如何，既然已经读到了这里，就让我们开始吧。 首先要弄明白一点，从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。 马上你就会学到这意味着什么。</p>
<p>早期的 Git（主要是 1.5 之前的版本）的用户界面要比现在复杂的多，因为它更侧重于作为一个文件系统，而不是一个打磨过的版本控制系统。 不时会有一些陈词滥调抱怨早期那个晦涩复杂的 Git 用户界面；不过最近几年来，它已经被改进到不输于任何其他版本控制系统地清晰易用了。</p>
<p>内容寻址文件系统层是一套相当酷的东西，所以在本章我们会先讲解这部分内容。随后我们会学习传输机制和版本库管理任务——你迟早会和它们打交道。</p>
<h3 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h3><p>本书旨在讨论如何通过 checkout、branch、remote 等大约 30 个诸如此类动词形式的命令来玩转 Git。 然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>
<p>本书前九章专注于探讨高层命令。 然而在本章，我们将主要面对底层命令。 因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。 多数底层命令并不面向最终用户：它们更适合作为新命令和自定义脚本的组成部分。</p>
<p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含了几乎所有 Git 存储和操作的对象。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 该目录的结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -F1</span><br><span class="line">HEAD</span><br><span class="line">config*</span><br><span class="line">description</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure>

<p>该目录下可能还会包含其他文件，不过对于一个全新的 git init 版本库，这将是你看到的默认结构。 description 文件仅供 GitWeb 程序使用，我们无需关心。 config 文件包含项目特有的配置选项。 info 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。 hooks 目录包含客户端或服务端的钩子脚本（hook scripts），在 Git 钩子 中这部分话题已被详细探讨过。</p>
<p>剩下的四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。 这些条目是 Git 的核心组成部分。 objects 目录存储所有数据内容；refs 目录存储指向数据（分支）的提交对象的指针；HEAD 文件指示目前被检出的分支；index 文件保存暂存区信息。 我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</p>
<h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git 是一个内容寻址文件系统。 看起来很酷， 但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 可以通过底层命令 <code>hash-object</code> 来演示上述效果——该命令可将任意数据保存于 <code>.git</code> 目录，并返回相应的键值。 首先，我们需要初始化一个新的 Git 版本库，并确认 <code>objects</code> 目录为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git init test</span><br><span class="line">Initialized empty Git repository in /tmp/test/.git/</span><br><span class="line">$ cd test</span><br><span class="line">$ find .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br><span class="line">$ find .git/objects -type f</span><br></pre></td></tr></table></figure>

<p>可以看到 Git 对 <code>objects</code> 目录进行了初始化，并创建了 <code>pack</code> 和 <code>info</code> 子目录，但均为空。 接着，往 Git 数据库存入一些文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;test content&apos; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p><code>-w</code> 选项指示 <code>hash-object</code> 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。 <code>--stdin</code> 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。 现在我们可以查看 Git 是如何存储数据的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>可以在 <code>objects</code> 目录下看到一个文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>
<p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code>cat-file</code> 指定 -p 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure>

<p>至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。 我们同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;version 1&apos; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure>

<p>接着，向文件里写入新内容，并再次将其存入数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;version 2&apos; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br></pre></td></tr></table></figure>

<p>数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>现在可以把文件内容恢复到第一个版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">version 1</span><br></pre></td></tr></table></figure>

<p>或者第二个版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">version 2</span><br></pre></td></tr></table></figure>

<p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）。 利用 <code>cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">blob</span><br></pre></td></tr></table></figure>

<h4 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h4><p>接下来要探讨的对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br></pre></td></tr></table></figure>

<p><code>master^{tree}</code> 语法表示 <code>master</code> 分支上最新的提交所指向的树对象。 请注意，<code>lib</code> 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure>

<p>从概念上讲，Git 内部存储的数据有点像这样：</p>
<p><img src="git-chapter-2/img1.png" alt>    </p>
<p>你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。 因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令 <code>update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。 利用该命令，可以把 test.txt 文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定 <code>--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）；同样必需的还有 <code>--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 \</span><br><span class="line">  83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure>

<p>本例中，我们指定的文件模式为 <code>100644</code>，表明这是一个普通文件。 其他选择包括：<code>100755</code>，表示一个可执行文件；<code>120000</code>，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p>
<p>现在，可以通过 <code>write-tree</code> 命令将暂存区内容写入一个树对象。 此处无需指定 <code>-w</code> 选项——如果某个树对象此前并不存在的话，当调用 <code>write-tree</code> 命令时，它会根据当前暂存区状态自动创建一个新的树对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</span><br></pre></td></tr></table></figure>

<p>不妨验证一下它确实是一个树对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">tree</span><br></pre></td></tr></table></figure>

<p>接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;new file&apos; &gt; new.txt</span><br><span class="line">$ git update-index --cacheinfo 100644 \</span><br><span class="line">  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line">$ git update-index --add new.txt</span><br></pre></td></tr></table></figure>

<p>暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure>

<p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code>1f7a7a</code>）是先前值的“第二版”。 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。 本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure>

<p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p>
<p><img src="git-chapter-2/img2.png" alt>    </p>
<h4 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h4><p>现在有三个树对象，分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p>
<p>可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;first commit&apos; | git commit-tree d8329f</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br></pre></td></tr></table></figure>

<p>现在可以通过 <code>cat-file</code> 命令查看这个新提交对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line">committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure>

<p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的 <code>user.name</code> 和 <code>user.email</code> 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</p>
<p>接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;second commit&apos; | git commit-tree 0155eb -p fdf4fc3</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d</span><br><span class="line">$ echo &apos;third commit&apos;  | git commit-tree 3c4e9c -p cac0cab</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure>

<p>这三个提交对象分别指向之前创建的三个树对象快照中的一个。 现在，如果对最后一个提交的 SHA-1 值运行 <code>git log</code> 命令，会出乎意料的发现，你已有一个货真价实的、可由 <code>git log</code> 查看的 Git 提交历史了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat 1a410e</span><br><span class="line">commit 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:15:24 2009 -0700</span><br><span class="line"></span><br><span class="line">	third commit</span><br><span class="line"></span><br><span class="line"> bak/test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit cac0cab538b970a37ea1e769cbbde608743bc96d</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:14:29 2009 -0700</span><br><span class="line"></span><br><span class="line">	second commit</span><br><span class="line"></span><br><span class="line"> new.txt  | 1 +</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:09:34 2009 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>太神奇了： 就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下。 下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2</span><br><span class="line">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2</span><br><span class="line">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1</span><br><span class="line">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &apos;test content&apos;</span><br><span class="line">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1</span><br><span class="line">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt</span><br><span class="line">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</span><br></pre></td></tr></table></figure>

<p>如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p>
<p><img src="git-chapter-2/img3.png" alt>    </p>
<h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>前文曾提及，在存储内容时，会有个头部信息一并被保存。 让我们略花些时间来看看 Git 是如何存储其对象的。 通过在 Ruby 脚本语言中交互式地演示，你将看到一个数据对象——本例中是字符串“what is up, doc?”——是如何被存储的。</p>
<p>可以通过 <code>irb</code> 命令启动 Ruby 的交互模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ irb</span><br><span class="line">&gt;&gt; content = &quot;what is up, doc?&quot;</span><br><span class="line">=&gt; &quot;what is up, doc?&quot;</span><br></pre></td></tr></table></figure>

<p>Git 以对象类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。 接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; header = &quot;blob #&#123;content.length&#125;\0&quot;</span><br><span class="line">=&gt; &quot;blob 16\u0000&quot;</span><br></pre></td></tr></table></figure>

<p>Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。 在 Ruby 中可以这样计算 SHA-1 值——先通过 <code>require</code> 命令导入 SHA-1 digest 库，然后对目标字符串调用 <code>Digest::SHA1.hexdigest()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; store = header + content</span><br><span class="line">=&gt; &quot;blob 16\u0000what is up, doc?&quot;</span><br><span class="line">&gt;&gt; require &apos;digest/sha1&apos;</span><br><span class="line">=&gt; true</span><br><span class="line">&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)</span><br><span class="line">=&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span><br></pre></td></tr></table></figure>

<p>Git 会通过 zlib 压缩这条新内容。在 Ruby 中可以借助 zlib 库做到这一点。 先导入相应的库，然后对目标内容调用 <code>Zlib::Deflate.deflate()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; require &apos;zlib&apos;</span><br><span class="line">=&gt; true</span><br><span class="line">&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)</span><br><span class="line">=&gt; &quot;x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D&quot;</span><br></pre></td></tr></table></figure>

<p>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在，可以通过 Ruby 中的 <code>FileUtils.mkdir_p()</code> 函数来创建它。 接着，通过 <code>File.open()</code> 打开这个文件。最后，对上一步中得到的文件句柄调用 <code>write()</code> 函数，以向目标文件写入之前那条 zlib 压缩过的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; path = &apos;.git/objects/&apos; + sha1[0,2] + &apos;/&apos; + sha1[2,38]</span><br><span class="line">=&gt; &quot;.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span><br><span class="line">&gt;&gt; require &apos;fileutils&apos;</span><br><span class="line">=&gt; true</span><br><span class="line">&gt;&gt; FileUtils.mkdir_p(File.dirname(path))</span><br><span class="line">=&gt; &quot;.git/objects/bd&quot;</span><br><span class="line">&gt;&gt; File.open(path, &apos;w&apos;) &#123; |f| f.write zlib_content &#125;</span><br><span class="line">=&gt; 32</span><br></pre></td></tr></table></figure>

<p>就是这样——你已创建了一个有效的 Git 数据对象。 所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>
<h3 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h3><p>我们可以借助类似于 <code>git log 1a410e</code> 这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住 <code>1a410e</code> 是最后一个提交。 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p>
<p>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 <code>.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br><span class="line">$ find .git/refs -type f</span><br></pre></td></tr></table></figure>

<p>若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure>

<p>现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline  master</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure>

<p>我们不提倡直接编辑引用文件。 如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成此事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure>

<p>这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。 若想在第二个提交上创建一个分支，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/test cac0ca</span><br></pre></td></tr></table></figure>

<p>这个分支将只包含从第二个提交开始往前追溯的记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline test</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure>

<p>至此，我们的 Git 数据库从概念上看起来像这样：</p>
<p><img src="git-chapter-3/img1.png" alt></p>
<p>当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</p>
<h4 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h4><p>现在的问题是，当你执行 <code>git branch (branchname)</code> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p>
<p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。 如果查看 HEAD 文件的内容，一般而言我们看到的类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p>如果执行 <code>git checkout test</code>，Git 会像这样更新 HEAD 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure>

<p>当我们执行 <code>git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p>
<p>你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code>symbolic-ref</code>。 可以借助此命令来查看 HEAD 引用对应的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD</span><br><span class="line">refs/heads/master</span><br></pre></td></tr></table></figure>

<p>同样可以设置 HEAD 引用的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure>

<p>不能把符号引用设置为一个不符合引用格式的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD test</span><br><span class="line">fatal: Refusing to point HEAD outside of refs/</span><br></pre></td></tr></table></figure>

<p>标签引用<br>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。 标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>
<p>正如 Git 基础 中所讨论的那样，存在两种类型的标签：附注标签和轻量标签。 可以像这样创建一个轻量标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</span><br></pre></td></tr></table></figure>

<p>这就是轻量标签的全部内容——一个固定的引用。 然而，一个附注标签则更复杂一些。 若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。 可以通过创建一个附注标签来验证这个过程（<code>-a</code> 选项指定了要创建的是一个附注标签）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m &apos;test tag&apos;</span><br></pre></td></tr></table></figure>

<p>下面是上述过程所建标签对象的 SHA-1 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br></pre></td></tr></table></figure>

<p>现在对该 SHA-1 值运行 <code>cat-file</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br><span class="line">object 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">type commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700</span><br><span class="line"></span><br><span class="line">test tag</span><br></pre></td></tr></table></figure>

<p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。 例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。 可以克隆一个 Git 版本库，然后通过执行下面的命令来在这个版本库中查看上述公钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file blob junio-gpg-pub</span><br></pre></td></tr></table></figure>

<p>Linux 内核版本库同样有一个不指向提交对象的标签对象——首个被创建的标签对象所指向的是最初被引入版本库的那份内核源码所对应的树对象。</p>
<h4 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h4><p>我们将看到的第三种引用类型是远程引用（remote reference）。 如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code>refs/remotes</code> 目录下。 例如，你可以添加一个叫做 <code>origin</code> 的远程版本库，然后把 <code>master</code> 分支推送上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:schacon/simplegit-progit.git</span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 11, done.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (7/7), 716 bytes, done.</span><br><span class="line">Total 7 (delta 2), reused 4 (delta 1)</span><br><span class="line">To git@github.com:schacon/simplegit-progit.git</span><br><span class="line">  a11bef0..ca82a6d  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>此时，如果查看 <code>refs/remotes/origin/master</code> 文件，可以发现 <code>origin</code> 远程版本库的 <code>master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code>master</code> 分支所对应的 SHA-1 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/remotes/origin/master</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure>

<p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>
<h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>让我们重新回到示例 Git 版本库的对象数据库。 目前为止，可以看到有 11 个对象——4 个数据对象、3 个树对象、3 个提交对象和 1 个标签对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2</span><br><span class="line">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2</span><br><span class="line">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1</span><br><span class="line">.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag</span><br><span class="line">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &apos;test content&apos;</span><br><span class="line">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1</span><br><span class="line">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt</span><br><span class="line">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</span><br></pre></td></tr></table></figure>

<p>Git 使用 zlib 压缩这些文件的内容，而且我们并没有存储太多东西，所以上文中的文件一共只占用了 925 字节。 接下来，我们会指引你添加一些大文件到版本库中，以此展示 Git 的一个很有趣的功能。 为了便于展示，我们要把之前在 Grit 库中用到过的 <code>repo.rb</code> 文件添加进来——这是一个大小约为 22K 的源代码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb</span><br><span class="line">$ git add repo.rb</span><br><span class="line">$ git commit -m &apos;added repo.rb&apos;</span><br><span class="line">[master 484a592] added repo.rb</span><br><span class="line"> 3 files changed, 709 insertions(+), 2 deletions(-)</span><br><span class="line"> delete mode 100644 bak/test.txt</span><br><span class="line"> create mode 100644 repo.rb</span><br><span class="line"> rewrite test.txt (100%)</span><br></pre></td></tr></table></figure>

<p>如果你查看生成的树对象，可以看到 repo.rb 文件对应的数据对象的 SHA-1 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb</span><br><span class="line">100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</span><br></pre></td></tr></table></figure>

<p>接下来你可以使用 <code>git cat-file</code> 命令查看这个对象有多大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5</span><br><span class="line">22044</span><br></pre></td></tr></table></figure>

<p>现在，稍微修改这个文件，然后看看会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;# testing&apos; &gt;&gt; repo.rb</span><br><span class="line">$ git commit -am &apos;modified repo a bit&apos;</span><br><span class="line">[master 2431da6] modified repo.rb a bit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>查看这个提交生成的树对象，你会看到一些有趣的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb</span><br><span class="line">100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</span><br></pre></td></tr></table></figure>

<p>repo.rb 对应一个与之前完全不同的数据对象，这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e</span><br><span class="line">22054</span><br></pre></td></tr></table></figure>

<p>你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象。 如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？</p>
<p>事实上 Git 可以那样做。 Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，你可以手动执行 <code>git gc</code> 命令让 Git 对对象进行打包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">Counting objects: 18, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (14/14), done.</span><br><span class="line">Writing objects: 100% (18/18), done.</span><br><span class="line">Total 18 (delta 3), reused 0 (delta 0)</span><br></pre></td></tr></table></figure>

<p>这个时候再查看 objects 目录，你会发现大部分的对象都不见了，与此同时出现了一对新文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">.git/objects/info/packs</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</span><br></pre></td></tr></table></figure>

<p>仍保留着的几个对象是未被任何提交记录引用的数据对象——在此例中是你之前创建的 “what is up, doc?” 和 “test content” 这两个示例数据对象。 因为你从没将它们添加至任何提交记录中，所以 Git 认为它们是悬空（dangling）的，不会将它们打包进新生成的包文件中。</p>
<p>剩下的文件是新创建的包文件和一个索引。 包文件包含了刚才从文件系统中移除的所有对象的内容。 索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。 有意思的是运行 gc 命令前磁盘上的对象大小约为 22K，而这个新生成的包文件大小仅有 7K。 通过打包对象减少了2/3的磁盘占用空间。</p>
<p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 <code>git verify-pack</code> 这个底层命令可以让你查看已打包的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12</span><br><span class="line">69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167</span><br><span class="line">80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319</span><br><span class="line">43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464</span><br><span class="line">092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610</span><br><span class="line">702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756</span><br><span class="line">d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874</span><br><span class="line">fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132</span><br><span class="line">deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178</span><br><span class="line">d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \</span><br><span class="line">  deef2e1b793907545e50a2ea2ddb5ba6c58c4506</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \</span><br><span class="line">  deef2e1b793907545e50a2ea2ddb5ba6c58c4506</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426</span><br><span class="line">fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445</span><br><span class="line">b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463</span><br><span class="line">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \</span><br><span class="line">  b042a60ef7dff760008df33cee372b945b6e884e</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282</span><br><span class="line">non delta: 15 objects</span><br><span class="line">chain length = 1: 3 objects</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</span><br></pre></td></tr></table></figure>

<p>此处，<code>033b4</code> 这个数据对象（即 repo.rb 文件的第一个版本，如果你还记得的话）引用了数据对象 <code>b042a</code>，即该文件的第二个版本。 命令输出内容的第三列显示的是各个对象在包文件中的大小，可以看到 <code>b042a</code> 占用了 22K 空间，而 <code>033b4</code> 仅占用 9 字节。 同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p>
<p>最妙之处是你可以随时重新打包。 Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 <code>git gc</code> 命令来这么做。</p>
<h3 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h3><p>纵观全书，我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。 假设你添加了这样一个远程版本库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure>

<p>上述命令会在你的 <code>.git/config</code> 文件中添加一个小节，并在其中指定远程版本库的名称（<code>origin</code>）、URL 和一个用于获取操作的引用规格（refspec）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>

<p>引用规格的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<code>&lt;dst&gt;</code> 是那些远程引用在本地所对应的位置。 <code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p>
<p>默认情况下，引用规格由 <code>git remote add</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。 所以，如果服务器上有一个 <code>master</code> 分支，我们可以在本地通过下面这种方式来访问该分支上的提交记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin/master</span><br><span class="line">$ git log remotes/origin/master</span><br><span class="line">$ git log refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p>
<p>如果想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>这仅是针对该远程版本库的 <code>git fetch</code> 操作的默认引用规格。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。 若要将远程的 <code>master</code> 分支拉到本地的 <code>origin/mymaster</code> 分支，可以运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster</span><br></pre></td></tr></table></figure>

<p>你也可以指定多个引用规格。 在命令行中，你可以按照如下的方式拉取多个分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster \</span><br><span class="line">	 topic:refs/remotes/origin/topic</span><br><span class="line">From git@github.com:schacon/simplegit</span><br><span class="line"> ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)</span><br><span class="line"> * [new branch]      topic      -&gt; origin/topic</span><br></pre></td></tr></table></figure>

<p>在这个例子中，对 <code>master</code> 分支的拉取操作被拒绝，因为它不是一个可以快进的引用。 我们可以通过在引用规格之前指定 <code>+</code> 号来覆盖该规则。</p>
<p>你也可以在配置文件中指定多个用于获取操作的引用规格。 如果想在每次获取时都包括 <code>master</code> 和 <code>experiment</code> 分支，添加如下两行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">	fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br></pre></td></tr></table></figure>

<p>我们不能在模式中使用部分通配符，所以像下面这样的引用规格是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/qa*:refs/remotes/origin/qa*</span><br></pre></td></tr></table></figure>

<p>但我们可以使用命名空间（或目录）来达到类似目的。 假设你有一个 QA 团队，他们推送了一系列分支，同时你只想要获取 <code>master</code> 和 QA 团队的所有分支而不关心其他任何分支，那么可以使用如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br></pre></td></tr></table></figure>

<p>如果项目的工作流很复杂，有 QA 团队推送分支、开发人员推送分支、集成团队推送并且在远程分支上展开协作，你就可以像这样（在本地）为这些分支创建各自的命名空间，非常方便。</p>
<h4 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h4><p>像上面这样从远程版本库获取已在命名空间中的引用当然很棒，但 QA 团队最初应该如何将他们的分支放入远程的 <code>qa/</code> 命名空间呢？ 我们可以通过引用规格推送来完成这个任务。</p>
<p>如果 QA 团队想把他们的 <code>master</code> 分支推送到远程服务器的 <code>qa/master</code> 分支上，可以运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure>

<p>如果他们希望 Git 每次运行 <code>git push origin</code> 时都像上面这样推送，可以在他们的配置文件中添加一条 <code>push</code> 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">	push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure>

<p>正如刚才所指出的，这会让 <code>git push origin</code> 默认把本地 <code>master</code> 分支推送到远程 <code>qa/master</code> 分支。</p>
<h4 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h4><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :topic</span><br></pre></td></tr></table></figure>

<p>因为引用规格（的格式）是 <code>&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code>&lt;src&gt;</code> 留空，意味着把远程版本库的 <code>topic</code> 分支定义为空值，也就是删除它。</p>
<p>或者你可以使用更新的语法（自 Git v1.7.0以后可用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete topic</span><br></pre></td></tr></table></figure>

<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。 本节将会带你快速浏览这两种协议的运作方式。</p>
<h4 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h4><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p>
<p>让我们通过 simplegit 版本库来看看 <code>http-fetch</code> 的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http://server/simplegit-progit.git</span><br></pre></td></tr></table></figure>

<p>它做的第一件事就是拉取 <code>info/refs</code> 文件。 这个文件是通过 <code>update-server-info</code> 命令生成的，这也解释了在使用 HTTP 传输时，必须把它设置为 <code>post-receive</code> 钩子的原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET info/refs</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</span><br></pre></td></tr></table></figure>

<p>现在，你得到了一个远程引用和 SHA-1 值的列表。 接下来，你要确定 HEAD 引用是什么，这样你就知道在完成后应该被检出到工作目录的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p>这说明在完成抓取后，你需要检出 <code>master</code> 分支。 这时，你就可以开始遍历处理了。 因为你是从 <code>info/refs</code> 文件中所提到的 <code>ca82a6</code> 提交对象开始的，所以你的首要操作是获取它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949</span><br><span class="line">(179 bytes of binary data)</span><br></pre></td></tr></table></figure>

<p>你取回了一个对象——这是一个在服务端以松散格式保存的对象，是你通过使用静态 HTTP GET 请求获取的。 你可以使用 zlib 解压缩它，去除其头部，查看提交记录的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700</span><br><span class="line">committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</span><br><span class="line"></span><br><span class="line">changed the version number</span><br></pre></td></tr></table></figure>

<p>接下来，你还要再获取两个对象，一个是树对象 <code>cfda3b</code>，它包含有我们刚刚获取的提交对象所指向的内容，另一个是它的父提交 <code>085bb3</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">(179 bytes of data)</span><br></pre></td></tr></table></figure>

<p>这样就取得了你的下一个提交对象。 再抓取树对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">(404 - Not Found)</span><br></pre></td></tr></table></figure>

<p>噢——看起来这个树对象在服务端并不以松散格式对象存在，所以你得到了一个 404 响应，代表在 HTTP 服务端没有找到该对象。 这有好几个可能的原因——这个对象可能在替代版本库里面，或者在包文件里面。 Git 会首先检查所有列出的替代版本库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/info/http-alternates</span><br><span class="line">(empty file)</span><br></pre></td></tr></table></figure>

<p>如果这返回了一个包含替代版本库 URL 的列表，那么 Git 就会去那些地址检查松散格式对象和文件——这是一种能让派生项目共享对象以节省磁盘的好方法。 然而，在这个例子中，没有列出可用的替代版本库。所以你所需要的对象肯定在某个包文件中。 要检查服务端有哪些可用的包文件，你需要获取 <code>objects/info/packs</code> 文件，这里面有一个包文件列表（它也是通过执行 <code>update-server-info</code> 所生成的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/info/packs</span><br><span class="line">P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</span><br></pre></td></tr></table></figure>

<p>服务端只有一个包文件，所以你要的对象显然就在里面。但是你要先检查它的索引文件以确认。 即使服务端有多个包文件，这也是很有用的，因为这样你就可以知道你所需要的对象是在哪一个包文件里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx</span><br><span class="line">(4k of binary data)</span><br></pre></td></tr></table></figure>

<p>现在你有这个包文件的索引，你可以查看你要的对象是否在里面——因为索引文件列出了这个包文件所包含的所有对象的 SHA-1 值，和该对象存在于包文件中的偏移量。 你的对象就在这里，接下来就是获取整个包文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</span><br><span class="line">(13k of binary data)</span><br></pre></td></tr></table></figure>

<p>现在你也有了你的树对象，你可以继续在提交记录上漫游。 它们全部都在这个你刚下载的包文件里面，所以你不用继续向服务端请求更多下载了。 Git 会将开始时下载的 HEAD 引用所指向的 master 分支检出到工作目录。</p>
<h4 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h4><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>
<h5 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h5><p>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</p>
<p><strong>SSH</strong><br>举例来说，在项目中使用命令 <code>git push origin master</code> 时, <code>origin</code> 是由基于 SSH 协议的 URL 所定义的。 Git 会运行 <code>send-pack</code> 进程，它会通过 SSH 连接你的服务器。 它会尝试通过 SSH 在服务端执行命令，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -x git@server &quot;git-receive-pack &apos;simplegit-progit.git&apos;&quot;</span><br><span class="line">00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \</span><br><span class="line">	delete-refs side-band-64k quiet ofs-delta \</span><br><span class="line">	agent=git/2:2.1.1+github-607-gfba4028 delete-refs</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p><code>git-receive-pack</code> 命令会立即为它所拥有的每一个引用发送一行响应——在这个例子中，就只有 <code>master</code> 分支和它的 SHA-1 值。 第一行响应中也包含了一个服务端能力的列表（这里是 <code>report-status、delete-refs</code> 和一些其它的，包括客户端的识别码）。</p>
<p>每一行以一个四位的十六进制值开始，用于指明本行的长度。 你看到第一行以 005b 开始，这在十六进制中表示 91，意味着第一行有 91 字节。 下一行以 003e 起始，也就是 62，所以下面需要读取 62 字节。 再下一行是 0000，表示服务端已完成了发送引用列表过程。</p>
<p>现在它知道了服务端的状态，你的 <code>send-pack</code> 进程会判断哪些提交记录是它所拥有但服务端没有的。 <code>send-pack</code> 会告知 <code>receive-pack</code> 这次推送将会更新的各个引用。 举个例子，如果你正在更新 <code>master</code> 分支，并且增加 <code>experiment</code> 分支，这个 <code>send-pack</code> 的响应将会是像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \</span><br><span class="line">	refs/heads/master report-status</span><br><span class="line">006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \</span><br><span class="line">	refs/heads/experiment</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p>Git 会为每一个将要更新的引用发送一行数据，包括该行长度，旧 SHA-1 值，新 SHA-1 值和将要更新的引用。 第一行也包括了客户端的能力。 这里的全为 0 的 SHA-1 值表示之前没有过这个引用——因为你正要添加新的 experiment 引用。 删除引用时，将会看到相反的情况：右边的 SHA-1 值全为 0。</p>
<p>接下来，客户端会发送一个包文件，它包含了所有服务端还没有的对象。 最后，服务端会以成功（或失败）响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000eunpack ok</span><br></pre></td></tr></table></figure>

<p><strong>HTTP(S)</strong><br>HTTPS 与 HTTP 相比较，除了在“握手”过程略有不同外，其他基本相似。 连接是从下面这个请求开始的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack</span><br><span class="line">001f# service=git-receive-pack</span><br><span class="line">00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master report-status \</span><br><span class="line">	delete-refs side-band-64k quiet ofs-delta \</span><br><span class="line">	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p>这完成了客户端和服务端的第一次数据交换。 接下来客户端发起另一个请求，这次是一个 POST 请求，这个请求中包含了 <code>git-upload-pack</code> 提供的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; POST http://server/simplegit-progit.git/git-receive-pack</span><br></pre></td></tr></table></figure>

<p>这个 <code>POST</code> 请求的内容是 <code>send-pack</code> 的输出和相应的包文件。 服务端在收到请求后相应地作出成功或失败的 HTTP 响应。</p>
<h5 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h5><p>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code>进程，以协商后续传输的数据。</p>
<p><strong>SSH</strong><br>如果你通过 SSH 使用抓取功能，<code>fetch-pack</code> 会像这样运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -x git@server &quot;git-upload-pack &apos;simplegit-progit.git&apos;&quot;</span><br></pre></td></tr></table></figure>

<p>在 <code>fetch-pack</code> 连接后，<code>upload-pack</code> 会返回类似下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00dfca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \</span><br><span class="line">	side-band side-band-64k ofs-delta shallow no-progress include-tag \</span><br><span class="line">	multi_ack_detailed symref=HEAD:refs/heads/master \</span><br><span class="line">	agent=git/2:2.1.1+github-607-gfba4028</span><br><span class="line">003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p>这与 <code>receive-pack</code> 的响应很相似，但是这里所包含的能力是不同的。 而且它还包含 HEAD 引用所指向内容（<code>symref=HEAD:refs/heads/master</code>），这样如果客户端执行的是克隆，它就会知道要检出什么。</p>
<p>这时候，<code>fetch-pack</code> 进程查看它自己所拥有的对象，并响应 “want” 和它需要的对象的 SHA-1 值。 它还会发送“have”和所有它已拥有的对象的 SHA-1 值。 在列表的最后，它还会发送“done”以通知 <code>upload-pack</code> 进程可以开始发送它所需对象的包文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta</span><br><span class="line">0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">0009done</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p><strong>HTTP(S)</strong><br>抓取操作的握手需要两个 HTTP 请求。 第一个是向和哑协议中相同的端点发送 <code>GET</code> 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET $GIT_URL/info/refs?service=git-upload-pack</span><br><span class="line">001e# service=git-upload-pack</span><br><span class="line">00e7ca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \</span><br><span class="line">	side-band side-band-64k ofs-delta shallow no-progress include-tag \</span><br><span class="line">	multi_ack_detailed no-done symref=HEAD:refs/heads/master \</span><br><span class="line">	agent=git/2:2.1.1+github-607-gfba4028</span><br><span class="line">003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p>这和通过 SSH 使用 <code>git-upload-pack</code> 是非常相似的，但是第二个数据交换则是一个单独的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0</span><br><span class="line">0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7</span><br><span class="line">0032have 441b40d833fdfa93eb2908e52742248faf0ee993</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>

<p>这个输出格式还是和前面一样的。 这个请求的响应包含了所需要的包文件，并指明成功或失败。</p>
<h4 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h4><p>这一章节是传输协议的一个概貌。 传输协议还有很多其它的特性，像是 <code>multi_ack</code> 或 <code>side-band</code>，但是这些内容已经超出了本书的范围。 我们希望能给你展示客户端和服务端之间的基本交互过程；如果你需要更多的相关知识，你可以参阅 Git 的源代码。</p>
<h3 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h3><p>有的时候，你需要对仓库进行清理——使它的结构变得更紧凑，或是对导入的仓库进行清理，或是恢复丢失的内容。 这个小节将会介绍这些情况中的一部分。</p>
<h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。 “gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<p>可以像下面一样手动执行自动垃圾回收：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git gc --auto</span><br></pre></td></tr></table></figure>

<p>就像上面提到的，这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。 你可以通过修改 <code>gc.auto</code> 与 <code>gc.autopacklimit</code> 的设置来改动这些数值。</p>
<p><code>gc</code> 将会做的另一件事是打包你的引用到一个单独的文件。 假设你的仓库包含以下分支与标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs -type f</span><br><span class="line">.git/refs/heads/experiment</span><br><span class="line">.git/refs/heads/master</span><br><span class="line">.git/refs/tags/v1.0</span><br><span class="line">.git/refs/tags/v1.1</span><br></pre></td></tr></table></figure>

<p>如果你执行了 <code>git gc</code> 命令，<code>refs</code> 目录中将不会再有这些文件。 为了保证效率 Git 会将它们移动到名为 <code>.git/packed-refs</code> 的文件中，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/packed-refs</span><br><span class="line"># pack-refs with: peeled fully-peeled</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</span><br><span class="line">^1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure>

<p>如果你更新了引用，Git 并不会修改这个文件，而是向 <code>refs/heads</code> 创建一个新的文件。 为了获得指定引用的正确 SHA-1 值，Git 会首先在 <code>refs</code> 目录中查找指定的引用，然后再到 <code>packed-refs</code> 文件中查找。 所以，如果你在 <code>refs</code> 目录中找不到一个引用，那么它或许在 packed-<code>refs</code> 文件中。</p>
<p>注意这个文件的最后一行，它会以 <code>^</code> 开头。 这个符号表示它上一行的标签是附注标签，<code>^</code> 所在的那一行是附注标签指向的那个提交。</p>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？</p>
<p>下面的例子将硬重置你的测试仓库中的 master 分支到一个旧的提交，以此来恢复丢失的提交。 首先，让我们看看你的仓库现在在什么地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</span><br><span class="line">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure>

<p>现在，我们将 <code>master</code> 分支硬重置到第三次提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">HEAD is now at 1a410ef third commit</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure>

<p>现在顶部的两个提交已经丢失了——没有分支指向这些提交。 你需要找出最后一次提交的 SHA-1 然后增加一个指向它的分支。 窍门就是找到最后一次的提交的 SHA-1 ——但是估计你记不起来了，对吗？</p>
<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 <code>git update-ref</code> 命令更新，我们在 Git 引用 有提到使用这个命令而不是是直接将 SHA-1 的值写入引用文件中的原因。 你可以在任何时候通过执行 <code>git reflog</code> 命令来了解你曾经做过什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">1a410ef HEAD@&#123;0&#125;: reset: moving to 1a410ef</span><br><span class="line">ab1afef HEAD@&#123;1&#125;: commit: modified repo.rb a bit</span><br><span class="line">484a592 HEAD@&#123;2&#125;: commit: added repo.rb</span><br></pre></td></tr></table></figure>

<p>这里可以看到我们已经检出的两次提交，然而并没有足够多的信息。 为了使显示的信息更加有用，我们可以执行 <code>git log -g</code>，这个命令会以标准日志的格式输出引用日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log -g</span><br><span class="line">commit 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">Reflog: HEAD@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: updating HEAD</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:22:37 2009 -0700</span><br><span class="line"></span><br><span class="line">		third commit</span><br><span class="line"></span><br><span class="line">commit ab1afef80fac8e34258ff41fc1b867c702daa24b</span><br><span class="line">Reflog: HEAD@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: updating HEAD</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:15:24 2009 -0700</span><br><span class="line"></span><br><span class="line">       modified repo.rb a bit</span><br></pre></td></tr></table></figure>

<p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。 例如，你可以创建一个名为 <code>recover-branch</code> 的分支指向这个提交（ab1afef）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch recover-branch ab1afef</span><br><span class="line">$ git log --pretty=oneline recover-branch</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</span><br><span class="line">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure>

<p>不错，现在有一个名为 <code>recover-branch</code> 的分支是你的 <code>master</code> 分支曾经指向的地方，再一次使得前两次提交可到达了。 接下来，假设你丢失的提交因为某些原因不在引用日志中——我们可以通过移除 <code>recover-branch</code> 分支并删除引用日志来模拟这种情况。 现在前两次提交又不被任何分支指向了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D recover-branch</span><br><span class="line">$ rm -Rf .git/logs/</span><br></pre></td></tr></table></figure>

<p>由于引用日志数据存放在 <code>.git/logs/</code> 目录中，现在你已经没有引用日志了。 这时该如何恢复那次提交？ 一种方式是使用 <code>git fsck</code> 实用工具，将会检查数据库的完整性。 如果使用一个 <code>--full</code> 选项运行它，它会向你显示出所有没有被其他对象指向的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --full</span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (18/18), done.</span><br><span class="line">dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b</span><br><span class="line">dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9</span><br><span class="line">dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</span><br></pre></td></tr></table></figure>

<p>在这个例子中，你可以在 “dangling commit” 后看到你丢失的提交。 现在你可以用和之前相同的方法恢复这个提交，也就是添加一个指向这个提交的分支。</p>
<h4 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h4><p>Git 有很多很棒的功能，但是其中一个特性会导致问题，<code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。 如果所有的东西都是源代码那么这很好，因为 Git 被高度优化来有效地存储这种数据。 然而，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。 之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p>
<p>当你迁移 Subversion 或 Perforce 仓库到 Git 的时候，这会是一个严重的问题。 因为这些版本控制系统并不下载所有的历史文件，所以这种文件所带来的问题比较少。 如果你从其他的版本控制系统迁移到 Git 时发现仓库比预期的大得多，那么你就需要找到并移除这些大文件。</p>
<p><strong>警告：这个操作对提交历史的修改是破坏性的</strong>。 它会从你必须修改或移除一个大文件引用最早的树对象开始重写每一次提交。 如果你在导入仓库后，在任何人开始基于这些提交工作前执行这个操作，那么将不会有任何问题——否则，你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上。</p>
<p>为了演示，我们将添加一个大文件到测试仓库中，并在下一次提交中删除它，现在我们需要找到它，并将它从仓库中永久删除。 首先，添加一个大文件到仓库中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz</span><br><span class="line">$ git add git.tgz</span><br><span class="line">$ git commit -m &apos;add git tarball&apos;</span><br><span class="line">[master 7b30847] add git tarball</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 git.tgz</span><br></pre></td></tr></table></figure>

<p>哎呀——其实这个项目并不需要这个巨大的压缩文件。 现在我们将它移除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm git.tgz</span><br><span class="line">rm &apos;git.tgz&apos;</span><br><span class="line">$ git commit -m &apos;oops - removed large tarball&apos;</span><br><span class="line">[master dadf725] oops - removed large tarball</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 git.tgz</span><br></pre></td></tr></table></figure>

<p>现在，我们执行 <code>gc</code> 来查看数据库占用了多少空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">Counting objects: 17, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (13/13), done.</span><br><span class="line">Writing objects: 100% (17/17), done.</span><br><span class="line">Total 17 (delta 1), reused 10 (delta 0)</span><br></pre></td></tr></table></figure>

<p>你也可以执行 <code>count-objects</code> 命令来快速的查看占用空间大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git count-objects -v</span><br><span class="line">count: 7</span><br><span class="line">size: 32</span><br><span class="line">in-pack: 17</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 4868</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure>

<p><code>size-pack</code> 的数值指的是你的包文件以 KB 为单位计算的大小，所以你大约占用了 5MB 的空间。 在最后一次提交前，使用了不到 2KB ——显然，从之前的提交中移除文件并不能从历史中移除它。 每一次有人克隆这个仓库时，他们将必须克隆所有的 5MB 来获得这个微型项目，只因为你意外地添加了一个大文件。 现在来让我们彻底的移除这个文件。</p>
<p>首先你必须找到它。 在本例中，你已经知道是哪个文件了。 但是假设你不知道；该如何找出哪个文件或哪些文件占用了如此多的空间？ 如果你执行 <code>git gc</code> 命令，所有的对象将被放入一个包文件中，你可以通过运行 <code>git verify-pack</code> 命令，然后对输出内容的第三列（即文件大小）进行排序，从而找出这个大文件。 你也可以将这个命令的执行结果通过管道传送给 <code>tail</code> 命令，因为你只需要找到列在最后的几个大对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \</span><br><span class="line">  | sort -k 3 -n \</span><br><span class="line">  | tail -3</span><br><span class="line">dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12</span><br><span class="line">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696</span><br><span class="line">82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</span><br></pre></td></tr></table></figure>

<p>你可以看到这个大对象出现在返回结果的最底部：占用 5MB 空间。 为了找出具体是哪个文件，可以使用 <code>rev-list</code> 命令，我们在 指定特殊的提交信息格式 中曾提到过。 如果你传递 <code>--objects</code> 参数给 <code>rev-list</code> 命令，它就会列出所有提交的 SHA-1、数据对象的 SHA-1 和与它们相关联的文件路径。 可以使用以下命令来找出你的数据对象的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-list --objects --all | grep 82c99a3</span><br><span class="line">82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</span><br></pre></td></tr></table></figure>

<p>现在，你只需要从过去所有的树中移除这个文件。 使用以下命令可以轻松地查看哪些提交对这个文件产生改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --branches -- git.tgz</span><br><span class="line">dadf725 oops - removed large tarball</span><br><span class="line">7b30847 add git tarball</span><br></pre></td></tr></table></figure>

<p>现在，你必须重写 <code>7b30847</code> 提交之后的所有提交来从 Git 历史中完全移除这个文件。 为了执行这个操作，我们要使用 <code>filter-branch</code> 命令，这个命令在 重写历史 中也使用过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --index-filter \</span><br><span class="line">  &apos;git rm --ignore-unmatch --cached git.tgz&apos; -- 7b30847^..</span><br><span class="line">Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm &apos;git.tgz&apos;</span><br><span class="line">Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)</span><br><span class="line">Ref &apos;refs/heads/master&apos; was rewritten</span><br></pre></td></tr></table></figure>

<p><code>--index-filter</code> 选项类似于在 重写历史 中提到的的 <code>--tree-filter</code> 选项，不过这个选项并不会让命令将修改在硬盘上检出的文件，而只是修改在暂存区或索引中的文件。</p>
<p>你必须使用 <code>git rm --cached</code> 命令来移除文件，而不是通过类似 <code>rm file</code> 的命令——因为你需要从索引中移除它，而不是磁盘中。 还有一个原因是速度—— Git 在运行过滤器时，并不会检出每个修订版本到磁盘中，所以这个过程会非常快。 如果愿意的话，你也可以通过 <code>--tree-filter</code> 选项来完成同样的任务。 <code>git rm</code> 命令的 <code>--ignore-unmatch</code> 选项告诉命令：如果尝试删除的模式不存在时，不提示错误。 最后，使用 <code>filter-branch</code> 选项来重写自 7b30847 提交以来的历史，也就是这个问题产生的地方。 否则，这个命令会从最旧的提交开始，这将会花费许多不必要的时间。</p>
<p>你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 <code>.git/refs/original</code> 通过 <code>filter-branch</code> 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据库。 在重新打包前需要移除任何包含指向那些旧提交的指针的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf .git/refs/original</span><br><span class="line">$ rm -Rf .git/logs/</span><br><span class="line">$ git gc</span><br><span class="line">Counting objects: 15, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (11/11), done.</span><br><span class="line">Writing objects: 100% (15/15), done.</span><br><span class="line">Total 15 (delta 1), reused 12 (delta 0)</span><br></pre></td></tr></table></figure>

<p>让我们看看你省了多少空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git count-objects -v</span><br><span class="line">count: 11</span><br><span class="line">size: 4904</span><br><span class="line">in-pack: 15</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 8</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure>

<p>打包的仓库大小下降到了 8K，比 5MB 好很多。 可以从 size 的值看出，这个大文件还在你的松散对象中，并没有消失；但是它不会在推送或接下来的克隆中出现，这才是最重要的。 如果真的想要删除它，可以通过有 <code>--expire</code> 选项的 <code>git prune</code> 命令来完全地移除那个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git prune --expire now</span><br><span class="line">$ git count-objects -v</span><br><span class="line">count: 0</span><br><span class="line">size: 0</span><br><span class="line">in-pack: 15</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 8</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Git 总是在一个 <code>bash shell</code> 中运行，并借助一些 shell 环境变量来决定它的运行方式。 有时候，知道它们是什么以及它们如何让 Git 按照你想要的方式去运行会很有用。 这里不会列出所有的 Git 环境变量，但我们会涉及最有的那部分。</p>
<h4 id="全局行为"><a href="#全局行为" class="headerlink" title="全局行为"></a>全局行为</h4><p>像通常的程序一样，Git 的常规行为依赖于环境变量。</p>
<p><strong>GIT_EXEC_PATH</strong> 决定 Git 到哪找它的子程序 （像 <code>git-commit</code>, <code>git-diff</code> 等等）。 你可以用 <code>git --exec-path</code> 来查看当前设置。</p>
<p>通常不会考虑修改 <strong>HOME</strong> 这个变量（太多其它东西都依赖它），这是 Git 查找全局配置文件的地方。 如果你想要一个包括全局配置的真正的便携版 Git， 你可以在便携版 Git 的 shell 配置中覆盖 HOME 设置。</p>
<p><strong>PREFIX</strong> 也类似，除了用于系统级别的配置。 Git 在 <code>$PREFIX/etc/gitconfig</code> 查找此文件。</p>
<p>如果设置了 <strong>GIT_CONFIG_NOSYSTEM</strong>，就禁用系统级别的配置文件。 这在系统配置影响了你的命令，而你又无权限修改的时候很有用。</p>
<p><strong>GIT_PAGER</strong> 控制在命令行上显示多页输出的程序。 如果这个没有设置，就会用 <code>PAGER</code> 。</p>
<p><strong>GIT_EDITOR</strong> 当用户需要编辑一些文本（比如提交信息）时， Git 会启动这个编辑器。 如果没设置，就会用 <code>EDITOR</code> 。</p>
<h4 id="版本库位置"><a href="#版本库位置" class="headerlink" title="版本库位置"></a>版本库位置</h4><p>Git 用了几个变量来确定它如何与当前版本库交互。</p>
<p><strong>GIT_DIR</strong> 是 <code>.git</code> 目录的位置。 如果这个没有设置， Git 会按照目录树逐层向上查找 <code>.git</code> 目录，直到到达 <code>~</code> 或 <code>/</code>。</p>
<p><strong>GIT_CEILING_DIRECTORIES</strong> 控制查找 <code>.git</code> 目录的行为。 如果你访问加载很慢的目录（如那些磁带机上的或通过网络连接访问的），你可能会想让 Git 早点停止尝试，尤其是 shell 构建时调用了 Git 。</p>
<p><strong>GIT_WORK_TREE</strong> 是非空版本库的工作目录的根路径。 如果没指定，就使用 <code>$GIT_DIR</code> 的父目录。</p>
<p><strong>GIT_INDEX_FILE</strong> 是索引文件的路径（只有非空版本库有）。</p>
<p><strong>GIT_OBJECT_DIRECTORY</strong> 用来指定 <code>.git/objects</code> 目录的位置。</p>
<p><strong>GIT_ALTERNATE_OBJECT_DIRECTORIES</strong> 一个冒号分割的列表（格式类似 <code>/dir/one:/dir/two:…</code>）用来告诉 Git 到哪里去找不在 <code>GIT_OBJECT_DIRECTORY</code> 目录中的对象。 如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。</p>
<h4 id="路径规则"><a href="#路径规则" class="headerlink" title="路径规则"></a>路径规则</h4><p>所谓 “pathspec” 是指你在 Git 中如何指定路径，包括通配符的使用。 它们会在 <code>.gitignore</code> 文件中用到，命令行里也会用到（<code>git add *.c</code>）。</p>
<p><strong>GIT_GLOB_PATHSPECS and GIT_NOGLOB_PATHSPECS</strong> 控制通配符在路径规则中的默认行为。 如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。意思是 <code>*.c</code> 只会匹配 文件名是 <code>“*.c”</code> 的文件，而不是以 <code>.c</code> 结尾的文件。 你可以在各个路径规格中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 <code>:(glob)*.c</code> 。</p>
<p><strong>GIT_LITERAL_PATHSPECS</strong> 禁用上面的两种行为；通配符将不能用，前缀覆盖也不能用。</p>
<p><strong>GIT_ICASE_PATHSPECS</strong> 让所有的路径规格忽略大小写。</p>
<h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p>
<p><strong>GIT_AUTHOR_NAME</strong> 是 “author” 字段的可读名字。</p>
<p><strong>GIT_AUTHOR_EMAIL</strong> 是 “author” 字段的邮件。</p>
<p><strong>GIT_AUTHOR_DATE</strong> 是 “author” 字段的时间戳。</p>
<p><strong>GIT_COMMITTER_NAME</strong> 是 “committer” 字段的可读名字。</p>
<p><strong>GIT_COMMITTER_EMAIL</strong> 是 “committer” 字段的邮件。</p>
<p><strong>GIT_COMMITTER_DATE</strong> 是 “committer” 字段的时间戳。</p>
<p>如果 <code>user.email</code> 没有配置， 就会用到 <strong>EMAIL</strong> 指定的邮件地址。 如果 这个 也没有设置， Git 继续回退使用系统用户和主机名。</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>Git 使用 <code>curl</code> 库通过 HTTP 来完成网络操作， 所以 <strong>GIT_CURL_VERBOSE</strong> 告诉 Git 显示所有由那个库产生的消息。 这跟在命令行执行 <code>curl -v</code> 差不多。</p>
<p><strong>GIT_SSL_NO_VERIFY</strong> 告诉 Git 不用验证 SSL 证书。 这在有些时候是需要的， 例如你用一个自己签名的证书通过 HTTPS 来提供 Git 服务， 或者你正在搭建 Git 服务器，还没有安装完全的证书。</p>
<p>如果 Git 操作在网速低于 <strong>GIT_HTTP_LOW_SPEED_LIMIT</strong> 字节／秒，并且持续 <strong>GIT_HTTP_LOW_SPEED_TIME</strong> 秒以上的时间，Git 会终止那个操作。 这些值会覆盖 <code>http.lowSpeedLimit</code> 和 <code>http.lowSpeedTime</code> 配置的值。</p>
<p><strong>GIT_HTTP_USER_AGENT</strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。 默认值类似于 <code>git/2.0.0</code> 。</p>
<h4 id="比较和合并"><a href="#比较和合并" class="headerlink" title="比较和合并"></a>比较和合并</h4><p><strong>GIT_DIFF_OPTS</strong> 这个有点起错名字了。 有效值仅支持 <code>-u&lt;n&gt;</code> 或 <code>--unified=&lt;n&gt;</code>，用来控制在 <code>git diff</code> 命令中显示的内容行数。</p>
<p><strong>GIT_EXTERNAL_DIFF</strong> 用来覆盖 <code>diff.external</code> 配置的值。 如果设置了这个值， 当执行 <code>git diff</code> 时，Git 会调用该程序。</p>
<p><strong>GIT_DIFF_PATH_COUNTER</strong> 和 <strong>GIT_DIFF_PATH_TOTAL</strong> 对于 <code>GIT_EXTERNAL_DIFF</code> 或 <code>diff.external</code> 指定的程序有用。 前者表示在一系列文件中哪个是被比较的（从 1 开始），后者表示每批文件的总数。</p>
<p><strong>GIT_MERGE_VERBOSITY</strong> 控制递归合并策略的输出。 允许的值有下面这些：</p>
<ul>
<li><p>0 什么都不输出，除了可能会有一个错误信息。</p>
</li>
<li><p>1 只显示冲突。</p>
</li>
<li><p>2 还显示文件改变。</p>
</li>
<li><p>3 显示因为没有改变被跳过的文件。</p>
</li>
<li><p>4 显示处理的所有路径。</p>
</li>
<li><p>5 显示详细的调试信息。</p>
</li>
</ul>
<p>默认值是 2。</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>想 <strong>真正地</strong> 知道 Git 正在做什么? Git 内置了相当完整的跟踪信息，你需要做的就是把它们打开。 这些变量的可用值如下：</p>
<ul>
<li><p>“true”“1” 或 “2”——跟踪类别写到标准错误输出。</p>
</li>
<li><p>以 / 开头的绝对路径——跟踪输出会被写到那个文件。</p>
</li>
</ul>
<p><strong>GIT_TRACE</strong> 控制常规跟踪，它并不适用于特殊情况。 它跟踪的范围包括别名的展开和其他子程序的委托。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE=true git lga</span><br><span class="line">20:12:49.877982 git.c:554               trace: exec: &apos;git-lga&apos;</span><br><span class="line">20:12:49.878369 run-command.c:341       trace: run_command: &apos;git-lga&apos;</span><br><span class="line">20:12:49.879529 git.c:282               trace: alias expansion: lga =&gt; &apos;log&apos; &apos;--graph&apos; &apos;--pretty=oneline&apos; &apos;--abbrev-commit&apos; &apos;--decorate&apos; &apos;--all&apos;</span><br><span class="line">20:12:49.879885 git.c:349               trace: built-in: git &apos;log&apos; &apos;--graph&apos; &apos;--pretty=oneline&apos; &apos;--abbrev-commit&apos; &apos;--decorate&apos; &apos;--all&apos;</span><br><span class="line">20:12:49.899217 run-command.c:341       trace: run_command: &apos;less&apos;</span><br><span class="line">20:12:49.899675 run-command.c:192       trace: exec: &apos;less&apos;</span><br></pre></td></tr></table></figure>

<p><strong>GIT_TRACE_PACK_ACCESS</strong> 控制访问打包文件的跟踪信息。 第一个字段是被访问的打包文件，第二个是文件的偏移量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_PACK_ACCESS=true git status</span><br><span class="line">20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 12</span><br><span class="line">20:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 34662</span><br><span class="line">20:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175</span><br><span class="line"># […]</span><br><span class="line">20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 56914983</span><br><span class="line">20:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p><strong>GIT_TRACE_PACKET</strong> 打开网络操作包级别的跟踪信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_PACKET=true git ls-remote origin</span><br><span class="line">20:15:14.867043 pkt-line.c:46           packet:          git&lt; # service=git-upload-pack</span><br><span class="line">20:15:14.867071 pkt-line.c:46           packet:          git&lt; 0000</span><br><span class="line">20:15:14.867079 pkt-line.c:46           packet:          git&lt; 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.4</span><br><span class="line">20:15:14.867088 pkt-line.c:46           packet:          git&lt; 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name</span><br><span class="line">20:15:14.867094 pkt-line.c:46           packet:          git&lt; 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config</span><br><span class="line"># […]</span><br></pre></td></tr></table></figure>

<p><strong>GIT_TRACE_PERFORMANCE</strong> 控制性能数据的日志打印。 输出显示了每个 Git 命令调用花费的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_PERFORMANCE=true git gc</span><br><span class="line">20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: &apos;git&apos; &apos;pack-refs&apos; &apos;--all&apos; &apos;--prune&apos;</span><br><span class="line">20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: &apos;git&apos; &apos;reflog&apos; &apos;expire&apos; &apos;--all&apos;</span><br><span class="line">Counting objects: 170994, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (43413/43413), done.</span><br><span class="line">Writing objects: 100% (170994/170994), done.</span><br><span class="line">Total 170994 (delta 126176), reused 170524 (delta 125706)</span><br><span class="line">20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: &apos;git&apos; &apos;pack-objects&apos; &apos;--keep-true-parents&apos; &apos;--honor-pack-keep&apos; &apos;--non-empty&apos; &apos;--all&apos; &apos;--reflog&apos; &apos;--unpack-unreachable=2.weeks.ago&apos; &apos;--local&apos; &apos;--delta-base-offset&apos; &apos;.git/objects/pack/.tmp-49190-pack&apos;</span><br><span class="line">20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: &apos;git&apos; &apos;prune-packed&apos;</span><br><span class="line">20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: &apos;git&apos; &apos;update-server-info&apos;</span><br><span class="line">20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: &apos;git&apos; &apos;repack&apos; &apos;-d&apos; &apos;-l&apos; &apos;-A&apos; &apos;--unpack-unreachable=2.weeks.ago&apos;</span><br><span class="line">Checking connectivity: 170994, done.</span><br><span class="line">20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: &apos;git&apos; &apos;prune&apos; &apos;--expire&apos; &apos;2.weeks.ago&apos;</span><br><span class="line">20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: &apos;git&apos; &apos;rerere&apos; &apos;gc&apos;</span><br><span class="line">20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: &apos;git&apos; &apos;gc&apos;</span><br></pre></td></tr></table></figure>

<p><strong>GIT_TRACE_SETUP</strong> 显示 Git 发现的关于版本库和交互环境的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_SETUP=true git status</span><br><span class="line">20:19:47.086765 trace.c:315             setup: git_dir: .git</span><br><span class="line">20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git</span><br><span class="line">20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git</span><br><span class="line">20:19:47.087194 trace.c:318             setup: prefix: (null)</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>如果指定了 <strong>GIT_SSH</strong>， Git 连接 SSH 主机时会用指定的程序代替 <code>ssh</code> 。 它会被用 <code>$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code> 的命令方式调用。 这不是配置定制 ssh 调用方式的最简单的方法; 它不支持额外的命令行参数， 所以你必须写一个封装脚本然后让 <code>GIT_SSH</code> 指向它。 可能用 <code>~/.ssh/config</code> 会更简单。</p>
<p><strong>GIT_ASKPASS</strong> 覆盖了 <code>core.askpass</code> 配置。 这是 Git 需要向用户请求验证时用到的程序，它接受一个文本提示作为命令行参数，并在 <code>stdout</code> 中返回应答。 </p>
<p><strong>GIT_NAMESPACE</strong> 控制有命令空间的引用的访问，与 <code>--namespace</code> 标志是相同的。 这主要在服务器端有用， 如果你想在一个版本库中存储单个版本库的多个 fork, 只要保持引用是隔离的就可以。</p>
<p><strong>GIT_FLUSH</strong> 强制 Git 在向标准输出增量写入时使用没有缓存的 I/O。 设置为 1 让 Git 刷新更多， 设置为 0 则使所有的输出被缓存。 默认值（若此变量未设置）是根据活动和输出模式的不同选择合适的缓存方案。</p>
<p><strong>GIT_REFLOG_ACTION</strong> 让你可以指定描述性的文字写到 reflog 中。 这有个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_REFLOG_ACTION=&quot;my action&quot; git commit --allow-empty -m &apos;my message&apos;</span><br><span class="line">[master 9e3d55a] my message</span><br><span class="line">$ git reflog -1</span><br><span class="line">9e3d55a HEAD@&#123;0&#125;: my action: my message</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\09\Git：分布式\" rel="bookmark">Git：分布式</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\07\Git：分支\" rel="bookmark">Git：分支</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\08\Git：服务器\" rel="bookmark">Git：服务器</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\11\Git：自定义\" rel="bookmark">Git：自定义</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\2018\06\06\Git：基础\" rel="bookmark">Git：基础</a></div>
      
    </li>
  
  </ul>

        
      
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/uploads/wechatpay.png" alt="彭真进 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/uploads/alipay.png" alt="彭真进 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>彭真进</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://pengzhenjin.top/2018/06/12/Git：内部原理/" title="Git：内部原理">http://pengzhenjin.top/2018/06/12/Git：内部原理/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Git/" rel="tag"><i class="fa fa-tag"></i> Git</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2018/06/11/Git：自定义/" rel="next" title="Git：自定义">
                  <i class="fa fa-chevron-left"></i> Git：自定义
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2018/08/15/Hexo搭建个人博客（一）：基础安装/" rel="prev" title="Hexo搭建个人博客（一）：基础安装">
                  Hexo搭建个人博客（一）：基础安装 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#底层命令和高层命令"><span class="nav-number">1.</span> <span class="nav-text">底层命令和高层命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-对象"><span class="nav-number">2.</span> <span class="nav-text">Git 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树对象"><span class="nav-number">2.1.</span> <span class="nav-text">树对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提交对象"><span class="nav-number">2.2.</span> <span class="nav-text">提交对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象存储"><span class="nav-number">2.3.</span> <span class="nav-text">对象存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-引用"><span class="nav-number">3.</span> <span class="nav-text">Git 引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HEAD-引用"><span class="nav-number">3.1.</span> <span class="nav-text">HEAD 引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#远程引用"><span class="nav-number">3.2.</span> <span class="nav-text">远程引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包文件"><span class="nav-number">4.</span> <span class="nav-text">包文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用规格"><span class="nav-number">5.</span> <span class="nav-text">引用规格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用规格推送"><span class="nav-number">5.1.</span> <span class="nav-text">引用规格推送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除引用"><span class="nav-number">5.2.</span> <span class="nav-text">删除引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输协议"><span class="nav-number">6.</span> <span class="nav-text">传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哑协议"><span class="nav-number">6.1.</span> <span class="nav-text">哑协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能协议"><span class="nav-number">6.2.</span> <span class="nav-text">智能协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#上传数据"><span class="nav-number">6.2.1.</span> <span class="nav-text">上传数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#下载数据"><span class="nav-number">6.2.2.</span> <span class="nav-text">下载数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议总结"><span class="nav-number">6.3.</span> <span class="nav-text">协议总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护与数据恢复"><span class="nav-number">7.</span> <span class="nav-text">维护与数据恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#维护"><span class="nav-number">7.1.</span> <span class="nav-text">维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据恢复"><span class="nav-number">7.2.</span> <span class="nav-text">数据恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移除对象"><span class="nav-number">7.3.</span> <span class="nav-text">移除对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量"><span class="nav-number">8.</span> <span class="nav-text">环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局行为"><span class="nav-number">8.1.</span> <span class="nav-text">全局行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本库位置"><span class="nav-number">8.2.</span> <span class="nav-text">版本库位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径规则"><span class="nav-number">8.3.</span> <span class="nav-text">路径规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提交"><span class="nav-number">8.4.</span> <span class="nav-text">提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络"><span class="nav-number">8.5.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较和合并"><span class="nav-number">8.6.</span> <span class="nav-text">比较和合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试"><span class="nav-number">8.7.</span> <span class="nav-text">调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它"><span class="nav-number">8.8.</span> <span class="nav-text">其它</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/uploads/avatar.png"
      alt="彭真进">
  <p class="site-author-name" itemprop="name">彭真进</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/pengzhenjin" title="GitHub &rarr; https://github.com/pengzhenjin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:562260994@qq.com" title="E-Mail &rarr; mailto:562260994@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://hexo.io/zh-cn" title="https://hexo.io/zh-cn" rel="noopener" target="_blank">Hexo</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://theme-next.org/docs" title="https://theme-next.org/docs" rel="noopener" target="_blank">NexT</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">彭真进 版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">454k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">6:53</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a0aefd8233242f4272c5',
      clientSecret: '89cbd8c8415d03a931cdeba5a9146e38803a1ad7',
      repo: 'pengzhenjin.github.io',
      owner: 'pengzhenjin',
      admin: ['pengzhenjin'],
      id: '948910b5432ec03f4b63ef7925e5ab2e',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
