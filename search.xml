<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网站导航</title>
      <link href="/2019/08/23/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/"/>
      <url>/2019/08/23/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><div class="note default">            <p><a href="https://study.163.com" target="_blank" rel="noopener">网易云课堂</a><br><a href="https://ke.qq.com" target="_blank" rel="noopener">腾讯课堂</a><br><a href="https://edu.aliyun.com" target="_blank" rel="noopener">阿里云大学</a><br><a href="https://chuanke.baidu.com" target="_blank" rel="noopener">百度传课</a><br><a href="https://www.imooc.com" target="_blank" rel="noopener">慕课网</a><br><a href="https://edu.51cto.com" target="_blank" rel="noopener">51CTO学院</a><br><a href="https://www.jikexueyuan.com" target="_blank" rel="noopener">极客学院</a><br><a href="http://www.maiziedu.com" title="麦子学院" target="_blank" rel="noopener">麦子学院</a><br><a href="https://www.icourse163.org" target="_blank" rel="noopener">中国大学MOOC</a><br><a href="https://www.mooc.cn" target="_blank" rel="noopener">MOOC中国</a><br><a href="http://www.xuetangx.com" target="_blank" rel="noopener">学堂在线</a><br><a href="http://www.duobei.com" target="_blank" rel="noopener">多贝公开课</a><br><a href="https://cn.udacity.com" target="_blank" rel="noopener">优达学城</a><br><a href="https://www.udemy.com" target="_blank" rel="noopener">Udemy</a><br><a href="https://www.coursera.org" target="_blank" rel="noopener">coursera</a>                                                               </p>          </div> <a id="more"></a> <h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><p><a href="http://www.atoolbox.net" target="_blank" rel="noopener">在线工具 —— 好用的在线工具都在这里</a><br><a href="https://www.qtool.net" target="_blank" rel="noopener">在线工具 —— QTOOL工具大家常用的工具箱</a><br><a href="https://www.iamwawa.cn" target="_blank" rel="noopener">在线工具 —— 蛙蛙便捷的在线工具集合网站</a><br><a href="http://www.nicetool.net" target="_blank" rel="noopener">在线工具 —— NiceTool用完即走，触手可及</a><br><a href="http://www.qijishow.com/down/index.html" target="_blank" rel="noopener">在线工具 —— 奇迹秀工具箱</a><br><a href="https://tools.imiku.me" target="_blank" rel="noopener">在线工具 —— MikuTools一个轻量的工具集合</a><br><a href="http://tools.jb51.net" target="_blank" rel="noopener">在线工具 —— 脚本之家在线工具</a><br><a href="https://tool.lu" target="_blank" rel="noopener">在线工具 —— 程序员的工具箱</a><br><a href="https://www.toolfk.com" target="_blank" rel="noopener">在线工具 —— ToolFK程序员开发工具大全</a></p><h3 id="IT-技术"><a href="#IT-技术" class="headerlink" title="IT 技术"></a>IT 技术</h3><div class="note default">            <h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git Book</a>（中文版）<br><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git 教程</a></p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p><a href="https://developer.android.google.cn" target="_blank" rel="noopener">Android Developers</a>（中文版）<br><a href="应用开发者文档">Android 应用开发者文档</a><br><a href="https://chinagdg.org/resource-list" target="_blank" rel="noopener">Android 技术资源汇总</a><br><a href="https://www.androidos.net.cn/sourcecode" target="_blank" rel="noopener">Android OS 在线源码</a><br><a href="https://www.mdui.org/design" target="_blank" rel="noopener">Material Design 设计</a>（中文版）</p><h5 id="Android-架构"><a href="#Android-架构" class="headerlink" title="Android 架构"></a>Android 架构</h5><p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Google 官方架构 Samples</a><br><a href="https://github.com/Juude/Awesome-Android-Architecture" target="_blank" rel="noopener">Android 架构集合</a><br><a href="https://www.jianshu.com/p/2d5c1d855c31" target="_blank" rel="noopener">Android APP 架构心得</a></p><h5 id="Android-技术博客"><a href="#Android-技术博客" class="headerlink" title="Android 技术博客"></a>Android 技术博客</h5><p><a href="https://www.cmonbaby.com" target="_blank" rel="noopener">彭锡</a> —— GitHub：<a href="https://github.com/cnmen" target="_blank" rel="noopener">https://github.com/cnmen</a><br><a href="https://xiandan.in" target="_blank" rel="noopener">闲蛋</a> —— GitHub：<a href="https://github.com/dengyuhan" target="_blank" rel="noopener">https://github.com/dengyuhan</a><br><a href="https://www.trinea.cn" target="_blank" rel="noopener">Trinea</a> —— GitHub：<a href="https://github.com/trinea" target="_blank" rel="noopener">https://github.com/trinea</a><br><a href="https://www.cnblogs.com/halzhang" target="_blank" rel="noopener">张汉国</a> —— GitHub：<a href="https://github.com/halzhang" target="_blank" rel="noopener">https://github.com/halzhang</a><br><a href="https://my.oschina.net/u/1171837" target="_blank" rel="noopener">wyouflf</a> —— GitHub：<a href="https://github.com/wyouflf" target="_blank" rel="noopener">https://github.com/wyouflf</a><br><a href="https://blog.daimajia.com" target="_blank" rel="noopener">代码家</a> —— GitHub：<a href="https://github.com/daimajia" target="_blank" rel="noopener">https://github.com/daimajia</a><br><a href="https://stormzhang.com" target="_blank" rel="noopener">stormzhang</a> —— GitHub：<a href="https://github.com/stormzhang" target="_blank" rel="noopener">https://github.com/stormzhang</a><br><a href="https://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">张鸿洋</a> —— GitHub：<a href="https://github.com/hongyangAndroid" target="_blank" rel="noopener">https://github.com/hongyangAndroid</a><br><a href="https://blog.csdn.net/singwhatiwanna" target="_blank" rel="noopener">任玉刚</a> —— GitHub：<a href="https://github.com/singwhatiwanna" target="_blank" rel="noopener">https://github.com/singwhatiwanna</a><br><a href="https://over140.cnblogs.com" target="_blank" rel="noopener">农民伯伯</a> —— GitHub：<a href="https://github.com/over140" target="_blank" rel="noopener">https://github.com/over140</a><br><a href="https://pedant.cn" target="_blank" rel="noopener">书呆子</a> —— GitHub：<a href="https://github.com/pedant" target="_blank" rel="noopener">https://github.com/pedant</a><br><a href="https://blog.csdn.net/lzyzsd" target="_blank" rel="noopener">大头鬼</a> —— GitHub：<a href="https://github.com/lzyzsd" target="_blank" rel="noopener">https://github.com/lzyzsd</a><br><a href="http://blog.zhaiyifan.cn" target="_blank" rel="noopener">markzhai</a> —— GitHub：<a href="https://github.com/markzhai" target="_blank" rel="noopener">https://github.com/markzhai</a></p><h5 id="Android-社区"><a href="#Android-社区" class="headerlink" title="Android 社区"></a>Android 社区</h5><p><a href="https://www.wanandroid.com" target="_blank" rel="noopener">玩安卓</a><br><a href="https://stackoverflow.com" target="_blank" rel="noopener">Stack OverFlow</a><br><a href="https://segmentfault.com/t/android" target="_blank" rel="noopener">SegmentFault</a><br><a href="https://juejin.im/welcome/android" target="_blank" rel="noopener">稀土掘金</a><br><a href="https://chinagdg.org" target="_blank" rel="noopener">谷歌开发者社区</a><br><a href="http://www.android-studio.org" target="_blank" rel="noopener">Android Studio 中文社区</a></p><h5 id="Android-面试"><a href="#Android-面试" class="headerlink" title="Android 面试"></a>Android 面试</h5><p><a href="https://github.com/stormzhang/android-interview-questions-cn" target="_blank" rel="noopener">Android 面试指南</a><br><a href="https://www.jianshu.com/p/d1efe2f31b6d" target="_blank" rel="noopener">Android 面试资料集合</a></p><h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content" target="_blank" rel="noopener">RxJava 文档</a>（中文版）</p><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p><a href="https://flutterchina.club" target="_blank" rel="noopener">Flutter 中文网</a><br><a href="https://book.flutterchina.club" target="_blank" rel="noopener">Flutter 实战</a></p><h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">Hexo 文档</a>（中文版）<br><a href="https://theme-next.org/docs" target="_blank" rel="noopener">Next Theme 文档</a></p><h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">Markdown 教程</a></p>          </div> <h3 id="招聘网站"><a href="#招聘网站" class="headerlink" title="招聘网站"></a>招聘网站</h3><div class="note default">            <p><a href="https://www.lagou.com" target="_blank" rel="noopener">拉钩网</a><br><a href="https://www.zhipin.com" target="_blank" rel="noopener">BOSS直聘</a><br><a href="https://www.zhipin.com" target="_blank" rel="noopener">猎聘网</a><br><a href="https://cn.100offer.com" target="_blank" rel="noopener">100offer</a><br><a href="https://www.neitui.me" target="_blank" rel="noopener">内推</a></p>          </div> ]]></content>
      
      
      <categories>
          
          <category> 网站导航 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线学习 </tag>
            
            <tag> 在线课堂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java队列详解</title>
      <link href="/2018/10/18/Java%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/18/Java%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="队列简述"><a href="#队列简述" class="headerlink" title="队列简述"></a>队列简述</h3><p>Queue：基本上，一个队列就是一个先入先出（FIFO）的数据结构。</p><p>Queue 接口与 List、Set 同一级别，都是继承了 Collection 接口。LinkedList 实现了 Deque接口。</p><p>在并发队列上 JDK 提供了两套实现，一个是以 ConcurrentLinkedQueue 为代表的高性能队列非阻塞，一个是以 BlockingQueue 接口为代表的阻塞队列，无论哪种都继承自 Queue 接口。</p><a id="more"></a><h3 id="阻塞队列与非阻塞队列"><a href="#阻塞队列与非阻塞队列" class="headerlink" title="阻塞队列与非阻塞队列"></a>阻塞队列与非阻塞队列</h3><p>阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列。</p><p><img src="queue-chapter/img1.png" alt></p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>没有实现的阻塞接口的 LinkedList：实现了 java.util.Queue 接口 和 java.util.AbstractQueue 接口。</p><p>内置的不阻塞队列：PriorityQueue 和 ConcurrentLinkedQueue。</p><p>PriorityQueue 和 ConcurrentLinkedQueue 类在 Collection Framework 中加入两个具体集合实现。</p><p>PriorityQueue 类实质上维护了一个有序列表。加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable 实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。</p><p>ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大小，ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。</p><p>ConcurrentLinkedQueue：是一个适用于高并发场景下的队列，通过无锁的方式，实现<br>了高并发状态下的高性能，通常 ConcurrentLinkedQueue 性能好于 BlockingQueue。它<br>是一个基于链接节点的无界线程安全队列，该队列的元素遵循先进先出的原则，头是最先<br>加入的，尾是最近加入的，该队列不允许 null 元素。</p><p>ConcurrentLinkedQueue 的重要方法:<br>add() 和 offer() 都是加入元素的方法（在 ConcurrentLinkedQueue 中这俩个方法没有任何区别）。<br>poll() 和 peek() 都是取头元素节点，区别在于前者会删除元素，后者不会。</p><p>ConcurrentLinkedQueue 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;test-clq&quot;)</span><br><span class="line">public void testConcurrentLinkedQueue() &#123;</span><br><span class="line">    ConcurrentLinkedDeque&lt;String&gt; q = new ConcurrentLinkedDeque&lt;&gt;();</span><br><span class="line">    q.offer(&quot;Java&quot;);</span><br><span class="line">    q.offer(&quot;C#&quot;);</span><br><span class="line">    q.offer(&quot;Javascript&quot;);</span><br><span class="line">    q.offer(&quot;Python&quot;);</span><br><span class="line"></span><br><span class="line">    // 从头获取元素,删除该元素</span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line"></span><br><span class="line">    // 从头获取元素,不刪除该元素</span><br><span class="line">    System.out.println(q.peek());</span><br><span class="line"></span><br><span class="line">    // 获取总长度</span><br><span class="line">    System.out.println(q.size());</span><br><span class="line"></span><br><span class="line">    // 遍历</span><br><span class="line">    for (String s : q) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line">C#</span><br><span class="line">3</span><br><span class="line">C#</span><br><span class="line">Javascript</span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h3><p>阻塞队列，即：BlockingQueue，首先它是一个队列，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出。<br>常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue 就是其中的一种）</p><ol><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。</li><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。</li></ol><p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的 concurrent 包横空出世了，而他也给我们带来了强大的 BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）</p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p><ol><li>在队列为空时，获取元素的线程会等待队列变为非空。</li><li>当队列满时，存储元素的线程会等待队列可用。 </li></ol><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>BlockingQueue 队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</p><ol><li>当队列满了的时候进行入队列操作。</li><li>当队列空了的时候进行出队列操作。</li></ol><p>因此，当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作。同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。</p><p>在 Java 中，BlockingQueue 的接口位于 java.util.concurrent 包中（在 Java 5 版本开始提供），由上面介绍的阻塞队列的特性可知，阻塞队列是线程安全的。<br>在新增的 java.util.concurrent 包中，BlockingQueue 很好的解决了多线程中如何高效安全“传输”数据的问题，通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。</p><p>下表显示了 jdk 1.5 中的阻塞队列的操作：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>add</td><td>增加一个元索，如果队列已满，则抛出一个 IIIegaISlabEepeplian 异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素，如果队列为空，则抛出一个 NoSuchElementException 异常</td></tr><tr><td>element</td><td>返回队列头部的元素，如果队列为空，则抛出一个 NoSuchElementException 异常</td></tr><tr><td>offer</td><td>添加一个元素并返回 true，如果队列已满，则返回 false</td></tr><tr><td>poll</td><td>移除并返问队列头部的元素，如果队列为空，则返回 null</td></tr><tr><td>peek</td><td>返回队列头部的元素，如果队列为空，则返回 null</td></tr><tr><td>put</td><td>添加一个元素，如果队列满，则阻塞</td></tr><tr><td>take</td><td>移除并返回队列头部的元素，如果队列为空，则阻塞</td></tr></tbody></table><p><strong>ArrayBlockingQueue</strong><br>ArrayBlockingQueue 是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。<br>ArrayBlockingQueue 是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</p><p><strong>LinkedBlockingQueue</strong><br>LinkedBlockingQueue 阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为 Integer.MAX_VALUE 的容量，它的内部实现是一个链表。<br>和 ArrayBlockingQueue 一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</p><p><strong>PriorityBlockingQueue</strong><br>PriorityBlockingQueue 是一个没有边界的队列，它的排序规则和 java.util.PriorityQueue 一样。需要注意：PriorityBlockingQueue 中允许插入 null 对象。<br>所有插入 PriorityBlockingQueue 的对象必须实现 java.lang.Comparable 接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。<br>另外，我们可以从 PriorityBlockingQueue 获得一个迭代器 Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。</p><p><strong>SynchronousQueue</strong><br>SynchronousQueue 队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</p><p><strong>DelayQueue</strong><br>DelayQueue（基于 PriorityQueue 来实现的）是一个存放 Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll 就以移除这个元素了，此队列不允许使用 null 元素。</p><p>一个例子，使用 BlockingQueue 模拟生产者与消费者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 生产者</span><br><span class="line">public class ProducerThread implements Runnable &#123;</span><br><span class="line">    private BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    private AtomicInteger count = new AtomicInteger();</span><br><span class="line">    private volatile boolean FLAG = true;</span><br><span class="line"></span><br><span class="line">    public ProducerThread(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;生产者开始启动....&quot;);</span><br><span class="line">        while (FLAG) &#123;</span><br><span class="line">            String data = count.incrementAndGet() + &quot;&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean offer = queue.offer(data, 2, TimeUnit.SECONDS);</span><br><span class="line">                if (offer) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;,生产队列&quot; + data + &quot;成功..&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;,生产队列&quot; + data + &quot;失败..&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;,生产者线程停止...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        this.FLAG = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 消费者</span><br><span class="line">public class ConsumerThread implements Runnable &#123;</span><br><span class="line">    private volatile boolean FLAG = true;</span><br><span class="line">    private BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    public ConsumerThread(BlockingQueue&lt;String&gt; blockingQueue) &#123;</span><br><span class="line">        this.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;消费者开始启动....&quot;);</span><br><span class="line">        while (FLAG) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String data = blockingQueue.poll(2, TimeUnit.SECONDS);</span><br><span class="line">                if (data == null || data == &quot;&quot;) &#123;</span><br><span class="line">                    FLAG = false;</span><br><span class="line">                    System.out.println(&quot;消费者超过2秒时间未获取到消息.&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;消费者获取到队列信息成功,data:&quot; + data);</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 测试</span><br><span class="line">@RequestMapping(&quot;test-blockingQueue&quot;)</span><br><span class="line">public void testBlockingQueue() &#123;</span><br><span class="line">    LinkedBlockingDeque&lt;String&gt; blockingDeque = new LinkedBlockingDeque&lt;&gt;(1);</span><br><span class="line">    ProducerThread producerThread = new ProducerThread(blockingDeque);</span><br><span class="line">    ConsumerThread consumerThread = new ConsumerThread(blockingDeque);</span><br><span class="line">    Thread t1 = new Thread(producerThread, &quot;生产者&quot;);</span><br><span class="line">    Thread t2 = new Thread(consumerThread, &quot;消费者&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    // 10秒后停止线程</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(10 * 1000);</span><br><span class="line">        producerThread.stop();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line"></span><br><span class="line">消费者消费者开始启动....</span><br><span class="line">生产者生产者开始启动....</span><br><span class="line">生产者,生产队列1成功..</span><br><span class="line">消费者获取到队列信息成功,data:1</span><br><span class="line">生产者,生产队列2成功..</span><br><span class="line">消费者获取到队列信息成功,data:2</span><br><span class="line">生产者,生产队列3成功..</span><br><span class="line">消费者获取到队列信息成功,data:3</span><br><span class="line">生产者,生产队列4成功..</span><br><span class="line">消费者获取到队列信息成功,data:4</span><br><span class="line">生产者,生产队列5成功..</span><br><span class="line">消费者获取到队列信息成功,data:5</span><br><span class="line">生产者,生产队列6成功..</span><br><span class="line">消费者获取到队列信息成功,data:6</span><br><span class="line">生产者,生产队列7成功..</span><br><span class="line">消费者获取到队列信息成功,data:7</span><br><span class="line">生产者,生产队列8成功..</span><br><span class="line">消费者获取到队列信息成功,data:8</span><br><span class="line">生产者,生产队列9成功..</span><br><span class="line">消费者获取到队列信息成功,data:9</span><br><span class="line">生产者,生产队列10成功..</span><br><span class="line">消费者获取到队列信息成功,data:10</span><br><span class="line">生产者,生产者线程停止...</span><br><span class="line">消费者超过2秒时间未获取到消息.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> queue </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的实现原理</title>
      <link href="/2018/10/16/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/16/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-中的-hashCode-和-equals"><a href="#Java-中的-hashCode-和-equals" class="headerlink" title="Java 中的 hashCode 和 equals"></a>Java 中的 hashCode 和 equals</h3><h4 id="关于-hashCode"><a href="#关于-hashCode" class="headerlink" title="关于 hashCode"></a>关于 hashCode</h4><ol><li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，hashCode 是用来在散列存储结构中确定对象的存储地址的。</li><li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同。</li><li>如果对象的 equals 方法被重写，那么对象的 hashCode 也尽量重写，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，否则就会违反上面提到的第 2 点。</li><li>两个对象的 hashCode 相同，并不一定表示两个对象就相同，也就是不一定适用于 equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如 Hashtable，他们“存放在同一个篮子里“。</li></ol><a id="more"></a><p>对 hashCode 的解读：</p><div class="note default">            <ol><li>hashcode 是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0  1  2  3  4  5  6  7<br>而我有个类，这个类有个字段叫 ID，我要把这个类存放在以上 8 个位置之一，如果不用 hashcode 而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用 hashcode 那就会使效率提高很多。<br>我们这个类中有个字段叫 ID，那么我们就定义我们的 hashcode 为 ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的 ID 为 9，9 除 8 的余数为 1，那么我们就把该类存在 1 这个位置，如果 ID 是 13，求得的余数是 5，那么我们就把该类放在 5 这个位置。这样，以后在查找该类时就可以通过 ID 除 8 求余数直接找到存放的位置了。</li></ol><ol start="2"><li>但是如果两个类有相同的 hashcode 怎么办那（我们假设上面的类的 ID 不是唯一的），例如 9 除以 8 和 17 除以 8 的余数都是 1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals 了。<br>也就是说，我们先通过 hashcode 来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么，重写了 equals()，为什么还要重写 hashCode() 呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写 hashcode() 来找到桶，光重写 equals() 有什么用啊。</li></ol>          </div><h4 id="关于-equals"><a href="#关于-equals" class="headerlink" title="关于 equals"></a>关于 equals</h4><ol><li><p>equals 和 ==<br>== 用于比较引用和比较基本数据类型时具有不同的功能。比较基本数据类型，如果两个值相同，则结果为 true，而在比较引用时，如果引用指向内存中的同一对象，结果为 true。<br>equals() 作为方法，实现对象的比较。由于 == 运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写 equals() 方法，达到比较对象内容是否相同的目的。而这些通过 == 运算符是做不到的。</p></li><li><p>object 类的 equals() 方法的比较规则为：如果两个对象的类型一致，并且内容一致，则返回 true，这些类有：java.io.file，java.util.Date，java.lang.string，包装类（Integer，Double等）。<br>String s1=new String(“abc”);<br>String s2=new String(“abc”);<br>System.out.println(s1==s2);<br>System.out.println(s1.equals(s2));<br>运行结果为：false、true</p></li></ol><h3 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h3><h4 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h4><p>HashMap 是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p> 在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap 也不例外。HashMap 实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><img src="hashmap-chapter/img1.png" alt></p><p>从上图中可以看出，HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。</p><p>其中 Java 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> */</span><br><span class="line">transient Entry[] table;</span><br><span class="line"></span><br><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    final int hash;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Entry 就是数组中的元素，每个 Map.Entry 其实就是一个 key-value 对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h4 id="HashMap-实现存储和读取"><a href="#HashMap-实现存储和读取" class="headerlink" title="HashMap 实现存储和读取"></a>HashMap 实现存储和读取</h4><p><strong>1、存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // HashMap允许存放null键和null值。</span><br><span class="line">    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。</span><br><span class="line">    if (key == null) &#123;</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据key的keyCode重新计算hash值。</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line"></span><br><span class="line">    // 搜索指定hash值在对应table中的索引。</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            // 如果发现已有该键值，则存储新的值，并返回原始值</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果i索引处的Entry为null，表明此处还没有Entry。</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // 将key、value添加到i索引处。</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p><p>hash(int h) 方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int hash(int h) &#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在 HashMap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p><p>根据上面 put 方法的源代码可以看出，当程序试图将一个 key-value 对放入 HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但 key 不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p><p>通过这种方式就可以高效的解决 HashMap 的冲突问题。</p><p><strong>2、读取</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key == null) &#123;</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 HashMap 中 get 元素时，首先计算 key 的 hashCode，找到数组中对应位置的某一元素，然后通过 key 的 equals 方法在对应位置的链表中找到需要的元素。</p><p><strong>3、归纳</strong><br>HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据 hash 算法来决定其在数组中的存储位置，在根据 equals 方法决定其在该数组位置上的链表中的存储位置；当需要取出一个 Entry 时，也会根据 hash 算法找到其在数组中的存储位置，再根据 equals 方法从该位置上的链表中取出该 Entry。</p><h4 id="HashMap-的-resize"><a href="#HashMap-的-resize" class="headerlink" title="HashMap 的 resize"></a>HashMap 的 resize</h4><p>当 hashmap 中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在 ArrayList 中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在 hashmap 数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize。</p><p>那么 hashmap 什么时候进行扩容呢？当 hashmap 中的元素个数超过数组大小 * loadFactor 时，就会进行数组扩容，loadFactor 的默认值为 0.75，也就是说，默认情况下，数组大小为 16，那么当 hashmap 中元素个数超过 16<em>0.75=12 的时候，就把数组的大小扩展为 2</em>16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够有效的提高 hashmap 的性能。比如说，我们有 1000 个元素 new HashMap(1000), 但是理论上来讲 new HashMap(1024) 更合适，不过上面 annegu 已经说过，即使是 1000，hashmap 也自动会将其设置为 1024。 但是 new HashMap(1024) 还不是更合适的，因为 0.75*1000 &lt; 1000, 也就是说为了让 0.75 * size &gt; 1000, 我们必须这样 new HashMap(2048) 才最合适，既考虑了&amp;的问题，也避免了 resize 的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashMap的实现原理：</p><ol><li><p>利用 key 的 hashCode 重新 hash 计算出当前对象的元素在数组中的下标。</p></li><li><p>存储时，如果出现 hash 值相同的 key，此时有两种情况：<br>(1). 如果 key 相同，则覆盖原始值。<br>(2). 如果 key 不同（出现冲突），则将当前的 key-value 放入链表中。</p></li><li><p>获取时，直接找到 hash 值对应的下标，在进一步判断 key 是否相同，从而找到对应值。</p></li><li><p>理解了以上过程就不难明白 HashMap 是如何解决 hash 冲突的问题，核心就是使用了数组的存储方式，然后将冲突的 key 的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程详解</title>
      <link href="/2018/10/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>线程对象是可以产生线程的对象。比如在 Java 平台中 Thread 对象 、Runnable 对象。线程，是指正在执行的一个指点令序列。在 Java 平台上是指从一个线程对象的 start() 方法开始，运行 run() 方法体中的那一段相对独立的过程。相比于多进程，多线程的优势有：</p><ol><li>进程之间不能共享数据，线程可以；</li><li>系统创建进程需要为该进程重新分配系统资源，故创建线程代价比较小；</li><li>Java 语言内置了多线程功能支持，简化了 Java 多线程编程。</li></ol><a id="more"></a><h3 id="创建线程和启动"><a href="#创建线程和启动" class="headerlink" title="创建线程和启动"></a>创建线程和启动</h3><h4 id="继承-Thread-类创建线程类"><a href="#继承-Thread-类创建线程类" class="headerlink" title="继承 Thread 类创建线程类"></a>继承 Thread 类创建线程类</h4><p>通过继承 Thread 类创建线程类的具体步骤和具体代码如下：</p><ul><li>定义一个继承 Thread 类的子类，并重写该类的 run() 方法。</li><li>创建 Thread 子类的实例，即创建了线程对象。</li><li>调用该线程对象的 start() 方法启动线程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SomeThead extends Thraad &#123; </span><br><span class="line">    public void run()   &#123; </span><br><span class="line">     // do something here  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SomeThread oneThread = new SomeThread();   </span><br><span class="line">    </span><br><span class="line">    // 步骤3：启动线程：   </span><br><span class="line">    oneThread.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-Runnable-接口创建线程类"><a href="#实现-Runnable-接口创建线程类" class="headerlink" title="实现 Runnable 接口创建线程类"></a>实现 Runnable 接口创建线程类</h4><p>通过实现 Runnable 接口创建线程类的具体步骤和具体代码如下：</p><ul><li>定义 Runnable 接口的实现类，并重写该接口的 run() 方法。</li><li>创建 Runnable 实现类的实例，并以此实例作为 Thread 的 target 对象，即该 Thread 对象才是真正的线程对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SomeRunnable implements Runnable &#123; </span><br><span class="line">    public void run() &#123; </span><br><span class="line">    // do something here  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable oneRunnable = new SomeRunnable();   </span><br><span class="line">Thread oneThread = new Thread(oneRunnable);   </span><br><span class="line">oneThread.start();</span><br></pre></td></tr></table></figure><h4 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h4><p>通过 Callable 和 Future 创建线程的具体步骤和具体代码如下：</p><ul><li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值其中，Callable 接口(也只有一个方法)定义如下： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable &#123; </span><br><span class="line">  V call() throws Exception;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 步骤1：创建实现 Callable 接口的类 SomeCallable (略);  </span><br><span class="line"> </span><br><span class="line">// 步骤2：创建一个类对象： </span><br><span class="line">    Callable oneCallable = new SomeCallable(); </span><br><span class="line"></span><br><span class="line">// 步骤3：由 Callable 创建一个 FutureTask 对象：   </span><br><span class="line">    FutureTask oneTask = new FutureTask(oneCallable); </span><br><span class="line"></span><br><span class="line">// 注释： FutureTask 是一个包装器，它通过接受 Callable 来创建，它同时实现了 Future 和 Runnable 接口。 </span><br><span class="line">// 步骤4：由 FutureTask 创建一个 Thread 对象：   </span><br><span class="line">    Thread oneThread = new Thread(oneTask);   </span><br><span class="line">  </span><br><span class="line">// 步骤5：启动线程：  </span><br><span class="line">    oneThread.start();</span><br></pre></td></tr></table></figure><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="thread-chapter/img1.png" alt></p><h4 id="新建状态"><a href="#新建状态" class="headerlink" title="新建状态"></a>新建状态</h4><p>用 new 关键字 和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用 start() 方法进入就绪状态（runnable）。</p><p><strong>注意：</strong>不能对已经启动的线程再次调用 start() 方法，否则会出现 Java.lang.IllegalThreadStateException 异常。</p><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>处于就绪状态的线程已经具备了运行条件，但还没有分配到 CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为 CPU 的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配 CPU 。等待状态并不是执行状态，当系统选定一个等待执行的 Thread 对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“CPU调度”。一旦获得 CPU，线程就进入运行状态并自动调用自己的 run() 方法。</p><p>提示：如果希望子线程调用 start() 方法后立即执行，可以使用 Thread.sleep() 方式使主线程睡眠一会儿，转去执行子线程。</p><h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p>处于就绪状态的线程，如果获得了 CPU 的调度，就会从就绪状态变为运行状态，执行 run() 方法中的任务。如果该线程失去了 CPU 资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用 yield() 方法，它就会让出 CPU 资源，再次变为就绪状态。</p><p>当发生如下情况是，线程会从运行状态变为阻塞状态：</p><ol><li>线程调用 sleep() 方法主动放弃所占用的系统资源。</li><li>线程调用一个阻塞式 IO 方法，在该方法返回之前，该线程被阻塞。</li><li>线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有。</li><li>线程在等待某个通知（notify）。</li><li>程序调用了线程的 suspend() 方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。</li></ol><p>当线程的 run() 方法执行完，或者被强制性地终止，例如出现异常，或者调用了 stop() 、desyory() 方法等等，就会从运行状态转变为死亡状态。</p><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><p>处于运行状态的线程在某些情况下，如执行了 sleep() 方法，或等待 I/O 设备等资源，将让出 CPU 并暂时停止自己的运行，进入阻塞状态。 </p><p>在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的 I/O 设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败（因为同步锁被其他线程占用）。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul><h4 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h4><p>当线程的 run() 方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用 start() 方法，会抛出 java.lang.IllegalThreadStateException 异常。</p><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>Java 提供了一些便捷的方法用于会线程状态的控制。具体如下：</p><h4 id="线程睡眠-——-sleep"><a href="#线程睡眠-——-sleep" class="headerlink" title="线程睡眠 —— sleep"></a>线程睡眠 —— sleep</h4><p>如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用 Thread 的 sleep() 方法。</p><p><strong>注意：</strong></p><ol><li><p>sleep() 是静态方法，最好不要用 Thread 的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread=new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程  </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for (int i=0;i&lt;100;i++) &#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java 线程调度是 Java 多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用 sleep() 方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用 Thread.sleep(1000) 使得线程睡眠 1 秒，可能结果会大于 1 秒。</p></li></ol><h4 id="线程让步-——-yield"><a href="#线程让步-——-yield" class="headerlink" title="线程让步 —— yield"></a>线程让步 —— yield</h4><p>yield() 方法 和 sleep() 方法有点相似，它也是 Thread 类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出 CPU 资源给其他的线程。但是和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用 yield() 方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p><p>实际上，当某个线程调用了 yield() 方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉 CPU 调度线程。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name); // 设置线程的名称  </span><br><span class="line">        this.setPriority(pro); // 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 == 0) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 sleep() 方法和 yield() 方的区别如下：</p><ol><li>sleep() 方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而 yield() 方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。</li><li>sleep() 方法声明抛出了 InterruptedException ，所以调用 sleep() 方法的时候要捕获该异常，或者显示声明抛出该异常。而 yield() 方法则没有声明抛出任务异常。</li><li>sleep() 方法比 yield() 方法有更好的可移植性，通常不要依靠 yield() 方法来控制并发线程的执行。</li></ol><h4 id="线程合并-——-join"><a href="#线程合并-——-join" class="headerlink" title="线程合并 —— join"></a>线程合并 —— join</h4><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread 类提供了 join() 方法来完成这个功能，注意，它不是静态方法。</p><p>它有3个重载的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程等该加入该线程后面，等待该线程终止。</span><br><span class="line">void join()</span><br><span class="line"></span><br><span class="line">// 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在 millis 时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待 CPU 调度  </span><br><span class="line">void join(long millis)</span><br><span class="line"></span><br><span class="line">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在 millis 时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待 CPU 调度  </span><br><span class="line">void join(long millis,int nanos)</span><br></pre></td></tr></table></figure><h4 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h4><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取 CPU 资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main 线程具有普通优先级。</p><p>Thread 类提供了 setPriority(int newPriority) 和 getPriority() 方法来设置和返回一个指定线程的优先级，其中 setPriority(int newPriority) 方法的参数是一个整数，范围是 1~·0 之间，也可以使用 Thread 类提供的三个静态常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   = 10</span><br><span class="line"></span><br><span class="line">MIN_PRIORITY   = 1</span><br><span class="line"></span><br><span class="line">NORM_PRIORITY  = 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name,int pro) &#123;  </span><br><span class="line">        super(name); // 设置线程的名称  </span><br><span class="line">        setPriority(pro); // 设置线程的优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">        </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>虽然 Java 提供了 10 个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和 Java 的 10 个优先级别对应。所以我们应该使用 MAX_PRIORITY 、 MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p><h4 id="后台（守护）线程"><a href="#后台（守护）线程" class="headerlink" title="后台（守护）线程"></a>后台（守护）线程</h4><p>守护线程使用的情况较少，但并非无用，举例来说，JVM 的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法 setDaemon(true) ，则可以将其设置为守护线程。守护线程的用途为：</p><ul><li>守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</li><li>Java 的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</li></ul><p>setDaemon 方法的详细说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line">// 该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。</span><br><span class="line">// 参数：on 如果为 true，则将该线程标记为守护线程。</span><br><span class="line">// 如果该线程处于活动状态，抛出 IllegalThreadStateException异常。 如果当前线程无法修改该线程，抛出 SecurityException 异常。</span><br><span class="line">public final void setDaemon(boolean on)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>JRE 判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程的时候一定要注意这个问题。</p><h4 id="正确结束线程"><a href="#正确结束线程" class="headerlink" title="正确结束线程"></a>正确结束线程</h4><p>Thread.stop() 、Thread.suspend 、Thread.resume 、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的，想要安全有效的结束一个线程，可以使用下面的方法：</p><ul><li>正常执行完 run() 方法，然后结束掉。</li><li>控制循环条件和判断条件的标识符来结束掉线程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i=0;  </span><br><span class="line">    boolean next=true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i==10) &#123;</span><br><span class="line">                next=false;</span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>Java 允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如：数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>即用 synchronized 关键字修饰的方法。由于 Java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void save()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>synchronized 关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>即用 synchronized 关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Bank &#123;  </span><br><span class="line">     </span><br><span class="line">    private int count =0; // 账户余额  </span><br><span class="line"> </span><br><span class="line">    // 存钱  </span><br><span class="line">    public void addMoney(int money) &#123;  </span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;  </span><br><span class="line">            count +=money;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 取钱  </span><br><span class="line">    public void subMoney(int money) &#123;  </span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;  </span><br><span class="line">            if(count-money &lt; 0) &#123;  </span><br><span class="line">                System.out.println(&quot;余额不足&quot;);  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            count -=money;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        System.out.println(+System.currentTimeMillis()+&quot;取出：&quot;+money);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 查询  </span><br><span class="line">    public void lookMoney() &#123;  </span><br><span class="line">        System.out.println(&quot;账户余额：&quot;+count);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用 synchronized 代码块同步关键代码即可。</p><h4 id="使用特殊域变量-volatile-实现线程同步"><a href="#使用特殊域变量-volatile-实现线程同步" class="headerlink" title="使用特殊域变量(volatile)实现线程同步"></a>使用特殊域变量(volatile)实现线程同步</h4><ul><li>volatile关键字为域变量的访问提供了一种免锁机制。</li><li>使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新。</li><li>因此每次使用该域就要重新计算，而不是使用寄存器中的值。</li><li>volatile不会提供任何原子操作，它也不能用来修饰 final 类型的变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedThread &#123;</span><br><span class="line"> </span><br><span class="line">    class Bank &#123;</span><br><span class="line"></span><br><span class="line">        private volatile int account = 100;</span><br><span class="line"></span><br><span class="line">        public int getAccount() &#123;</span><br><span class="line">            return account;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 用同步方法实现</span><br><span class="line">         * </span><br><span class="line">         * @param money</span><br><span class="line">         */</span><br><span class="line">        public synchronized void save(int money) &#123;</span><br><span class="line">            account += money;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 用同步代码块实现</span><br><span class="line">         * </span><br><span class="line">         * @param money</span><br><span class="line">         */</span><br><span class="line">        public void save1(int money) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                account += money;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class NewThread implements Runnable &#123;</span><br><span class="line">        private Bank bank;</span><br><span class="line"></span><br><span class="line">        public NewThread(Bank bank) &#123;</span><br><span class="line">            this.bank = bank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                // bank.save1(10);</span><br><span class="line">                bank.save(10);</span><br><span class="line">                System.out.println(i + &quot;账户余额为：&quot; +bank.getAccount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 建立线程，调用内部类</span><br><span class="line">     */</span><br><span class="line">    public void useThread() &#123;</span><br><span class="line">        Bank bank = new Bank();</span><br><span class="line">        NewThread new_thread = new NewThread(bank);</span><br><span class="line">        System.out.println(&quot;线程1&quot;);</span><br><span class="line">        Thread thread1 = new Thread(new_thread);</span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(&quot;线程2&quot;);</span><br><span class="line">        Thread thread2 = new Thread(new_thread);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedThread st = new SynchronizedThread();</span><br><span class="line">        st.useThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用 final 域，有锁保护的域 和 volatile 域可以避免非同步的问题。</p><h4 id="使用重入锁（Lock）实现线程同步"><a href="#使用重入锁（Lock）实现线程同步" class="headerlink" title="使用重入锁（Lock）实现线程同步"></a>使用重入锁（Lock）实现线程同步</h4><p>在 JavaSE 5.0 中新增了一个 java.util.concurrent 包来支持同步。ReentrantLock 类是可重入、互斥、实现了 Lock 接口的锁，它与使用 synchronized 方法和块，具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock 类的常用方法有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock() : 创建一个 ReentrantLock 实例         </span><br><span class="line"></span><br><span class="line">lock() : 获得锁        </span><br><span class="line"></span><br><span class="line">unlock() : 释放锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 只给出要修改的代码，其余代码与上同</span><br><span class="line">class Bank &#123;</span><br><span class="line">    </span><br><span class="line">    private int account = 100;</span><br><span class="line"></span><br><span class="line">    // 需要声明这个锁</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    public int getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这里不再需要synchronized </span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            account += money;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>ReentrantLock 类还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。</p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h4 id="借助于-Object-类的-wait-、notify-和-notifyAll-实现通信"><a href="#借助于-Object-类的-wait-、notify-和-notifyAll-实现通信" class="headerlink" title="借助于 Object 类的 wait() 、notify() 和 notifyAll() 实现通信"></a>借助于 Object 类的 wait() 、notify() 和 notifyAll() 实现通信</h4><p>线程执行 wait() 后，就放弃了运行资格，处于冻结状态；</p><p>线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify() 执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。</p><p>notifyall() ，唤醒线程池中所有线程。</p><p><strong>注意：</strong></p><ol><li>wait() 、notify() 、 notifyall() 都用在同步里面，因为这 3 个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中。</li><li>wait() 、 notify() 、 notifyall() 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程，而锁可以是任意对象，所以这 3 个方法都是 Object 类中的方法。</li></ol><p>单个消费者生产者例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 生产者和消费者都要操作的资源 </span><br><span class="line">class Resource &#123;   </span><br><span class="line">    private String name;  </span><br><span class="line">    private int count=1;  </span><br><span class="line">    private boolean flag=false;  </span><br><span class="line"></span><br><span class="line">    public synchronized void set(String name) &#123;  </span><br><span class="line">        if(flag) &#123;  </span><br><span class="line">            try &#123; </span><br><span class="line">                wait(); </span><br><span class="line">            &#125; catch(Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.name=name+&quot;---&quot;+count++;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name);  </span><br><span class="line">        flag=true;  </span><br><span class="line">        this.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public synchronized void out() &#123;  </span><br><span class="line">        if(!flag) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch(Exception e) &#123;&#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name);  </span><br><span class="line">        flag=false;  </span><br><span class="line">        this.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">class Producer implements Runnable &#123;  </span><br><span class="line">    private Resource res;  </span><br><span class="line"></span><br><span class="line">    Producer(Resource res) &#123;  </span><br><span class="line">        this.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while(true) &#123;  </span><br><span class="line">            res.set(&quot;商品&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable&#123;  </span><br><span class="line">    private Resource res;  </span><br><span class="line"></span><br><span class="line">    Consumer(Resource res) &#123;  </span><br><span class="line">        this.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while(true) &#123;  </span><br><span class="line">            res.out();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class ProducerConsumerDemo &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Resource r=new Resource();  </span><br><span class="line">        Producer pro=new Producer(r);  </span><br><span class="line">        Consumer con=new Consumer(r);  </span><br><span class="line">        Thread t1=new Thread(pro);  </span><br><span class="line">        Thread t2=new Thread(con);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。</span><br></pre></td></tr></table></figure><p>但是如果有多个生产者和多个消费者，上面的代码是有问题，比如 2 个生产者，2 个消费者，运行结果就可能出现生产的 1 个商品生产了一次而被消费了 2 次，或者连续生产 2 个商品而只有 1 个被消费，这是因为此时共有 4 个线程在操作 Resource 对象，而 notify() 唤醒的是线程池中第 1 个 wait() 的线程，所以生产者执行 notify() 时，唤醒的线程有可能是另 1 个生产者线程，这个生产者线程从 wait() 中醒来后不会再判断 flag ，而是直接向下运行打印出一个新的商品，这样就出现了连续生产 2 个商品。</p><p>为了避免这种情况，修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Resource &#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">    private int count=1;  </span><br><span class="line">    private boolean flag=false;  </span><br><span class="line"></span><br><span class="line">    public synchronized void set(String name) &#123;  </span><br><span class="line">        // 原先是 if，现在改成 while，这样生产者线程从冻结状态醒来时，还会再判断 flag</span><br><span class="line">        while(flag) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch(Exception e) &#123;&#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        this.name=name+&quot;---&quot;+count++;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name);  </span><br><span class="line">        flag=true;  </span><br><span class="line"></span><br><span class="line">        // 原先是 notity()，现在改成 notifyAll()，这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成 while 后，可能出现所有生产者和消费者都在 wait() 的情况。</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public synchronized void out() &#123;  </span><br><span class="line">        // 原先是 if，现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag</span><br><span class="line">        while(!flag) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch(Exception e) &#123;&#125;  </span><br><span class="line">        &#125; </span><br><span class="line">           </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name);  </span><br><span class="line">        flag=false;  </span><br><span class="line"></span><br><span class="line">        // 原先是 notity()，现在改成 notifyAll()，这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成 while 后，可能出现所有生产者和消费者都在 wait() 的情况。</span><br><span class="line">        this.notifyAll(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class ProducerConsumerDemo &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Resource r=new Resource();  </span><br><span class="line">        Producer pro=new Producer(r);  </span><br><span class="line">        Consumer con=new Consumer(r);  </span><br><span class="line">        Thread t1=new Thread(pro);  </span><br><span class="line">        Thread t2=new Thread(con);  </span><br><span class="line">        Thread t3=new Thread(pro);  </span><br><span class="line">        Thread t4=new Thread(con);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t3.start();  </span><br><span class="line">        t4.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Condition-控制线程通信"><a href="#使用-Condition-控制线程通信" class="headerlink" title="使用 Condition 控制线程通信"></a>使用 Condition 控制线程通信</h4><p>jdk 1.5 中，提供了多线程的升级解决方案为：</p><ol><li>将同步 synchronized 替换为显式的 Lock 操作。</li><li>将 Object 类中的 wait()、notify()、notifyAll() 替换成了 Condition 对象，该对象可以通过 Lock 锁对象获取。</li><li>一个 Lock 对象上可以绑定多个 Condition 对象，这样实现了本方线程只唤醒对方线程，而 jdk 1.5 之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Resource &#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">    private int count=1;  </span><br><span class="line">    private boolean flag=false;  </span><br><span class="line">    private Lock lock = new ReentrantLock(); // Lock 是一个接口，ReentrantLock 是该接口的一个直接子类</span><br><span class="line">    private Condition condition_pro=lock.newCondition(); // 创建代表生产者方面的 Condition对象  </span><br><span class="line">    private Condition condition_con=lock.newCondition(); // 使用同一个锁，创建代表消费者方面的 Condition 对象</span><br><span class="line">      </span><br><span class="line">    public void set(String name) &#123;  </span><br><span class="line">        lock.lock(); // 锁住此语句与 lock.unlock() 之间的代码  </span><br><span class="line">        try &#123;  </span><br><span class="line">            while(flag) &#123;</span><br><span class="line">                condition_pro.await(); // 生产者线程在 conndition_pro 对象上等待  </span><br><span class="line">            &#125;</span><br><span class="line">            this.name=name+&quot;---&quot;+count++;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name);  </span><br><span class="line">            flag=true;  </span><br><span class="line">            condition_con.signalAll();  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally &#123;  </span><br><span class="line">            lock.unlock(); // unlock() 要放在 finally 块中</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void out() &#123;  </span><br><span class="line">        lock.lock(); // 锁住此语句与 lock.unlock() 之间的代码  </span><br><span class="line">        try &#123;  </span><br><span class="line">            while(!flag) &#123;</span><br><span class="line">                condition_con.await(); // 消费者线程在 conndition_con 对象上等待</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name);  </span><br><span class="line">            flag=false;  </span><br><span class="line">            condition_pro.signqlAll(); // 唤醒所有在 condition_pro 对象下等待的线程，也就是唤醒所有生产者线程  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally &#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用阻塞队列（BlockingQueue）控制线程通信"><a href="#使用阻塞队列（BlockingQueue）控制线程通信" class="headerlink" title="使用阻塞队列（BlockingQueue）控制线程通信"></a>使用阻塞队列（BlockingQueue）控制线程通信</h4><p>BlockingQueue 是一个接口，也是 Queue 的子接口。BlockingQueue 具有一个特征：当生产者线程试图向 BlockingQueue 中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从 BlockingQueue 中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向 BlockingQueue 中放入元素、取出元素，即可很好地控制线程的通信。</p><p>BlockingQueue 提供如下两个支持阻塞的方法：</p><ol><li>put(E e)：尝试把 Eu 元素放如 BlockingQueue 中，如果该队列的元素已满，则阻塞该线程。</li><li>take（）：尝试从 BlockingQueue 的头部取出元素，如果该队列的元素已空，则阻塞该线程。</li></ol><p>BlockingQueue 继承了 Queue 接口，当然也可以使用 Queue 接口中的方法，这些方法归纳起来可以分为如下三组：</p><ol><li>在队列尾部插入元素，包括 add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回 false、阻塞队列。</li><li>在队列头部删除并返回删除的元素。包括 remove（）、poll（）、和 take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回 false、阻塞队列。</li><li>在队列头部取出但不删除元素。包括 element（）和 peek（）方法，当队列已空时，这两个方法分别抛出异常、返回 false。</li></ol><p>BlockingQueue 接口包含如下 5 个实现类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue ：基于数组实现的 BlockingQueue 队列。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue：基于链表实现的 BlockingQueue 队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用 remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。它判断元素的大小即可根据元素（实现 Comparable 接口）的本身大小来自然排序，也可使用 Comparator 进行定制排序。</span><br><span class="line"></span><br><span class="line">SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。</span><br><span class="line"></span><br><span class="line">DelayQueue：它是一个特殊的 BlockingQueue，底层基于 PriorityBlockingQueue 实现，不过，DelayQueue 要求集合元素都实现 Delay 接口（该接口里只有一个 long getDelay（）方法），DelayQueue 根据集合元素的 getDalay（）方法的返回值进行排序。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">public class BlockingQueueTest &#123;</span><br><span class="line">    public static void main(String[] args)throws Exception &#123;</span><br><span class="line">        // 创建一个容量为 1 的 BlockingQueue</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;String&gt; b=new ArrayBlockingQueue&lt;&gt;(1);</span><br><span class="line"></span><br><span class="line">        // 启动 3 个生产者线程</span><br><span class="line">        new Producer(b).start();</span><br><span class="line">        new Producer(b).start();</span><br><span class="line">        new Producer(b).start();</span><br><span class="line"></span><br><span class="line">        // 启动一个消费者线程</span><br><span class="line">        new Consumer(b).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Producer extends Thread &#123;</span><br><span class="line">    private BlockingQueue&lt;String&gt; b;</span><br><span class="line">    </span><br><span class="line">    public Producer(BlockingQueue&lt;String&gt; b) &#123;</span><br><span class="line">        this.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void run() &#123;</span><br><span class="line">        String [] str=new String[] &#123;</span><br><span class="line">            &quot;java&quot;,</span><br><span class="line">            &quot;struts&quot;,</span><br><span class="line">            &quot;Spring&quot;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;9999999;i++) &#123;</span><br><span class="line">            System.out.println(getName()+&quot;生产者准备生产集合元素！&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                b.put(str[i%3]);</span><br><span class="line">                sleep(1000);</span><br><span class="line">                // 尝试放入元素，如果队列已满，则线程被阻塞</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName()+&quot;生产完成：&quot;+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer extends Thread &#123;</span><br><span class="line">    private BlockingQueue&lt;String&gt; b;</span><br><span class="line">    public Consumer(BlockingQueue&lt;String&gt; b) &#123;</span><br><span class="line">        this.b=b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void run() &#123;    </span><br><span class="line">        while(true) &#123;</span><br><span class="line">            System.out.println(getName()+&quot;消费者准备消费集合元素！&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(1000);</span><br><span class="line">                // 尝试取出元素，如果队列已空，则线程被阻塞</span><br><span class="line">                b.take();</span><br><span class="line">            &#125; catch(Exception e) &#123; </span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName()+&quot;消费完：&quot;+b);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h4 id="使用-Executors-工厂类产生线程池"><a href="#使用-Executors-工厂类产生线程池" class="headerlink" title="使用 Executors 工厂类产生线程池"></a>使用 Executors 工厂类产生线程池</h4><p>Executor 线程池框架的最大优点是把任务的提交和执行解耦。客户端将要执行的任务封装成 Task，然后提交即可。而 Task 如何执行客户端则是透明的。具体点讲，提交一个 Callable 对象给ExecutorService（如：最常用的线程池 ThreadPoolExecutor ），将得到一个 Future 对象，调用 Future 对象的 get 方法等待执行结果。线程池实现原理类结构图如下：</p><p><img src="thread-chapter/img2.png" alt></p><p>上图中涉及到的线程池内部实现原理的所有类，不利于我们理解线程池如何使用。我们先从客户端的角度出发，看看客户端使用线程池所涉及到的类结构图：由上图可知，ExecutorService 是 Java 中对线程池定义的一个接口，它 java.util.concurrent 包中。Java API 对 ExecutorService 接口的实现有两个，所以这两个即是Java线程池具体实现类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor</span><br><span class="line">ScheduledThreadPoolExecutor</span><br></pre></td></tr></table></figure><p>除此之外，ExecutorService 还继承了 Executor 接口（注意区分 Executor 接口 和 Executors 工厂类），这个接口只有一个 execute() 方法，最后我们看一下整个继承树：</p><p>使用 Executors 执行多线程任务的步骤如下：</p><ul><li>调用 Executors 类的静态工厂方法创建一个 ExecutorService 对象，该对象代表一个线程池。</li><li>创建 Runnable 实现类或 Callable 实现类的实例，作为线程执行任务。</li><li>调用 ExecutorService 对象的 submit() 方法来提交 Runnable 实例或 Callable 实例。</li><li>当不想提交任务时，调用 ExecutorService 对象的 shutdown() 方法来关闭线程池。  </li></ul><p><strong>1. 使用 Executors 的静态工厂类创建线程池的方法如下：</strong><br>（1）newFixedThreadPool() ：<br>作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。 </p><p>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按 FIFO 方式处理任务队列中的任务。</p><p>（2）newCachedThreadPool() ：<br>作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。 </p><p>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为 60s。</p><p>（3）newSingleThreadExecutor() ：<br>作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按 FIFO 方式顺序执行任务队列中的任务。</p><p>（4）newScheduledThreadPool() ：<br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</p><p>（5）newSingleThreadScheduledExecutor() ：<br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为 1，而上面的可以指定线程池的大小。</p><p><strong>注意：</strong>Executors 只是一个工厂类，它所有的方法返回的都是T hreadPoolExecutor、ScheduledThreadPoolExecutor 这两个类的实例。</p><p><strong>2. ExecutorService 有如下几个执行方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- execute(Runnable)</span><br><span class="line">- submit(Runnable)</span><br><span class="line">- submit(Callable)</span><br><span class="line">- invokeAny(...)</span><br><span class="line">- invokeAll(...)</span><br></pre></td></tr></table></figure><p>（1）execute(Runnable)：<br>这个方法接收一个 Runnable 实例，并且异步的执行，请看下面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">executorService.execute(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>（2）submit(Runnable)：<br>submit(Runnable) 和 execute(Runnable) 区别是前者可以返回一个 Future 对象，通过返回的 Future 对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future.get();  // returns null if the task has finished correctly.</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果任务执行完成，future.get() 方法会返回一个 null。注意，future.get() 方法会产生阻塞。</p><p>（3）submit(Callable)：<br>submit(Callable) 和 submit(Runnable) 类似，也会返回一个 Future 对象，但是除此之外，submit(Callable) 接收的是一个 Callable 的实现，Callable 接口中的 call() 方法有一个返回值，可以返回任务的执行结果，而 Runnable 接口中的 run() 方法是 void 的，没有返回值。请看下面实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(new Callable()&#123;</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous Callable&quot;);</span><br><span class="line">        return &quot;Callable Result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;future.get() = &quot; + future.get());</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果任务执行完成，future.get() 方法会返回 Callable 任务的执行结果。另外，future.get() 方法会产生阻塞。</p><p>（4）invokeAny(…)：<br>invokeAny(…) 方法接收的是一个 Callable 的集合，执行这个方法不会返回 Future，但是会返回所有 Callable 任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(new Callable&lt;String&gt;() &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Task 1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">callables.add(new Callable&lt;String&gt;() &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Task 2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">callables.add(new Callable&lt;String&gt;() &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Task 3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">String result = executorService.invokeAny(callables);</span><br><span class="line">System.out.println(&quot;result = &quot; + result);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>大家可以尝试执行上面代码，每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”，也可是“Task1”或者其它。</p><p>（5）invokeAll(…)：<br>invokeAll(…) 与 invokeAny(…) 类似也是接收一个 Callable 集合，但是前者执行之后会返回一个 Future 的 List，其中对应着每个 Callable 任务执行后的 Future 对象。情况下面这个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(new Callable&lt;String&gt;() &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Task 1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">callables.add(new Callable&lt;String&gt;() &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Task 2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">callables.add(new Callable&lt;String&gt;() &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Task 3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);</span><br><span class="line">for(Future&lt;String&gt; future : futures) &#123;</span><br><span class="line">    System.out.println(&quot;future.get = &quot; + future.get());</span><br><span class="line">&#125;</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p><strong>3. ExecutorService 关闭方法</strong><br>当我们使用完成 ExecutorService 之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过 main() 方法启动的，在这个 main() 退出之后，如果应用程序中的 ExecutorService 没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为 ExecutorService 中运行的线程会阻止 JVM 关闭。</p><p>要关闭 ExecutorService 中执行的线程，我们可以调用 ExecutorService.shutdown() 方法。在调用 shutdown() 方法之后，ExecutorService 不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在 shutdown() 执行之前提交的任务都会被执行。</p><p>如果想立即关闭 ExecutorService，我们可以调用 ExecutorService.shutdownNow() 方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h4 id="使用-Java-8-增强的-ForkJoinPool-产生线程池"><a href="#使用-Java-8-增强的-ForkJoinPool-产生线程池" class="headerlink" title="使用 Java 8 增强的 ForkJoinPool 产生线程池"></a>使用 Java 8 增强的 ForkJoinPool 产生线程池</h4><p>在 Java 8 中，引入了自动并行化的概念。它能够让一部分 Java 代码自动地以并行的方式执行，前提是使用了 ForkJoinPool。</p><p>ForkJoinPool 同 ThreadPoolExecutor 一样，也实现了 Executor 和 ExecutorService 接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的 CPU 数量会被设置为线程数量作为默认值。</p><p>ForkJoinPool 主要用来使用分治法（Divide-and-Conquer Algorithm）来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool 需要使用相对少的线程来处理大量的任务。比如要对 1000 万个数据进行排序，那么会将这个任务分割成两个 500 万的排序任务和一个针对这两组 500 万数据的合并任务。以此类推，对于 500 万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于 10 时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概 2000000+ 个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。所以当使用 ThreadPoolExecutor 时，使用分治法会存在问题，因为 ThreadPoolExecutor 中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用 ForkJoinPool 时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。比如，我们需要统计一个 double 数组中小于 0.5 的元素的个数，那么可以使用 ForkJoinPool 进行实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinTest &#123;</span><br><span class="line">    private double[] d;</span><br><span class="line">    private class ForkJoinTask extends RecursiveTask &#123;</span><br><span class="line">        private int first;</span><br><span class="line">        private int last;</span><br><span class="line">        public ForkJoinTask(int first, int last) &#123;</span><br><span class="line">            this.first = first;</span><br><span class="line">            this.last = last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            int subCount;</span><br><span class="line">            if (last - first &lt; 10) &#123;</span><br><span class="line">                subCount = 0;</span><br><span class="line">                for (int i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                    if (d[i] &lt; 0.5)&#123;</span><br><span class="line">                        subCount++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;else &#123;</span><br><span class="line">                int mid = (first + last) / 2;</span><br><span class="line">                ForkJoinTask left = new ForkJoinTask(first, mid);</span><br><span class="line">                left.fork();</span><br><span class="line">                ForkJoinTask right = new ForkJoinTask(mid + 1, last);</span><br><span class="line">                right.fork();</span><br><span class="line">                subCount = left.join();</span><br><span class="line">                subCount += right.join();</span><br><span class="line">            &#125;</span><br><span class="line">            return subCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool pool=new ForkJoinPool();</span><br><span class="line">        pool.submit(new ForkJoinTask(0, 9999999));</span><br><span class="line">        pool.awaitTermination(2,TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(&quot;Found &quot; + n + &quot; values&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的关键是 fork() 和 join() 方法。在 ForkJoinPool 使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。</p><p><strong>注意：</strong>使用 ThreadPoolExecutor 和 ForkJoinPool 的性能差异：</p><ol><li><p>首先，使用 ForkJoinPool 能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过 200 万个任务。但是，使用 ThreadPoolExecutor 时，是不可能完成的，因为 ThreadPoolExecutor 中的 Thread 无法选择优先执行子任务，需要完成 200 万个具有父子关系的任务时，也需要 200 万个线程，显然这是不可行的。</p></li><li><p>ForkJoinPool 能够实现工作窃取（Work Stealing），在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。因此，提高了线程的利用率，从而提高了整体性能。</p></li><li><p>对于 ForkJoinPool，还有一个因素会影响它的性能，就是停止进行任务分割的那个阈值。比如在之前的快速排序中，当剩下的元素数量小于10的时候，就会停止子任务的创建。</p></li></ol><p><strong>结论：</strong></p><ol><li><p>当需要处理递归分治算法时，考虑使用 ForkJoinPool。</p></li><li><p>仔细设置不再进行任务划分的阈值，这个阈值对性能有影响。</p></li><li><p>Java 8 中的一些特性会使用到 ForkJoinPool 中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。</p></li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>产生死锁的四个必要条件如下。当下边的四个条件都满足时即产生死锁，即任意一个条件不满足既不会产生死锁。</p><p><strong>死锁的四个必要条件：</strong></p><ul><li>互斥条件：资源不能被共享，只能被同一个进程使用。</li><li>请求与保持条件：已经得到资源的进程可以申请新的资源。</li><li>非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺。</li><li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源。</li></ul><p>举个常见的死锁例子：进程 A 中包含资源 A，进程 B 中包含资源 B，A 的下一步需要资源 B，B 的下一步需要资源 A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。</p><p><strong>处理死锁的方法：</strong></p><ul><li>忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它。</li><li>检测死锁并恢复。</li><li>资源进行动态分配。</li><li>破除上面的四种死锁条件之一。</li></ul><h3 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h3><p><strong>ThreadLocal</strong><br>ThreadLocal 它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 即多个线程通过同一个 ThreadLocal 获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。使用这个工具类可以简化多线程编程时的并发访问，很简洁的隔离多线程程序的竞争资源。</p><p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而 ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。ThreadLocal 类提供了如下的三个 public 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个线程本地变量</span><br><span class="line">ThreadLocal()</span><br><span class="line"></span><br><span class="line">// 返回此线程局部变量的当前线程副本中的值，如果这是线程第一次调用该方法，则创建并初始化此副本</span><br><span class="line">T get()</span><br><span class="line">          </span><br><span class="line">// 返回此线程局部变量的当前线程的初始值</span><br><span class="line">protected  T initialValue()</span><br></pre></td></tr></table></figure><p>下面通过系统源码来分析出现这个结果的原因。 在 ThreadLocal 中存在着两个很重要的方法，get() 和 set() 方法，一个读取一个设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Returns the value of this variable for the current thread. If an entry</span><br><span class="line">* doesn&apos;t yet exist for this variable on this thread, this method will</span><br><span class="line">* create an entry, populating the value with the result of</span><br><span class="line">* &#123;@link #initialValue()&#125;.</span><br><span class="line">*</span><br><span class="line">* @return the current value of the variable for the calling thread.</span><br><span class="line">*/</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public T get() &#123;</span><br><span class="line">   // Optimized for the fast path.</span><br><span class="line">   Thread currentThread = Thread.currentThread();</span><br><span class="line">   Values values = values(currentThread);</span><br><span class="line">   if (values != null) &#123;</span><br><span class="line">        Object[] table = values.table;</span><br><span class="line">        int index = hash &amp; values.mask;</span><br><span class="line">        if (this.reference == table[index]) &#123;</span><br><span class="line">　　　　　      return (T) table[index + 1];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">　　　　values = initializeValues(currentThread);</span><br><span class="line">　　&#125;</span><br><span class="line">　　return (T) values.getAfterMiss(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Sets the value of this variable for the current thread. If set to</span><br><span class="line">* &#123;@code null&#125;, the value will be set to null and the underlying entry will</span><br><span class="line">* still be present.</span><br><span class="line">*</span><br><span class="line">* @param value the new value of the variable for the caller thread.</span><br><span class="line">*/</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">     Thread currentThread = Thread.currentThread();</span><br><span class="line">　　 Values values = values(currentThread);</span><br><span class="line">　　 if (values == null) &#123;</span><br><span class="line">　　　　  values = initializeValues(currentThread);</span><br><span class="line">　　　&#125;</span><br><span class="line">   values.put(this, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从注释上可以看出，get() 方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。另外，对于“当前线程”和“数组”，数组对于每个线程来说都是不同的 values.table。而 values 是通过当前线程获取到的一个 Values 对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个 ThreadLocal 返回的是不同的东西。</p><p>Java 中为什么要这么设置呢？</p><ul><li><p>ThreadLocal 在日常开发中使用到的地方较少，但是在某些特殊的场景下，通过 ThreadLocal 可以轻松实现一些看起来很复杂的功能。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用 ThreadLocal。例如在 Handler 和 Looper 中。对于 Handler 来说，它需要获取当前线程的 Looper，很显然 Looper 的作用域就是线程并且不同的线程具有不同的 Looper，这个时候通过 ThreadLocal 就可以轻松的实现 Looper 在线程中的存取。如果不采用 ThreadLocal，那么系统就必须提供一个全局的哈希表供 Handler 查找指定的 Looper，这样就比较麻烦了，还需要一个管理类。</p></li><li><p>ThreadLocal 的另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，就可能表现为函数调用栈比较深以及代码入口的多样性，这种情况下，我们又需要监听器能够贯穿整个线程的执行过程。这个时候就可以使用到 ThreadLocal，通过 ThreadLocal 可以让监听器作为线程内的全局对象存在，在线程内通过 get() 方法就可以获取到监听器。如果不采用的话，可以使用参数传递，但是这种方式在设计上不是特别好，当调用栈很深的时候，通过参数来传递监听器这个设计太糟糕。而另外一种方式就是使用 static 静态变量的方式，但是这种方式存在一定的局限性，拓展性并不是特别的强。比如有 10 个线程在执行，就需要提供 10 个监听器对象。</p></li></ul><p><strong>注意：</strong>ThreadLocal 和其他所有的同步机制一样，都是为了解决多线程中对于同一变量的访问冲突。值普通的同步机制中，通过对象加锁来实现多线程对同一变量的安全访问，且该变量是多线程共享的，所有需要使用这种同步机制来明确分开是在什么时候对变量进行读写，在什么时候需要锁定该对象。此种情况下，系统并没有将这个资源复制多份，而是采取安全机制来控制访问而已。 ThreadLocal 只是从另一个角度解决多线程的并发访问，即将需要并发访问的资源复制多份，每个线程拥有一份资源，每个线程都有自己的资源副本。</p><p><strong>总结：</strong>若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用 ThreadLocal。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thread </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（四）：虚拟机类加载机制</title>
      <link href="/2018/09/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/09/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p><p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="jvm-chapter-4/img1.jpg" alt></p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p><a id="more"></a><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ol><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li></ol><p>前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int value = 1127;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class SubClass extends SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ConstClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;ConstClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String HELLOWORLD = &quot;hello world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        /**</span><br><span class="line">         *  output : SuperClass init!</span><br><span class="line">         * </span><br><span class="line">         * 通过子类引用父类的静态对象不会导致子类的初始化</span><br><span class="line">         * 只有直接定义这个字段的类才会被初始化</span><br><span class="line">         */</span><br><span class="line"> </span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line">        /**</span><br><span class="line">         *  output : </span><br><span class="line">         * </span><br><span class="line">         * 通过数组定义来引用类不会触发此类的初始化</span><br><span class="line">         * 虚拟机在运行时动态创建了一个数组类</span><br><span class="line">         */</span><br><span class="line"> </span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">        /**</span><br><span class="line">         *  output : </span><br><span class="line">         * </span><br><span class="line">         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</span><br><span class="line">         * 因此不会触发定义常量的类的初始化。</span><br><span class="line">         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ol><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ol><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ol><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p><p>文件格式验证</p><ol><li>是否以魔数 0xCAFEBABE 开头。</li><li>主、次版本号是否在当前虚拟机处理范围之内。</li><li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。</li><li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息。</li><li>……</li></ol><p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p><p>元数据验证</p><ol><li>这个类是否有父类（除 java.lang.Object 之外）。</li><li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）。</li></ol><p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p><p>字节码验证</p><ol><li>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）。</li><li>……</li></ol><p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>符号引用验证</p><ol><li>符号引用中通过字符创描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li><li>……</li></ol><p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。</p><p>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p><p>public static int value = 1127;<br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p><p>基本数据类型的零值</p><table><thead><tr><th>数据类型</th><th>零值</th><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td><td>boolean</td><td>false</td></tr><tr><td>long</td><td>0L</td><td>float</td><td>0.0f</td></tr><tr><td>short</td><td>(short) 0</td><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>‘\u0000’</td><td>reference</td><td>null</td></tr><tr><td>byte</td><td>(byte) 0</td><td></td><td></td></tr></tbody></table><p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ol><li><p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。</p></li><li><p>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关。</p></li></ol><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。如果两个类来源于同一个 Class 文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p><ol><li><p>启动类加载器<br>这个类加载器负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 去 rt.jar ，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 getClassLoader() 方法返回 null 。</p></li><li><p>扩展类加载器<br>这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 \lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p></li><li><p>引用程序类加载器<br>这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader中的getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ol><p><img src="jvm-chapter-4/img2.jpg" alt></p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合的关系复用父类加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>双亲委派模型的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    //1 首先检查类是否被加载</span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    if (c == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (parent != null) &#123;</span><br><span class="line">             //2 没有则调用父类加载器的loadClass()方法；</span><br><span class="line">                c = parent.loadClass(name, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //3 若父类加载器为空，则默认使用启动类加载器作为父加载器；</span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">           //4 若父类加载失败，抛出ClassNotFoundException 异常后</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resolve) &#123;</span><br><span class="line">        //5 再调用自己的findClass() 方法。</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>keyword：线程上下文加载器(Thread Context ClassLoader)。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（三）：Java内存模型与线程</title>
      <link href="/2018/09/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/09/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="jvm-chapter-3/img1.jpg" alt></p><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>屏蔽掉各种硬件和操作系统的内存访问差异。</p><p><img src="jvm-chapter-3/img2.jpg" alt></p><h4 id="主内存和工作内存之间的交互"><a href="#主内存和工作内存之间的交互" class="headerlink" title="主内存和工作内存之间的交互"></a>主内存和工作内存之间的交互</h4><table><thead><tr><th>操作</th><th>作用对象</th><th>解释</th></tr></thead><tbody><tr><td>lock</td><td>主内存</td><td>把一个变量标识为一条线程独占的状态</td></tr><tr><td>unlock</td><td>主内存</td><td>把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td></tr><tr><td>read</td><td>主内存</td><td>把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td></tr><tr><td>load</td><td>工作内存</td><td>把 read 操作从主内存中得到的变量值放入工作内存中</td></tr><tr><td>use</td><td>工作内存</td><td>把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td></tr><tr><td>assign</td><td>工作内存</td><td>把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td>store</td><td>工作内存</td><td>把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td></tr><tr><td>write</td><td>工作内存</td><td>把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><a id="more"></a><h4 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h4><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p><p>一个变量被定义为 volatile 的特性：保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。</p><p>如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁（使用 synchronize 或 java.util.concurrent 中的原子类）来保证原子性。</p><p>禁止指令重排序优化。<br>通过插入内存屏障保证一致性。</p><h4 id="对于-long-和-double-型变量的特殊规则"><a href="#对于-long-和-double-型变量的特殊规则" class="headerlink" title="对于 long 和 double 型变量的特殊规则"></a>对于 long 和 double 型变量的特殊规则</h4><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p><h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p>回顾下并发下应该注意操作的那些特性是什么，同时加深理解。</p><p><strong>原子性(Atomicity)</strong><br>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p><p><strong>可见性(Visibility)</strong><br>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p><p><strong>有序性(Ordering)</strong><br>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p><h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p><p>天然的先行发生关系</p><table><thead><tr><th>规则</th><th>解释</th></tr></thead><tbody><tr><td>程序次序规则</td><td>在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td>管程锁定规则</td><td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td>volatile 变量规则</td><td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td>线程启动规则</td><td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td></tr><tr><td>线程终止规则</td><td>线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td></tr><tr><td>线程中断规则</td><td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)</td></tr><tr><td>对象终结规则</td><td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td>传递性</td><td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p><strong>使用内核线程实现</strong><br>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p><p><img src="jvm-chapter-3/img3.jpg" alt></p><p><strong>使用用户线程实现</strong><br>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p><p><img src="jvm-chapter-3/img4.jpg" alt></p><p><strong>使用用户线程夹加轻量级进程混合实现</strong><br>直接看图。</p><p><img src="jvm-chapter-3/img5.jpg" alt></p><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p><h4 id="Java-线程调度"><a href="#Java-线程调度" class="headerlink" title="Java 线程调度"></a>Java 线程调度</h4><p><strong>协同式线程调度</strong><br>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p><p><strong>抢占式线程调度</strong><br>每个线程由系统来分配执行时间。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><strong>新建(new)</strong><br>创建后尚未启动的线程。</p><p><strong>运行(Runable)</strong><br>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p><p><strong>无限期等待(Waiting)</strong><br>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p><p>以下方法会然线程进入无限期等待状态：<br>1、没有设置 Timeout 参数的 Object.wait() 方法。<br>2、没有设置 Timeout 参数的 Thread.join() 方法。<br>3、LookSupport.park() 方法。</p><p><strong>限期等待(Timed Waiting)</strong><br>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p><p>以下方法会让线程进入限期等待状态：<br>1、Thread.sleep() 方法。<br>2、设置了 Timeout 参数的 Object.wait() 方法。<br>3、设置了 Timeout 参数的 Thread.join() 方法。<br>4、LockSupport.parkNanos() 方法。<br>5、LockSupport.parkUntil() 方法。</p><p><strong>阻塞(Blocked)</strong><br>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p><p><strong>结束(Terminated)</strong><br>已终止线程的线程状态。</p><p><strong>状态转换总结，如下图所示：</strong><br><img src="jvm-chapter-3/img6.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（二）：垃圾回收器与内存分配策略</title>
      <link href="/2018/09/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2018/09/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p><a id="more"></a><h3 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h3><p>在进行内存回收之前要做的事情就是判断哪些对象是“死”的，哪些对象是“活”的。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p><p><img src="jvm-chapter-2/img1.jpg" alt></p><p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p><p><img src="jvm-chapter-2/img2.jpg" alt></p><p>可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>前面的两种方式判断存活时都与“引用”有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。</p><p><strong>强引用</strong><br>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</p><p><strong>软引用</strong><br>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p><p><strong>弱引用</strong><br>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p><p><strong>虚引用</strong><br>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>finalize() 方法只会被系统自动调用一次。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。<br>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类：要以下三个条件都满足</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h4><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p><p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p><h4 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h4><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p><p><img src="jvm-chapter-2/img3.jpg" alt></p><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p><p><img src="jvm-chapter-2/img4.jpg" alt></p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>可以认为是 Serial 收集器的多线程版本。</p><p><img src="jvm-chapter-2/img5.jpg" alt></p><p>并行：Parallel<br>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p><p>并发：Concurrent<br>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p><p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>收集器的老年代版本，单线程，使用 标记 —— 整理。</p><p><img src="jvm-chapter-2/img6.jpg" alt></p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理</p><p><img src="jvm-chapter-2/img7.jpg" alt></p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。</p><p>运作步骤:</p><ol><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象。</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing。</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分。</li><li>并发清除(CMS concurrent sweep)。</li></ol><p><img src="jvm-chapter-2/img8.jpg" alt></p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片</p><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>面向服务端的垃圾回收器。</p><p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p><p>运作步骤:</p><ol><li>初始标记(Initial Marking)。</li><li>并发标记(Concurrent Marking)。</li><li>最终标记(Final Marking)。</li><li>筛选回收(Live Data Counting and Evacuation)。</li></ol><p><img src="jvm-chapter-2/img9.jpg" alt></p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>一般来说 Java 堆的内存模型如下图所示：</p><p><img src="jvm-chapter-2/img10.jpg" alt></p><p>新生代 GC (Minor GC)<br>发生在新生代的垃圾回收动作，频繁，速度快。</p><p>老年代 GC (Major GC / Full GC)<br>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p><h4 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h4><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象是指需要大量连续内存空间的对象，虚拟机提供了参数 -XX:PretenureSizeThreshold（只对Serial，PerNew两个回收器起效），令大于这个值得对象直接在老年代分配，避免了 Eden 和 两个 Survival 之间发生大量的内存复制。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了对象年龄计数器（Age），如果对象在Eden出生，经过第一次 Minor GC 后依然存活，并且能被 Survival 容纳的话，将被移动到 Survival ，对象年龄设为 1。对象在 Survival 中每熬过一次 Major GC，年龄就增加 1，达到一定程度（默认是 15 ），就会被晋升到老年代。对象晋升老年代的阈值，可以通过参数 -XX:MaxTenuringThreShold 指定。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>如果在 Survival 空间中相同年龄所有对象的大小综合超过了 Survival 空间的一半，年龄大于等于这个年龄的对象都会被晋升到老年代。无需等待年龄超过 MaxTenuringThreShold 指定的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>只要老年代的连续空间大于新生代对象总和或者历次晋升的平均大小，就进行 Major GC，否则进行 Full GC。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（一）：Java内存区域与内存溢出异常</title>
      <link href="/2018/09/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/09/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配一个地址空间、建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费要比进程小很多，同时创建一个线程的开销也要比进程小很多。</p><a id="more"></a><p>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包含一个线程。线程之间的通信更加方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信则需要以通信的方式（IPC）进行。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java 虚拟机在执行 Java 程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java 虚拟机所管理的内存包括以下几个运行时数据区域，如下图所示：</p><p><img src="jvm-chapter-1/img1.jpg" alt></p><h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看成是当前线程所执行字节码的行号指示器。在计算机中，其实程序计数器就是一个寄存器，依据不同计算机细节的差异，它可以存放当前正在被执行的指令，也可以放下一个被执行的指令。</p><p>在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令的。</p><p>由于 Java 虚拟机的多线程是通过线程轮询切换并分配处理器执行时间的方式来实现的，在任何一个确定的时候，一个处理器都只会执行一条线程中的指令，因此为了线程切换之后能过恢复到正确的执行位置，每条线程都需要拥有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，所以程序计数器是线程私有的内存，也就是它属于线程隔离区的。</p><p>如果线程执行的是一个 Java 方法，这个计数器记录的就是正在执行的虚拟机字节码指令地址；如果正在执行的是 Native 方法，那么这个计数器的值就是（Undefined）。</p><p>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h4><p>Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，即他的生命周期和线程相同。</p><p>在 Java 中，JVM 中的栈记录了线程的方法调用，每个线程拥有一个栈，在某个线程的运行过程中，如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈针（Stack Frame）。</p><p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法从调用至完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放。线程回到原方法，继续执行。当所有的栈都清空时，程序也随之运行结束。</p><p>我们经常说的栈内存其实就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p><p>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，可能是指向对象起始位置的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置，引用所指向的对象保存在堆中（引用可能为 Null，即不指向任何对象））和 returnAddress 类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。局部变量表所需要的内存空间在编译时期完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>异常有两种：<br>1、线程请求的栈深度大于虚拟机所允许的深度将抛出 StackOverflowError 异常 （递归调用）<br>2、如果虚拟机可以动态扩展，如果扩展时已经无法申请到足够的内存就会抛出 OutOfMemeoryError 异常。</p><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的。他们之间的区别就是 Java 虚拟机栈是位虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈为位虚拟机使用到的 Native 方法服务。</p><p>其实虚拟机规范中对本地方发栈中方法所使用的语言、使用方式以及数据结构都没有强制规定，因此具体的虚拟机可以自由地实现它。甚至在有的虚拟机（如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和           OutOfMemory  异常。</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机管理的内存中最大的一块。Java 堆是被所有线程共享的一块数据区域，在虚拟机启动时创建，这一内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也逐渐变得不是那么“绝对”。</p><p>堆中可细分为新生代和老年代，在细分可以分为 Ede n空间、Form Survivor 空间、to Survivor 空间。</p><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p><p>根据 Java 虚拟机规范规定，Java 堆可以处于物理上不连续的内存中，即只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，可以固定大小也是可扩展的。主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 来控制）。如果在堆中没有内存可分配，并且堆也无法继续扩展时，将会抛出 OutOfMemortError 异常。</p><p>Java 的普通对象存活在堆中，与栈不同，堆的空间不会随着方法调用结束而清空。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存控件将会最终消耗殆尽。</p><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译之后的代码等数据。虽然 Java 虚拟机将其描述为堆的一个逻辑部分，但它却有一个别名叫做 Non-Heap（非堆）。目的是与 Java 堆区分开来。（以前很多人把方法区称为永久代，现在JDK1.8中已经用元数据区域取代了永久代）。</p><p>运行时常量池：<br>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入到方法区的运行时常量池中存放。并非预置入 Class 文件中常量池的内容才进入方法运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p><p>当方法区无法满足内存分配需求时，抛出 OutOfMemoryError 异常。</p><h4 id="总结每个区域存储的内容，如下图所示："><a href="#总结每个区域存储的内容，如下图所示：" class="headerlink" title="总结每个区域存储的内容，如下图所示："></a>总结每个区域存储的内容，如下图所示：</h4><p><img src="jvm-chapter-1/img2.jpg" alt></p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>由于直接内存（Direct Memory）并不是 Java 虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部分也被频繁使用，而且也可能导致内存溢出异常出现，所以也放到这一部分进行简介。</p><p>先让，本机直接内存的分配不会受到 Java 堆大小的限制，但是肯定还是会受到本机总内存大小以及处理器寻址空间的限制。管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常会忽略直接内存，使得各个内存区域总和大于物理内存限制（包含物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。</p><p>JDK1.4 加入了 NIO，引入一种基于通道与缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。因此避免了在 Java 堆和 Native 堆中来回复制数据，提高了性能。</p><h3 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h3><p>主要介绍数据是如何创建、如何布局以及如何访问的。</p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>虚拟机遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p><p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p><p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p><p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在 HotSpot 虚拟机中，分为 3 块区域：对象头（Header）、实例数据（Instance Data）和 对齐填充（Padding）。</p><p><strong>对象头（Header）</strong>：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><strong>实例数据（Instance Data）</strong>：程序代码中所定义的各种类型的字段内容（包含父类继承下来的和子类中定义的）。</p><p><strong>对齐填充（Padding）</strong>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p><p><strong>通过句柄访问</strong>：Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。如下图所示：</p><p><img src="jvm-chapter-1/img3.jpg" alt></p><p><strong>使用直接指针访问</strong>：reference 中直接存储对象地址。如下图所示：</p><p><img src="jvm-chapter-1/img4.jpg" alt></p><div class="note info">            <p><strong>比较</strong>：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>          </div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令详解</title>
      <link href="/2018/08/20/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/20/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><a id="more"></a><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate    # 简写：hexo g</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server    # 简写：hexo s</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy    # 简写：hexo d</span><br></pre></td></tr></table></figure><p>部署网站。</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发表草稿</p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure><p>渲染文件。</p><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统迁移内容。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version    # 简写：hexo v</span><br></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><p>显示 source/_drafts 文件夹中的草稿文章。</p><h4 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p><h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><ol><li><p>生成静态文件后自动部署网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --deploy    # 简写：hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>生成静态文件后自动部署网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate &amp;&amp; hexo deploy    # 简写：hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li><li><p>先清除缓存文件，然后再生成静态文件后自动部署网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy    # 简写：hexo clean &amp;&amp; hexo g &amp;&amp; hexo  d</span><br></pre></td></tr></table></figure></li><li><p>生成静态文件后自动启动 Hexo 服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate &amp;&amp; hexo server    # 简写：hexo g &amp;&amp; hexo  s</span><br></pre></td></tr></table></figure></li><li><p>先清除缓存文件，然后再生成静态文件后自动启动 Hexo 服务器</p><pre><code>$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server    # 简写：hexo clean &amp;&amp; hexo g &amp;&amp; hexo  s</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客（三）：主题美化</title>
      <link href="/2018/08/17/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/2018/08/17/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="自定样式"><a href="#自定样式" class="headerlink" title="自定样式"></a>自定样式</h3><p>您可以将所有自定义样式文件放在 <code>hexo-size/source/_data</code> 目录下。<br>编辑 主题配置文件 <code>_config.yml</code> ，取消 <code>custom_file_path</code> 前面的注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  #footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="设置-RSS"><a href="#设置-RSS" class="headerlink" title="设置 RSS"></a>设置 RSS</h3><p>NexT 中 RSS 有三个设置选项，满足特定的使用场景。</p><ul><li>false：禁用 RSS，不在页面上显示 RSS 连接。</li><li>留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 插件。</li><li>具体的URL：这个URL需要您提前生成（如：/atom.xml）。<br>编辑 主题配置文件 <code>_config.yml</code> 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: false    # 禁用 RSS</span><br></pre></td></tr></table></figure></li></ul><h3 id="添加「分类」页面"><a href="#添加「分类」页面" class="headerlink" title="添加「分类」页面"></a>添加「分类」页面</h3><p>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>hexo new page</code> 命令新建一个页面，命名为 <code>categories</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><p>此时会在 <code>hexo-size/source</code> 目录下生成一个 <code>categories</code> 文件夹，打开 <code>categories</code> 文件夹，修改 <code>index.md</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2019-08-20 13:17:57</span><br><span class="line">type: &quot;categories&quot;    # 将页面的类型设置为 categories</span><br><span class="line">comments: false       # 该页面禁用评论</span><br></pre></td></tr></table></figure><p>编辑 主题配置文件 <code>_config.yml</code> ， 添加 <code>categories</code> 到 <code>menu</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                       # 首页</span><br><span class="line">  archives: /archives/ || archive       # 归档</span><br><span class="line">  categories: /categories/ || th        # 分类</span><br></pre></td></tr></table></figure><h3 id="添加「标签」页面"><a href="#添加「标签」页面" class="headerlink" title="添加「标签」页面"></a>添加「标签」页面</h3><p>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>hexo new page</code> 命令新建一个页面，命名为 <code>tags</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>此时会在 <code>hexo-size/source</code> 目录下生成一个 <code>tags</code> 文件夹，打开 <code>tags</code> 文件夹，修改 <code>index.md</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-08-20 13:17:57</span><br><span class="line">type: &quot;tags&quot;       # 将页面的类型设置为 tags</span><br><span class="line">comments: false    # 该页面禁用评论</span><br></pre></td></tr></table></figure><p>编辑 主题配置文件 <code>_config.yml</code> ， 添加 <code>tags</code> 到 <code>menu</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                       # 首页</span><br><span class="line">  archives: /archives/ || archive       # 归档</span><br><span class="line">  categories: /categories/ || th        # 分类</span><br><span class="line">  tags: /tags/ || tags                  # 标签</span><br></pre></td></tr></table></figure><h3 id="添加「关于」页面"><a href="#添加「关于」页面" class="headerlink" title="添加「关于」页面"></a>添加「关于」页面</h3><p>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>hexo new page</code> 命令新建一个页面，命名为 <code>about</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure><p>此时会在 <code>hexo-size/source</code> 目录下生成一个 <code>about</code> 文件夹，打开 <code>about</code> 文件夹，修改 <code>index.md</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 关于</span><br><span class="line">date: 2019-08-20 13:17:57</span><br><span class="line">type: &quot;about&quot;      # 将页面的类型设置为 about</span><br></pre></td></tr></table></figure><p>编辑 主题配置文件 <code>_config.yml</code> ， 添加 <code>about</code> 到 <code>menu</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                       # 首页</span><br><span class="line">  archives: /archives/ || archive       # 归档</span><br><span class="line">  categories: /categories/ || th        # 分类</span><br><span class="line">  tags: /tags/ || tags                  # 标签</span><br><span class="line">  about: /about/ || user                # 关于</span><br></pre></td></tr></table></figure><h3 id="设置代码块样式"><a href="#设置代码块样式" class="headerlink" title="设置代码块样式"></a>设置代码块样式</h3><p>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme" target="_blank" rel="noopener">Tomorrow Theme</a> 作为代码高亮，共有5款主题供你选择。</p><ul><li>normal</li><li>night</li><li>night blue</li><li>night bright</li><li>night eighties</li></ul><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">codeblock:  </span><br><span class="line">  highlight_theme: night    # 设置代码高亮主题为：night         </span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true            # 代码块是否添加复制按钮</span><br><span class="line">    show_result: true       # 是否显示文本复制结果</span><br><span class="line">    style: flat             # 复制按钮的样式，值：default、flat、mac</span><br></pre></td></tr></table></figure><h3 id="设置阅读进度条样式"><a href="#设置阅读进度条样式" class="headerlink" title="设置阅读进度条样式"></a>设置阅读进度条样式</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: false    # 是否启用阅读进度条</span><br><span class="line">  position: top    # 位置，值：top、bottom</span><br><span class="line">  color: &quot;#37c6c0&quot; # 颜色</span><br><span class="line">  height: 2px      # 高度</span><br></pre></td></tr></table></figure><h3 id="设置书签"><a href="#设置书签" class="headerlink" title="设置书签"></a>设置书签</h3><p>书签是一个插件，允许您阅读的时候保存阅读进度。您可以在页面上单击书签图标（如：🔖），将会保存滚动的位置，当您下次再访问的时候，便可以自动恢复到每个页面的最后滚动位置。<br>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bookmark:   </span><br><span class="line">  enable: false    # 是否启用书签</span><br><span class="line">  color: &quot;#222&quot;    # 书签颜色</span><br><span class="line">  # 如果是 auto ，则在关闭页面或单击书签图标时保存阅读进度</span><br><span class="line">  # 如果是 manual ，则需点击书签图标保存它</span><br><span class="line">  save: auto       # 保存设置，值：auto、manual</span><br></pre></td></tr></table></figure><h3 id="设置社交链接"><a href="#设置社交链接" class="headerlink" title="设置社交链接"></a>设置社交链接</h3><p>侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。</p><ul><li>social：设置社交链接。</li><li>social_icons：设置社交链接图标。</li></ul><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/pengzhenjin || github</span><br><span class="line">  E-Mail: mailto:562260994@qq.com || envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true        # 是否启用社交链接图标</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure><h3 id="设置友情链接"><a href="#设置友情链接" class="headerlink" title="设置友情链接"></a>设置友情链接</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">links_settings:</span><br><span class="line">  icon: link        # 友情链接图标</span><br><span class="line">  title: 友情链接    # 友情链接标题</span><br><span class="line">  layout: inline    # 友情链接布局样式，值：block、inline</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  Hexo: https://hexo.io/zh-cn</span><br><span class="line">  NexT: https://theme-next.org/docs</span><br></pre></td></tr></table></figure><h3 id="设置文章目录"><a href="#设置文章目录" class="headerlink" title="设置文章目录"></a>设置文章目录</h3><p>默认情况下，NexT 的文章目录显示在侧边栏中。<br>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true      # 是否使用文章目录</span><br><span class="line">  number: true      # 是否自动编号</span><br><span class="line">  wrap: false       # 如果标题超长，是否换行</span><br><span class="line">  expand_all: true  # 标题目录是否完全展开</span><br><span class="line">  max_depth: 6      # 最大层次深度</span><br></pre></td></tr></table></figure><h3 id="设置回到顶部按钮"><a href="#设置回到顶部按钮" class="headerlink" title="设置回到顶部按钮"></a>设置回到顶部按钮</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true         # 是否启用回到顶部按钮</span><br><span class="line">  sidebar: false       # 是否在侧边栏显示回到顶部按钮</span><br><span class="line">  scrollpercent: true  # 是否显示当前滚动进度百分比</span><br></pre></td></tr></table></figure><h3 id="设置站点建立时间"><a href="#设置站点建立时间" class="headerlink" title="设置站点建立时间"></a>设置站点建立时间</h3><p>这个时间将在站点的底部显示，例如 © 2018 - 2019。<br>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2018    # 站点建站年份，如果不配置，采用当前年份</span><br></pre></td></tr></table></figure><h3 id="设置站点底部图标"><a href="#设置站点底部图标" class="headerlink" title="设置站点底部图标"></a>设置站点底部图标</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon:                 </span><br><span class="line">    name: user        # 图标名称，See: https://fontawesome.com/v4.7.0/icons</span><br><span class="line">    animated: true    # 是否开启图标动画</span><br><span class="line">    color: &quot;#808080&quot;  # 图标颜色</span><br></pre></td></tr></table></figure><h3 id="设置站点底部版权声明"><a href="#设置站点底部版权声明" class="headerlink" title="设置站点底部版权声明"></a>设置站点底部版权声明</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  copyright: &apos;张三 版权所有&apos;    # 版权声明</span><br></pre></td></tr></table></figure><h3 id="设置站点底部平台信息"><a href="#设置站点底部平台信息" class="headerlink" title="设置站点底部平台信息"></a>设置站点底部平台信息</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  powered:          </span><br><span class="line">    enable: false   # 是否显示 Hexo 链接(Powered by Hexo)</span><br><span class="line">    version: false  # 是否显示 Hexo 链接后的版本信息(vX.X.X)</span><br><span class="line"></span><br><span class="line">  theme:    </span><br><span class="line">    enable: false   # 是否显示 Theme 链接信息(Theme - NexT.scheme)</span><br><span class="line">    version: false  # 是否显示 Theme 链接信息后的版本信息(vX.X.X)</span><br></pre></td></tr></table></figure><h3 id="设置站点底部备案信息"><a href="#设置站点底部备案信息" class="headerlink" title="设置站点底部备案信息"></a>设置站点底部备案信息</h3><p>默认情况下，NexT 不会显示 备案 信息。<br>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  beian:</span><br><span class="line">    enable: true</span><br><span class="line">    icp: 京ICP备 1234567890号-1</span><br><span class="line">    gongan_id: 1234567890</span><br><span class="line">    gongan_num: 京公网安备 1234567890号</span><br><span class="line">    gongan_icon_url: /uploads/beian.png</span><br></pre></td></tr></table></figure><h3 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:      </span><br><span class="line">  enable: true      # 是否启用自动摘要,不建议，请使用&lt;!-- more --&gt;进行精确控制</span><br><span class="line">  length: 150       # 从开始往后选取的摘要文字数量</span><br><span class="line"></span><br><span class="line">read_more_btn: true # 是否显示 “阅读全文” 按钮</span><br></pre></td></tr></table></figure><h3 id="设置文章-Meta"><a href="#设置文章-Meta" class="headerlink" title="设置文章 Meta"></a>设置文章 Meta</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_meta:          </span><br><span class="line">  item_text: true      # 是否显示文章 “发表于XX”</span><br><span class="line">  created_at: true     # 是否显示文章创建日期</span><br><span class="line">  updated_at:    </span><br><span class="line">    enable: false      # 是否显示文章修改日期</span><br><span class="line">    another_day: true</span><br><span class="line">  categories: true     # 是否显示文章所属分类</span><br></pre></td></tr></table></figure><h3 id="设置文章字数统计和阅读时长"><a href="#设置文章字数统计和阅读时长" class="headerlink" title="设置文章字数统计和阅读时长"></a>设置文章字数统计和阅读时长</h3><p>依赖第三方插件 <code>hexo-symbols-count-time</code>，See：<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a>。<br>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>npm install hexo-symbols-count-time --save</code> 命令安装插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>安装成功后，在 站点配置文件 <code>_config.yml</code> 中配置 <code>symbols_count_time</code> 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true            # 是否在文章 meta 中显示本文字数</span><br><span class="line">  time: true               # 是否在文章 meta 中显示阅读时长</span><br><span class="line">  total_symbols: true      # 是否在站点底部显示总字数</span><br><span class="line">  total_time: true         # 是否在站点底部显示阅读时长</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure><p>最后在 主题配置文件 <code>_config.yml</code> 中配置 <code>symbols_count_time</code> 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true  </span><br><span class="line">  item_text_post: true  </span><br><span class="line">  item_text_total: true </span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><h3 id="设置文章底部标签图标"><a href="#设置文章底部标签图标" class="headerlink" title="设置文章底部标签图标"></a>设置文章底部标签图标</h3><p>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag_icon: true    # 是否显示标签图标，默认显示 “#” 符号</span><br></pre></td></tr></table></figure><h3 id="设置文章微信订阅"><a href="#设置文章微信订阅" class="headerlink" title="设置文章微信订阅"></a>设置文章微信订阅</h3><p>获取您的微信二维码图片，将其放入 <code>hexo-size/source/uploads</code> 目录下，如果 uploads 目录不存在，则新建。<br>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wechat_subscriber:</span><br><span class="line">  enable: true</span><br><span class="line">  qcode: /uploads/wechat-qcode.jpg</span><br><span class="line">  description: Welcome to scan the WeChat Public Account QRcode and subscribe my blog!</span><br></pre></td></tr></table></figure><h3 id="设置打赏功能"><a href="#设置打赏功能" class="headerlink" title="设置打赏功能"></a>设置打赏功能</h3><p>获取您的微信、支付宝收款二维码图片，将其放入 <code>hexo-size/source/uploads</code> 目录下，如果 uploads 目录不存在，则新建。<br>编辑 主题配置文件 <code>_config.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward would be displayed in every article by default. # 如果为true，默认情况下，每篇文章都会显示奖励。</span><br><span class="line">  # You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  #comment: Donate comment here.</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /uploads/wechatpay.png      # 微信打赏二维码</span><br><span class="line">  alipay: /uploads/alipay.png            # 支付宝打赏二维码</span><br></pre></td></tr></table></figure><h3 id="设置相关文章功能"><a href="#设置相关文章功能" class="headerlink" title="设置相关文章功能"></a>设置相关文章功能</h3><p>依赖第三方插件 <code>hexo-related-popular-posts</code>，See：<a href="https://github.com/tea3/hexo-related-popular-posts" target="_blank" rel="noopener">https://github.com/tea3/hexo-related-popular-posts</a>。<br>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>npm install hexo-related-popular-posts --save</code> 命令安装插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure><p>安装成功后，在 主题配置文件 <code>_config.yml</code>中配置 <code>related_posts</code> 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">related_posts: </span><br><span class="line">  enable: true</span><br><span class="line">  title:                   # 默认情况下，NexT 使用 “相关文章” 作为标题，你也可以自定义</span><br><span class="line">  display_in_home: false   # 是否在主页面显示相关文章信息</span><br><span class="line">  params:</span><br><span class="line">    maxCount: 5            # 最多显示5篇相关文章信息，你也可以自定义</span><br></pre></td></tr></table></figure><h3 id="添加本地搜索"><a href="#添加本地搜索" class="headerlink" title="添加本地搜索"></a>添加本地搜索</h3><p>依赖第三方插件 <code>hexo-generator-search</code>，See：<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">https://github.com/wzpan/hexo-generator-search</a>。<br>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>npm install hexo-generator-search --save</code> 命令安装插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>安装成功后，在 站点配置文件 <code>_config.yml</code>中配置 <code>search</code> 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>最后在 主题配置文件 <code>_config.yml</code> 中配置 <code>local_search</code> 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # 如果值为&apos;auto&apos;，通过改变输入信息来触发搜索；如果值为&apos;manual&apos;，按enter键或search按钮来触发搜索</span><br><span class="line">  trigger: auto</span><br><span class="line"></span><br><span class="line">  # 显示每篇文章的前n个结果，通过设置为-1显示所有结果</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line"></span><br><span class="line">  # 是否将html字符串解义为可读的字符串</span><br><span class="line">  unescape: false</span><br><span class="line"></span><br><span class="line">  # 是否在页面加载时预加载搜索数据</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure><h3 id="设置Gitalk评论系统"><a href="#设置Gitalk评论系统" class="headerlink" title="设置Gitalk评论系统"></a>设置Gitalk评论系统</h3><p>Gitalk 是一个基于 Github Issue 的评论插件，使用 Github 帐号登录，界面干净整洁，支持 MarkDown 语法。</p><p>在自己的 Github 账号下创建一个仓库用来存放评论信息，仓库类型为 public 。<br><img src="screenshot_1.png" alt></p><p>创建 Github OAuth Application 用来授权登录，如果没有 点击这里注册一个新的 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">OAuth Application</a>。<br><img src="screenshot_2.png" alt></p><p>创建完成后，会生成一个 <code>Client ID</code> 和 <code>Client Secret</code><br><img src="screenshot_3.png" alt></p><p>最后在 主题配置文件 <code>_config.yml</code> 中配置 <code>gitalk</code> 信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: &apos;pengzhenjin&apos;                                   # GitHub账户名</span><br><span class="line">  repo: &apos;pengzhenjin.github.io&apos;                              # 存储评论的仓库名</span><br><span class="line">  client_id: &apos;2e07c2563cfbca1908e8&apos;                          # GitHub Application Client ID</span><br><span class="line">  client_secret: &apos;e7669e875bc3881cb2c3fea6ce057d03fd7afc5a&apos;  # GitHub Application Client Secret</span><br><span class="line">  admin_user: &apos;pengzhenjin&apos;                                  # GitHub账户名</span><br><span class="line">  distraction_free_mode: true</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客（二）：主题配置</title>
      <link href="/2018/08/16/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/08/16/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-NexT-？"><a href="#什么是-NexT-？" class="headerlink" title="什么是 NexT ？"></a>什么是 NexT ？</h3><p>Next 是专门为 Hexo 而定制的一款主题。它简单、清新、优雅，一个主题，三种外观，而且还支持多种语言，选您所好。</p><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><a id="more"></a><p>为了描述方便，在以下说明中，将前者称为 <span class="label info">站点配置文件</span> ， 后者称为 <span class="label primary">主题配置文件</span> 。</p><h3 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至 Hexo 站点根目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>在 Hexo 站点根目录下执行以下命令下载主题文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 Hexo 站点配置文件 <code>_config.yml</code> ， 找到 theme 字段，并将其值更改为 next。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后，验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 <code>hexo s --debug</code> 。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，检查站点是否正确运行。</p><div class="note success">            <p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse<br><img src="screenshot_2.png" alt></p>          </div><p>现在，你已经成功安装并启用了 NexT 主题。</p><h3 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h3><h4 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h4><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p><ul><li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白。</li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观。</li><li>Pisces - 双栏 Scheme，小家碧玉似的清新。</li><li>Gemini - 看起来像 Pisces ，但有明显的柱块与阴影，以显得更敏感的效果。</li></ul><p>Scheme 的切换通过更改 主题配置文件 <code>_config.yml</code> ，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><h4 id="设置基本信息"><a href="#设置基本信息" class="headerlink" title="设置基本信息"></a>设置基本信息</h4><p>编辑 站点配置文件 <code>_config.yml</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 张三的博客 # 站点名称</span><br><span class="line">subtitle:        # 站点副标题</span><br><span class="line">description:     # 站点描述</span><br><span class="line">language: zh-CN  # 设置网站语言为简体中文</span><br><span class="line">author: 张三     # 作者名称</span><br></pre></td></tr></table></figure><h4 id="设置菜单信息"><a href="#设置菜单信息" class="headerlink" title="设置菜单信息"></a>设置菜单信息</h4><p>菜单设置项的格式为 <code>Key: /link/ || icon</code> 。</p><ul><li>Key：菜单的名称(如：home、tags等)。</li><li>link：菜单的链接(如：tags、categories)。</li><li>icon：菜单的图标(如：tags、th等)，NexT 使用的是 <a href="https://fontawesome.com/?from=io" target="_blank" rel="noopener">Font Awesome</a> 提供的图标。</li></ul><p>编辑 主题配置文件 <code>_config.yml</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                   # 主页</span><br><span class="line">  tags: /tags/ || tags              # 标签</span><br><span class="line">  categories: /categories/ || th    # 分类</span><br><span class="line">  archives: /archives/ || archive   # 归档</span><br><span class="line">  #about: /about/ || user           # 关于</span><br><span class="line">  #schedule: /schedule/ || calendar # 日程表</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap # 站点地图</span><br><span class="line">  #commonweal: /404/ || heartbeat   # 公益404</span><br></pre></td></tr></table></figure><h4 id="设置侧栏信息"><a href="#设置侧栏信息" class="headerlink" title="设置侧栏信息"></a>设置侧栏信息</h4><p>编辑 主题配置文件 <code>_config.yml</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  position: left  # 侧栏位置，值：left、rigth</span><br><span class="line">  display: post  # 侧栏显示的时机（仅适用于 Muse、Mist 主题），值：post、always、hide、remove</span><br><span class="line">  offset: 12      # 侧栏距离顶部菜单条的距离（仅适用于 Pisces、Gemini 主题），值：xx像素</span><br><span class="line">  onmobile: false # 是否在窄屏设备上显示侧栏（仅适用于 Muse、Mist 主题），值：true、false</span><br></pre></td></tr></table></figure><h4 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h4><p>默认情况下，Hexo 使用 <code>hexo-site/themes/next/source/images</code> 目录中的 NexT favicons，不同的设备使用不同大小的 NexT favicons ，你也可以用你自己的图标替换它们。<br>您可以将您的 favicons 放在 <code>hexo-site/source/images</code> 目录下。<br>编辑 主题配置文件 <code>_config.yml</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  android_manifest: /images/manifest.json</span><br><span class="line">  ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure><h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>将您的头像图片放在 <code>themes/next/source/images</code> 目录下。<br>编辑 主题配置文件 <code>_config.yml</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: /images/avatar.png # 头像路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客（一）：基础安装</title>
      <link href="/2018/08/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/"/>
      <url>/2018/08/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着互联网浪潮的翻腾，国内外已经涌现出越来越多优秀的社交网站让用户分享信息更加便捷。然而，如果你是一个不甘堕落的工程狮或程序猿，是否也想要拥有一个属于自己的博客网站呢？如果你曾经或者现在正有这样的想法，那就请跟随这篇文章，发挥你的Geek精神，让你快速拥有自己的博客网站。文章内容如果有错误，请在文章下面的评论中留言指正，谢谢！</p><a id="more"></a><h3 id="什么是-Hexo-？"><a href="#什么是-Hexo-？" class="headerlink" title="什么是 Hexo ？"></a>什么是 Hexo ？</h3><p><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 使用 <a href="https://daringfireball.net/projects/markdown" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><img src="screenshot_1.jpg" alt></p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>在 <a href="https://nodejs.org/en/download" target="_blank" rel="noopener">Node.js 官网</a> 下载 6.9 及以上版本的安装包，并进行安装。 Node.js 的安装可以参考<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">这篇文章</a>。</p><p>安装完后，请在命令行中执行下列命令，查看 Node.js 版本，检验是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果显示版本号，如：<code>v10.10.3</code>，则表示安装成功，否则安装失败。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>在 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git官网</a> 下载安装包，并进行安装。Git的安装可以参考<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">这篇文章</a>。</p><p>安装完后，请在 Git Bash 中执行下列命令，查看 Git 版本，检验是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>如果显示版本号，如：<code>git version 2.22.0.windows.1</code>，则表示安装成功，否则安装失败。</p><p>请在 Git Bash 中执行下列命令，设置 user.name 和 user.email 配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的github用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的github注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>请在 Git Bash 中执行下列命令，生成 SSH 公钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续按3次回车键，会在用户目录下生成 id_rsa.pub 公钥文件。<br>然后在 Git Bash 中执行下列命令，复制 id_rsa.pub 公钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>最后在浏览器中打开你的 github 主页，进入 Settings –&gt; SSH and GPG keys –&gt; New SSH key，将刚复制的内容粘贴到 Key 那里，Title 随便填，点击 Add SSH key。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><font color="#FF0000">注意：以上命令肯能安装失败，原因是国内 npm 源有问题，请使用淘宝的 npm 镜像安装。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;# 如：hexo init blog</span><br><span class="line">cd &lt;folder&gt;# 如：cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules// 依赖安装目录</span><br><span class="line">├── scaffolds// 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。           </span><br><span class="line">├── source// 资源文件夹，用于放置图片、数据、文章等资源</span><br><span class="line">|   └── _posts// 文章目录</span><br><span class="line">├── themes// 主题文件夹。Hexo 会根据主题来生成静态页面。</span><br><span class="line">|└── landscape// 默认主题</span><br><span class="line">├── _config.yml// 网站的配置信息，您可以在此配置大部分的参数。</span><br><span class="line">└── package.json// 应用程序的信息。</span><br></pre></td></tr></table></figure><p>然后在站点根目录下执行如下命令，启动 Hex o内置的 Web 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g# 生成静态文件</span><br><span class="line">$ hexo s# 启动 Hexo 服务器</span><br></pre></td></tr></table></figure><p>最后在浏览器中输入地址 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到如下页面了。</p><p><img src="screenshot_2.png" alt></p><h3 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h3><p>在自己的 Github 账号下创建一个仓库，比如，您的GitHub账户名是 zhangsan ，那您创建的仓库名应该为：zhangsan.github.io ，这是固定写法（必须是您的用户名，其它名称无效），以后您的网站访问地址就是 <a href="http://www.zhangsan.github.io" target="_blank" rel="noopener">http://www.zhangsan.github.io</a> 。<br><img src="screenshot_3.png" alt></p><p>在 站点配置文件 <code>_config.yml</code>，配置部署服务器信息，您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:            </span><br><span class="line">- type: git</span><br><span class="line">  repo: git@github.com:pengzhenjin/zhangsan.github.io.git    # 部署到github平台</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: git@git.dev.tencent.com:zhangsan/zhangsan.git        # 部署到腾讯云开发者平台</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>在终端窗口下，定位到 Hexo 站点根目录下，使用 <code>hexo clean</code> 命令清除缓存文件，然后使用 <code>hexo generate</code> 命令生成静态文件，最后使用 <code>hexo deploy</code> 命令部署到服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 清除缓存文件</span><br><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line"># 生成静态文件</span><br><span class="line">$ hexo generate    # 简写：hexo g</span><br><span class="line"></span><br><span class="line"># 部署到服务器</span><br><span class="line">$ hexo deploy    # 简写：hexo d</span><br></pre></td></tr></table></figure><p>部署成功后，您就可以在浏览器中输入 <a href="http://www.zhangsan.github.io" target="_blank" rel="noopener">http://www.zhangsan.github.io</a> 网址就行访问了。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>域名是网站的入口，也是网站的第一印象，如果您想更个性一点，想拥有一个属于自己的域名，那就可以去申请一个域名，然后进行域名绑定，当然，您也可以不绑定域名，那就使用默认的 <a href="http://www.zhangsan.github.io" target="_blank" rel="noopener">http://www.zhangsan.github.io</a> 网址进行访问。</p><p>申请域名的地方有很多，这里推荐去阿里云申请。</p><p>申请成功后，登录阿里云控制台，进行域名解析。<br><img src="screenshot_4.png" alt></p><p>进入在您 GitHub，打开您创建的 zhangsan.github.io 仓库，进行 Settings 页面进行域名绑定。<br><img src="screenshot_5.png" alt><br><img src="screenshot_6.png" alt></p><p>最后就可以用您的域名进行访问了，赶紧试试吧！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：内部原理</title>
      <link href="/2018/06/12/Git%EF%BC%9A%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/12/Git%EF%BC%9A%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。 我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。 因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。</p><a id="more"></a><p>无论如何，既然已经读到了这里，就让我们开始吧。 首先要弄明白一点，从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。 马上你就会学到这意味着什么。</p><p>早期的 Git（主要是 1.5 之前的版本）的用户界面要比现在复杂的多，因为它更侧重于作为一个文件系统，而不是一个打磨过的版本控制系统。 不时会有一些陈词滥调抱怨早期那个晦涩复杂的 Git 用户界面；不过最近几年来，它已经被改进到不输于任何其他版本控制系统地清晰易用了。</p><p>内容寻址文件系统层是一套相当酷的东西，所以在本章我们会先讲解这部分内容。随后我们会学习传输机制和版本库管理任务——你迟早会和它们打交道。</p><h3 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h3><p>本书旨在讨论如何通过 checkout、branch、remote 等大约 30 个诸如此类动词形式的命令来玩转 Git。 然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“高层（porcelain）”命令。</p><p>本书前九章专注于探讨高层命令。 然而在本章，我们将主要面对底层命令。 因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。 多数底层命令并不面向最终用户：它们更适合作为新命令和自定义脚本的组成部分。</p><p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含了几乎所有 Git 存储和操作的对象。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 该目录的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -F1</span><br><span class="line">HEAD</span><br><span class="line">config*</span><br><span class="line">description</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure><p>该目录下可能还会包含其他文件，不过对于一个全新的 git init 版本库，这将是你看到的默认结构。 description 文件仅供 GitWeb 程序使用，我们无需关心。 config 文件包含项目特有的配置选项。 info 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。 hooks 目录包含客户端或服务端的钩子脚本（hook scripts），在 Git 钩子 中这部分话题已被详细探讨过。</p><p>剩下的四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。 这些条目是 Git 的核心组成部分。 objects 目录存储所有数据内容；refs 目录存储指向数据（分支）的提交对象的指针；HEAD 文件指示目前被检出的分支；index 文件保存暂存区信息。 我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</p><h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git 是一个内容寻址文件系统。 看起来很酷， 但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 可以通过底层命令 <code>hash-object</code> 来演示上述效果——该命令可将任意数据保存于 <code>.git</code> 目录，并返回相应的键值。 首先，我们需要初始化一个新的 Git 版本库，并确认 <code>objects</code> 目录为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git init test</span><br><span class="line">Initialized empty Git repository in /tmp/test/.git/</span><br><span class="line">$ cd test</span><br><span class="line">$ find .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br><span class="line">$ find .git/objects -type f</span><br></pre></td></tr></table></figure><p>可以看到 Git 对 <code>objects</code> 目录进行了初始化，并创建了 <code>pack</code> 和 <code>info</code> 子目录，但均为空。 接着，往 Git 数据库存入一些文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;test content&apos; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p><code>-w</code> 选项指示 <code>hash-object</code> 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。 <code>--stdin</code> 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。 现在我们可以查看 Git 是如何存储数据的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>可以在 <code>objects</code> 目录下看到一个文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code>cat-file</code> 指定 -p 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure><p>至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。 我们同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;version 1&apos; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure><p>接着，向文件里写入新内容，并再次将其存入数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;version 2&apos; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br></pre></td></tr></table></figure><p>数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>现在可以把文件内容恢复到第一个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">version 1</span><br></pre></td></tr></table></figure><p>或者第二个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">version 2</span><br></pre></td></tr></table></figure><p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）。 利用 <code>cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><h4 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h4><p>接下来要探讨的对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br></pre></td></tr></table></figure><p><code>master^{tree}</code> 语法表示 <code>master</code> 分支上最新的提交所指向的树对象。 请注意，<code>lib</code> 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure><p>从概念上讲，Git 内部存储的数据有点像这样：</p><p><img src="git-chapter-2/img1.png" alt>    </p><p>你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。 因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令 <code>update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。 利用该命令，可以把 test.txt 文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定 <code>--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）；同样必需的还有 <code>--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 \</span><br><span class="line">  83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure><p>本例中，我们指定的文件模式为 <code>100644</code>，表明这是一个普通文件。 其他选择包括：<code>100755</code>，表示一个可执行文件；<code>120000</code>，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p><p>现在，可以通过 <code>write-tree</code> 命令将暂存区内容写入一个树对象。 此处无需指定 <code>-w</code> 选项——如果某个树对象此前并不存在的话，当调用 <code>write-tree</code> 命令时，它会根据当前暂存区状态自动创建一个新的树对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</span><br></pre></td></tr></table></figure><p>不妨验证一下它确实是一个树对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p>接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;new file&apos; &gt; new.txt</span><br><span class="line">$ git update-index --cacheinfo 100644 \</span><br><span class="line">  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line">$ git update-index --add new.txt</span><br></pre></td></tr></table></figure><p>暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code>1f7a7a</code>）是先前值的“第二版”。 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。 本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p><p><img src="git-chapter-2/img2.png" alt>    </p><h4 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h4><p>现在有三个树对象，分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p><p>可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;first commit&apos; | git commit-tree d8329f</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br></pre></td></tr></table></figure><p>现在可以通过 <code>cat-file</code> 命令查看这个新提交对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line">committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的 <code>user.name</code> 和 <code>user.email</code> 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</p><p>接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;second commit&apos; | git commit-tree 0155eb -p fdf4fc3</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d</span><br><span class="line">$ echo &apos;third commit&apos;  | git commit-tree 3c4e9c -p cac0cab</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure><p>这三个提交对象分别指向之前创建的三个树对象快照中的一个。 现在，如果对最后一个提交的 SHA-1 值运行 <code>git log</code> 命令，会出乎意料的发现，你已有一个货真价实的、可由 <code>git log</code> 查看的 Git 提交历史了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat 1a410e</span><br><span class="line">commit 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:15:24 2009 -0700</span><br><span class="line"></span><br><span class="line">third commit</span><br><span class="line"></span><br><span class="line"> bak/test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit cac0cab538b970a37ea1e769cbbde608743bc96d</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:14:29 2009 -0700</span><br><span class="line"></span><br><span class="line">second commit</span><br><span class="line"></span><br><span class="line"> new.txt  | 1 +</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:09:34 2009 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>太神奇了： 就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下。 下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2</span><br><span class="line">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2</span><br><span class="line">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1</span><br><span class="line">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &apos;test content&apos;</span><br><span class="line">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1</span><br><span class="line">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt</span><br><span class="line">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</span><br></pre></td></tr></table></figure><p>如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p><p><img src="git-chapter-2/img3.png" alt>    </p><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>前文曾提及，在存储内容时，会有个头部信息一并被保存。 让我们略花些时间来看看 Git 是如何存储其对象的。 通过在 Ruby 脚本语言中交互式地演示，你将看到一个数据对象——本例中是字符串“what is up, doc?”——是如何被存储的。</p><p>可以通过 <code>irb</code> 命令启动 Ruby 的交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ irb</span><br><span class="line">&gt;&gt; content = &quot;what is up, doc?&quot;</span><br><span class="line">=&gt; &quot;what is up, doc?&quot;</span><br></pre></td></tr></table></figure><p>Git 以对象类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。 接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; header = &quot;blob #&#123;content.length&#125;\0&quot;</span><br><span class="line">=&gt; &quot;blob 16\u0000&quot;</span><br></pre></td></tr></table></figure><p>Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。 在 Ruby 中可以这样计算 SHA-1 值——先通过 <code>require</code> 命令导入 SHA-1 digest 库，然后对目标字符串调用 <code>Digest::SHA1.hexdigest()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; store = header + content</span><br><span class="line">=&gt; &quot;blob 16\u0000what is up, doc?&quot;</span><br><span class="line">&gt;&gt; require &apos;digest/sha1&apos;</span><br><span class="line">=&gt; true</span><br><span class="line">&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)</span><br><span class="line">=&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span><br></pre></td></tr></table></figure><p>Git 会通过 zlib 压缩这条新内容。在 Ruby 中可以借助 zlib 库做到这一点。 先导入相应的库，然后对目标内容调用 <code>Zlib::Deflate.deflate()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; require &apos;zlib&apos;</span><br><span class="line">=&gt; true</span><br><span class="line">&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)</span><br><span class="line">=&gt; &quot;x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D&quot;</span><br></pre></td></tr></table></figure><p>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在，可以通过 Ruby 中的 <code>FileUtils.mkdir_p()</code> 函数来创建它。 接着，通过 <code>File.open()</code> 打开这个文件。最后，对上一步中得到的文件句柄调用 <code>write()</code> 函数，以向目标文件写入之前那条 zlib 压缩过的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; path = &apos;.git/objects/&apos; + sha1[0,2] + &apos;/&apos; + sha1[2,38]</span><br><span class="line">=&gt; &quot;.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span><br><span class="line">&gt;&gt; require &apos;fileutils&apos;</span><br><span class="line">=&gt; true</span><br><span class="line">&gt;&gt; FileUtils.mkdir_p(File.dirname(path))</span><br><span class="line">=&gt; &quot;.git/objects/bd&quot;</span><br><span class="line">&gt;&gt; File.open(path, &apos;w&apos;) &#123; |f| f.write zlib_content &#125;</span><br><span class="line">=&gt; 32</span><br></pre></td></tr></table></figure><p>就是这样——你已创建了一个有效的 Git 数据对象。 所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p><h3 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h3><p>我们可以借助类似于 <code>git log 1a410e</code> 这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住 <code>1a410e</code> 是最后一个提交。 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p><p>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 <code>.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br><span class="line">$ find .git/refs -type f</span><br></pre></td></tr></table></figure><p>若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure><p>现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline  master</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><p>我们不提倡直接编辑引用文件。 如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成此事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure><p>这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。 若想在第二个提交上创建一个分支，可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/test cac0ca</span><br></pre></td></tr></table></figure><p>这个分支将只包含从第二个提交开始往前追溯的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline test</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><p>至此，我们的 Git 数据库从概念上看起来像这样：</p><p><img src="git-chapter-3/img1.png" alt></p><p>当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</p><h4 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h4><p>现在的问题是，当你执行 <code>git branch (branchname)</code> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。 如果查看 HEAD 文件的内容，一般而言我们看到的类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>如果执行 <code>git checkout test</code>，Git 会像这样更新 HEAD 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure><p>当我们执行 <code>git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p><p>你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code>symbolic-ref</code>。 可以借助此命令来查看 HEAD 引用对应的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD</span><br><span class="line">refs/heads/master</span><br></pre></td></tr></table></figure><p>同样可以设置 HEAD 引用的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure><p>不能把符号引用设置为一个不符合引用格式的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD test</span><br><span class="line">fatal: Refusing to point HEAD outside of refs/</span><br></pre></td></tr></table></figure><p>标签引用<br>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。 标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><p>正如 Git 基础 中所讨论的那样，存在两种类型的标签：附注标签和轻量标签。 可以像这样创建一个轻量标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</span><br></pre></td></tr></table></figure><p>这就是轻量标签的全部内容——一个固定的引用。 然而，一个附注标签则更复杂一些。 若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。 可以通过创建一个附注标签来验证这个过程（<code>-a</code> 选项指定了要创建的是一个附注标签）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m &apos;test tag&apos;</span><br></pre></td></tr></table></figure><p>下面是上述过程所建标签对象的 SHA-1 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br></pre></td></tr></table></figure><p>现在对该 SHA-1 值运行 <code>cat-file</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br><span class="line">object 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">type commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700</span><br><span class="line"></span><br><span class="line">test tag</span><br></pre></td></tr></table></figure><p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。 例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。 可以克隆一个 Git 版本库，然后通过执行下面的命令来在这个版本库中查看上述公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file blob junio-gpg-pub</span><br></pre></td></tr></table></figure><p>Linux 内核版本库同样有一个不指向提交对象的标签对象——首个被创建的标签对象所指向的是最初被引入版本库的那份内核源码所对应的树对象。</p><h4 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h4><p>我们将看到的第三种引用类型是远程引用（remote reference）。 如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code>refs/remotes</code> 目录下。 例如，你可以添加一个叫做 <code>origin</code> 的远程版本库，然后把 <code>master</code> 分支推送上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:schacon/simplegit-progit.git</span><br><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 11, done.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (7/7), 716 bytes, done.</span><br><span class="line">Total 7 (delta 2), reused 4 (delta 1)</span><br><span class="line">To git@github.com:schacon/simplegit-progit.git</span><br><span class="line">  a11bef0..ca82a6d  master -&gt; master</span><br></pre></td></tr></table></figure><p>此时，如果查看 <code>refs/remotes/origin/master</code> 文件，可以发现 <code>origin</code> 远程版本库的 <code>master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code>master</code> 分支所对应的 SHA-1 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/remotes/origin/master</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure><p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p><h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>让我们重新回到示例 Git 版本库的对象数据库。 目前为止，可以看到有 11 个对象——4 个数据对象、3 个树对象、3 个提交对象和 1 个标签对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2</span><br><span class="line">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2</span><br><span class="line">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1</span><br><span class="line">.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag</span><br><span class="line">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &apos;test content&apos;</span><br><span class="line">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1</span><br><span class="line">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt</span><br><span class="line">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</span><br></pre></td></tr></table></figure><p>Git 使用 zlib 压缩这些文件的内容，而且我们并没有存储太多东西，所以上文中的文件一共只占用了 925 字节。 接下来，我们会指引你添加一些大文件到版本库中，以此展示 Git 的一个很有趣的功能。 为了便于展示，我们要把之前在 Grit 库中用到过的 <code>repo.rb</code> 文件添加进来——这是一个大小约为 22K 的源代码文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb</span><br><span class="line">$ git add repo.rb</span><br><span class="line">$ git commit -m &apos;added repo.rb&apos;</span><br><span class="line">[master 484a592] added repo.rb</span><br><span class="line"> 3 files changed, 709 insertions(+), 2 deletions(-)</span><br><span class="line"> delete mode 100644 bak/test.txt</span><br><span class="line"> create mode 100644 repo.rb</span><br><span class="line"> rewrite test.txt (100%)</span><br></pre></td></tr></table></figure><p>如果你查看生成的树对象，可以看到 repo.rb 文件对应的数据对象的 SHA-1 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb</span><br><span class="line">100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</span><br></pre></td></tr></table></figure><p>接下来你可以使用 <code>git cat-file</code> 命令查看这个对象有多大：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5</span><br><span class="line">22044</span><br></pre></td></tr></table></figure><p>现在，稍微修改这个文件，然后看看会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;# testing&apos; &gt;&gt; repo.rb</span><br><span class="line">$ git commit -am &apos;modified repo a bit&apos;</span><br><span class="line">[master 2431da6] modified repo.rb a bit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>查看这个提交生成的树对象，你会看到一些有趣的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb</span><br><span class="line">100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</span><br></pre></td></tr></table></figure><p>repo.rb 对应一个与之前完全不同的数据对象，这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e</span><br><span class="line">22054</span><br></pre></td></tr></table></figure><p>你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象。 如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？</p><p>事实上 Git 可以那样做。 Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，你可以手动执行 <code>git gc</code> 命令让 Git 对对象进行打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">Counting objects: 18, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (14/14), done.</span><br><span class="line">Writing objects: 100% (18/18), done.</span><br><span class="line">Total 18 (delta 3), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>这个时候再查看 objects 目录，你会发现大部分的对象都不见了，与此同时出现了一对新文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">.git/objects/info/packs</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</span><br></pre></td></tr></table></figure><p>仍保留着的几个对象是未被任何提交记录引用的数据对象——在此例中是你之前创建的 “what is up, doc?” 和 “test content” 这两个示例数据对象。 因为你从没将它们添加至任何提交记录中，所以 Git 认为它们是悬空（dangling）的，不会将它们打包进新生成的包文件中。</p><p>剩下的文件是新创建的包文件和一个索引。 包文件包含了刚才从文件系统中移除的所有对象的内容。 索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。 有意思的是运行 gc 命令前磁盘上的对象大小约为 22K，而这个新生成的包文件大小仅有 7K。 通过打包对象减少了2/3的磁盘占用空间。</p><p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 <code>git verify-pack</code> 这个底层命令可以让你查看已打包的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12</span><br><span class="line">69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167</span><br><span class="line">80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319</span><br><span class="line">43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464</span><br><span class="line">092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610</span><br><span class="line">702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756</span><br><span class="line">d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874</span><br><span class="line">fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132</span><br><span class="line">deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178</span><br><span class="line">d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \</span><br><span class="line">  deef2e1b793907545e50a2ea2ddb5ba6c58c4506</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \</span><br><span class="line">  deef2e1b793907545e50a2ea2ddb5ba6c58c4506</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426</span><br><span class="line">fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445</span><br><span class="line">b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463</span><br><span class="line">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \</span><br><span class="line">  b042a60ef7dff760008df33cee372b945b6e884e</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282</span><br><span class="line">non delta: 15 objects</span><br><span class="line">chain length = 1: 3 objects</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</span><br></pre></td></tr></table></figure><p>此处，<code>033b4</code> 这个数据对象（即 repo.rb 文件的第一个版本，如果你还记得的话）引用了数据对象 <code>b042a</code>，即该文件的第二个版本。 命令输出内容的第三列显示的是各个对象在包文件中的大小，可以看到 <code>b042a</code> 占用了 22K 空间，而 <code>033b4</code> 仅占用 9 字节。 同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p><p>最妙之处是你可以随时重新打包。 Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 <code>git gc</code> 命令来这么做。</p><h3 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h3><p>纵观全书，我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。 假设你添加了这样一个远程版本库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure><p>上述命令会在你的 <code>.git/config</code> 文件中添加一个小节，并在其中指定远程版本库的名称（<code>origin</code>）、URL 和一个用于获取操作的引用规格（refspec）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/schacon/simplegit-progit</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><p>引用规格的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<code>&lt;dst&gt;</code> 是那些远程引用在本地所对应的位置。 <code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p><p>默认情况下，引用规格由 <code>git remote add</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。 所以，如果服务器上有一个 <code>master</code> 分支，我们可以在本地通过下面这种方式来访问该分支上的提交记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin/master</span><br><span class="line">$ git log remotes/origin/master</span><br><span class="line">$ git log refs/remotes/origin/master</span><br></pre></td></tr></table></figure><p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p><p>如果想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></table></figure><p>这仅是针对该远程版本库的 <code>git fetch</code> 操作的默认引用规格。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。 若要将远程的 <code>master</code> 分支拉到本地的 <code>origin/mymaster</code> 分支，可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster</span><br></pre></td></tr></table></figure><p>你也可以指定多个引用规格。 在命令行中，你可以按照如下的方式拉取多个分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster \</span><br><span class="line"> topic:refs/remotes/origin/topic</span><br><span class="line">From git@github.com:schacon/simplegit</span><br><span class="line"> ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)</span><br><span class="line"> * [new branch]      topic      -&gt; origin/topic</span><br></pre></td></tr></table></figure><p>在这个例子中，对 <code>master</code> 分支的拉取操作被拒绝，因为它不是一个可以快进的引用。 我们可以通过在引用规格之前指定 <code>+</code> 号来覆盖该规则。</p><p>你也可以在配置文件中指定多个用于获取操作的引用规格。 如果想在每次获取时都包括 <code>master</code> 和 <code>experiment</code> 分支，添加如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/schacon/simplegit-progit</span><br><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br></pre></td></tr></table></figure><p>我们不能在模式中使用部分通配符，所以像下面这样的引用规格是不合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/qa*:refs/remotes/origin/qa*</span><br></pre></td></tr></table></figure><p>但我们可以使用命名空间（或目录）来达到类似目的。 假设你有一个 QA 团队，他们推送了一系列分支，同时你只想要获取 <code>master</code> 和 QA 团队的所有分支而不关心其他任何分支，那么可以使用如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/schacon/simplegit-progit</span><br><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br></pre></td></tr></table></figure><p>如果项目的工作流很复杂，有 QA 团队推送分支、开发人员推送分支、集成团队推送并且在远程分支上展开协作，你就可以像这样（在本地）为这些分支创建各自的命名空间，非常方便。</p><h4 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h4><p>像上面这样从远程版本库获取已在命名空间中的引用当然很棒，但 QA 团队最初应该如何将他们的分支放入远程的 <code>qa/</code> 命名空间呢？ 我们可以通过引用规格推送来完成这个任务。</p><p>如果 QA 团队想把他们的 <code>master</code> 分支推送到远程服务器的 <code>qa/master</code> 分支上，可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure><p>如果他们希望 Git 每次运行 <code>git push origin</code> 时都像上面这样推送，可以在他们的配置文件中添加一条 <code>push</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/schacon/simplegit-progit</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure><p>正如刚才所指出的，这会让 <code>git push origin</code> 默认把本地 <code>master</code> 分支推送到远程 <code>qa/master</code> 分支。</p><h4 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h4><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :topic</span><br></pre></td></tr></table></figure><p>因为引用规格（的格式）是 <code>&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code>&lt;src&gt;</code> 留空，意味着把远程版本库的 <code>topic</code> 分支定义为空值，也就是删除它。</p><p>或者你可以使用更新的语法（自 Git v1.7.0以后可用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete topic</span><br></pre></td></tr></table></figure><h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。 本节将会带你快速浏览这两种协议的运作方式。</p><h4 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h4><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><p>让我们通过 simplegit 版本库来看看 <code>http-fetch</code> 的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http://server/simplegit-progit.git</span><br></pre></td></tr></table></figure><p>它做的第一件事就是拉取 <code>info/refs</code> 文件。 这个文件是通过 <code>update-server-info</code> 命令生成的，这也解释了在使用 HTTP 传输时，必须把它设置为 <code>post-receive</code> 钩子的原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET info/refs</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</span><br></pre></td></tr></table></figure><p>现在，你得到了一个远程引用和 SHA-1 值的列表。 接下来，你要确定 HEAD 引用是什么，这样你就知道在完成后应该被检出到工作目录的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>这说明在完成抓取后，你需要检出 <code>master</code> 分支。 这时，你就可以开始遍历处理了。 因为你是从 <code>info/refs</code> 文件中所提到的 <code>ca82a6</code> 提交对象开始的，所以你的首要操作是获取它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949</span><br><span class="line">(179 bytes of binary data)</span><br></pre></td></tr></table></figure><p>你取回了一个对象——这是一个在服务端以松散格式保存的对象，是你通过使用静态 HTTP GET 请求获取的。 你可以使用 zlib 解压缩它，去除其头部，查看提交记录的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700</span><br><span class="line">committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</span><br><span class="line"></span><br><span class="line">changed the version number</span><br></pre></td></tr></table></figure><p>接下来，你还要再获取两个对象，一个是树对象 <code>cfda3b</code>，它包含有我们刚刚获取的提交对象所指向的内容，另一个是它的父提交 <code>085bb3</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">(179 bytes of data)</span><br></pre></td></tr></table></figure><p>这样就取得了你的下一个提交对象。 再抓取树对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">(404 - Not Found)</span><br></pre></td></tr></table></figure><p>噢——看起来这个树对象在服务端并不以松散格式对象存在，所以你得到了一个 404 响应，代表在 HTTP 服务端没有找到该对象。 这有好几个可能的原因——这个对象可能在替代版本库里面，或者在包文件里面。 Git 会首先检查所有列出的替代版本库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/info/http-alternates</span><br><span class="line">(empty file)</span><br></pre></td></tr></table></figure><p>如果这返回了一个包含替代版本库 URL 的列表，那么 Git 就会去那些地址检查松散格式对象和文件——这是一种能让派生项目共享对象以节省磁盘的好方法。 然而，在这个例子中，没有列出可用的替代版本库。所以你所需要的对象肯定在某个包文件中。 要检查服务端有哪些可用的包文件，你需要获取 <code>objects/info/packs</code> 文件，这里面有一个包文件列表（它也是通过执行 <code>update-server-info</code> 所生成的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/info/packs</span><br><span class="line">P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</span><br></pre></td></tr></table></figure><p>服务端只有一个包文件，所以你要的对象显然就在里面。但是你要先检查它的索引文件以确认。 即使服务端有多个包文件，这也是很有用的，因为这样你就可以知道你所需要的对象是在哪一个包文件里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx</span><br><span class="line">(4k of binary data)</span><br></pre></td></tr></table></figure><p>现在你有这个包文件的索引，你可以查看你要的对象是否在里面——因为索引文件列出了这个包文件所包含的所有对象的 SHA-1 值，和该对象存在于包文件中的偏移量。 你的对象就在这里，接下来就是获取整个包文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</span><br><span class="line">(13k of binary data)</span><br></pre></td></tr></table></figure><p>现在你也有了你的树对象，你可以继续在提交记录上漫游。 它们全部都在这个你刚下载的包文件里面，所以你不用继续向服务端请求更多下载了。 Git 会将开始时下载的 HEAD 引用所指向的 master 分支检出到工作目录。</p><h4 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h4><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><h5 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h5><p>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</p><p><strong>SSH</strong><br>举例来说，在项目中使用命令 <code>git push origin master</code> 时, <code>origin</code> 是由基于 SSH 协议的 URL 所定义的。 Git 会运行 <code>send-pack</code> 进程，它会通过 SSH 连接你的服务器。 它会尝试通过 SSH 在服务端执行命令，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -x git@server &quot;git-receive-pack &apos;simplegit-progit.git&apos;&quot;</span><br><span class="line">00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \</span><br><span class="line">delete-refs side-band-64k quiet ofs-delta \</span><br><span class="line">agent=git/2:2.1.1+github-607-gfba4028 delete-refs</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p><code>git-receive-pack</code> 命令会立即为它所拥有的每一个引用发送一行响应——在这个例子中，就只有 <code>master</code> 分支和它的 SHA-1 值。 第一行响应中也包含了一个服务端能力的列表（这里是 <code>report-status、delete-refs</code> 和一些其它的，包括客户端的识别码）。</p><p>每一行以一个四位的十六进制值开始，用于指明本行的长度。 你看到第一行以 005b 开始，这在十六进制中表示 91，意味着第一行有 91 字节。 下一行以 003e 起始，也就是 62，所以下面需要读取 62 字节。 再下一行是 0000，表示服务端已完成了发送引用列表过程。</p><p>现在它知道了服务端的状态，你的 <code>send-pack</code> 进程会判断哪些提交记录是它所拥有但服务端没有的。 <code>send-pack</code> 会告知 <code>receive-pack</code> 这次推送将会更新的各个引用。 举个例子，如果你正在更新 <code>master</code> 分支，并且增加 <code>experiment</code> 分支，这个 <code>send-pack</code> 的响应将会是像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \</span><br><span class="line">refs/heads/master report-status</span><br><span class="line">006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \</span><br><span class="line">refs/heads/experiment</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p>Git 会为每一个将要更新的引用发送一行数据，包括该行长度，旧 SHA-1 值，新 SHA-1 值和将要更新的引用。 第一行也包括了客户端的能力。 这里的全为 0 的 SHA-1 值表示之前没有过这个引用——因为你正要添加新的 experiment 引用。 删除引用时，将会看到相反的情况：右边的 SHA-1 值全为 0。</p><p>接下来，客户端会发送一个包文件，它包含了所有服务端还没有的对象。 最后，服务端会以成功（或失败）响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000eunpack ok</span><br></pre></td></tr></table></figure><p><strong>HTTP(S)</strong><br>HTTPS 与 HTTP 相比较，除了在“握手”过程略有不同外，其他基本相似。 连接是从下面这个请求开始的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack</span><br><span class="line">001f# service=git-receive-pack</span><br><span class="line">00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master report-status \</span><br><span class="line">delete-refs side-band-64k quiet ofs-delta \</span><br><span class="line">agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p>这完成了客户端和服务端的第一次数据交换。 接下来客户端发起另一个请求，这次是一个 POST 请求，这个请求中包含了 <code>git-upload-pack</code> 提供的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; POST http://server/simplegit-progit.git/git-receive-pack</span><br></pre></td></tr></table></figure><p>这个 <code>POST</code> 请求的内容是 <code>send-pack</code> 的输出和相应的包文件。 服务端在收到请求后相应地作出成功或失败的 HTTP 响应。</p><h5 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h5><p>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code>进程，以协商后续传输的数据。</p><p><strong>SSH</strong><br>如果你通过 SSH 使用抓取功能，<code>fetch-pack</code> 会像这样运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -x git@server &quot;git-upload-pack &apos;simplegit-progit.git&apos;&quot;</span><br></pre></td></tr></table></figure><p>在 <code>fetch-pack</code> 连接后，<code>upload-pack</code> 会返回类似下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00dfca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \</span><br><span class="line">side-band side-band-64k ofs-delta shallow no-progress include-tag \</span><br><span class="line">multi_ack_detailed symref=HEAD:refs/heads/master \</span><br><span class="line">agent=git/2:2.1.1+github-607-gfba4028</span><br><span class="line">003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p>这与 <code>receive-pack</code> 的响应很相似，但是这里所包含的能力是不同的。 而且它还包含 HEAD 引用所指向内容（<code>symref=HEAD:refs/heads/master</code>），这样如果客户端执行的是克隆，它就会知道要检出什么。</p><p>这时候，<code>fetch-pack</code> 进程查看它自己所拥有的对象，并响应 “want” 和它需要的对象的 SHA-1 值。 它还会发送“have”和所有它已拥有的对象的 SHA-1 值。 在列表的最后，它还会发送“done”以通知 <code>upload-pack</code> 进程可以开始发送它所需对象的包文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta</span><br><span class="line">0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">0009done</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p><strong>HTTP(S)</strong><br>抓取操作的握手需要两个 HTTP 请求。 第一个是向和哑协议中相同的端点发送 <code>GET</code> 请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=&gt; GET $GIT_URL/info/refs?service=git-upload-pack</span><br><span class="line">001e# service=git-upload-pack</span><br><span class="line">00e7ca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \</span><br><span class="line">side-band side-band-64k ofs-delta shallow no-progress include-tag \</span><br><span class="line">multi_ack_detailed no-done symref=HEAD:refs/heads/master \</span><br><span class="line">agent=git/2:2.1.1+github-607-gfba4028</span><br><span class="line">003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p>这和通过 SSH 使用 <code>git-upload-pack</code> 是非常相似的，但是第二个数据交换则是一个单独的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0</span><br><span class="line">0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7</span><br><span class="line">0032have 441b40d833fdfa93eb2908e52742248faf0ee993</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><p>这个输出格式还是和前面一样的。 这个请求的响应包含了所需要的包文件，并指明成功或失败。</p><h4 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h4><p>这一章节是传输协议的一个概貌。 传输协议还有很多其它的特性，像是 <code>multi_ack</code> 或 <code>side-band</code>，但是这些内容已经超出了本书的范围。 我们希望能给你展示客户端和服务端之间的基本交互过程；如果你需要更多的相关知识，你可以参阅 Git 的源代码。</p><h3 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h3><p>有的时候，你需要对仓库进行清理——使它的结构变得更紧凑，或是对导入的仓库进行清理，或是恢复丢失的内容。 这个小节将会介绍这些情况中的一部分。</p><h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。 “gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p><p>可以像下面一样手动执行自动垃圾回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git gc --auto</span><br></pre></td></tr></table></figure><p>就像上面提到的，这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。 你可以通过修改 <code>gc.auto</code> 与 <code>gc.autopacklimit</code> 的设置来改动这些数值。</p><p><code>gc</code> 将会做的另一件事是打包你的引用到一个单独的文件。 假设你的仓库包含以下分支与标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs -type f</span><br><span class="line">.git/refs/heads/experiment</span><br><span class="line">.git/refs/heads/master</span><br><span class="line">.git/refs/tags/v1.0</span><br><span class="line">.git/refs/tags/v1.1</span><br></pre></td></tr></table></figure><p>如果你执行了 <code>git gc</code> 命令，<code>refs</code> 目录中将不会再有这些文件。 为了保证效率 Git 会将它们移动到名为 <code>.git/packed-refs</code> 的文件中，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/packed-refs</span><br><span class="line"># pack-refs with: peeled fully-peeled</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</span><br><span class="line">^1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure><p>如果你更新了引用，Git 并不会修改这个文件，而是向 <code>refs/heads</code> 创建一个新的文件。 为了获得指定引用的正确 SHA-1 值，Git 会首先在 <code>refs</code> 目录中查找指定的引用，然后再到 <code>packed-refs</code> 文件中查找。 所以，如果你在 <code>refs</code> 目录中找不到一个引用，那么它或许在 packed-<code>refs</code> 文件中。</p><p>注意这个文件的最后一行，它会以 <code>^</code> 开头。 这个符号表示它上一行的标签是附注标签，<code>^</code> 所在的那一行是附注标签指向的那个提交。</p><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？</p><p>下面的例子将硬重置你的测试仓库中的 master 分支到一个旧的提交，以此来恢复丢失的提交。 首先，让我们看看你的仓库现在在什么地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</span><br><span class="line">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><p>现在，我们将 <code>master</code> 分支硬重置到第三次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">HEAD is now at 1a410ef third commit</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><p>现在顶部的两个提交已经丢失了——没有分支指向这些提交。 你需要找出最后一次提交的 SHA-1 然后增加一个指向它的分支。 窍门就是找到最后一次的提交的 SHA-1 ——但是估计你记不起来了，对吗？</p><p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 <code>git update-ref</code> 命令更新，我们在 Git 引用 有提到使用这个命令而不是是直接将 SHA-1 的值写入引用文件中的原因。 你可以在任何时候通过执行 <code>git reflog</code> 命令来了解你曾经做过什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">1a410ef HEAD@&#123;0&#125;: reset: moving to 1a410ef</span><br><span class="line">ab1afef HEAD@&#123;1&#125;: commit: modified repo.rb a bit</span><br><span class="line">484a592 HEAD@&#123;2&#125;: commit: added repo.rb</span><br></pre></td></tr></table></figure><p>这里可以看到我们已经检出的两次提交，然而并没有足够多的信息。 为了使显示的信息更加有用，我们可以执行 <code>git log -g</code>，这个命令会以标准日志的格式输出引用日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log -g</span><br><span class="line">commit 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line">Reflog: HEAD@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: updating HEAD</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:22:37 2009 -0700</span><br><span class="line"></span><br><span class="line">third commit</span><br><span class="line"></span><br><span class="line">commit ab1afef80fac8e34258ff41fc1b867c702daa24b</span><br><span class="line">Reflog: HEAD@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: updating HEAD</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri May 22 18:15:24 2009 -0700</span><br><span class="line"></span><br><span class="line">       modified repo.rb a bit</span><br></pre></td></tr></table></figure><p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。 例如，你可以创建一个名为 <code>recover-branch</code> 的分支指向这个提交（ab1afef）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch recover-branch ab1afef</span><br><span class="line">$ git log --pretty=oneline recover-branch</span><br><span class="line">ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit</span><br><span class="line">484a59275031909e19aadb7c92262719cfcdf19a added repo.rb</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><p>不错，现在有一个名为 <code>recover-branch</code> 的分支是你的 <code>master</code> 分支曾经指向的地方，再一次使得前两次提交可到达了。 接下来，假设你丢失的提交因为某些原因不在引用日志中——我们可以通过移除 <code>recover-branch</code> 分支并删除引用日志来模拟这种情况。 现在前两次提交又不被任何分支指向了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D recover-branch</span><br><span class="line">$ rm -Rf .git/logs/</span><br></pre></td></tr></table></figure><p>由于引用日志数据存放在 <code>.git/logs/</code> 目录中，现在你已经没有引用日志了。 这时该如何恢复那次提交？ 一种方式是使用 <code>git fsck</code> 实用工具，将会检查数据库的完整性。 如果使用一个 <code>--full</code> 选项运行它，它会向你显示出所有没有被其他对象指向的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --full</span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (18/18), done.</span><br><span class="line">dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b</span><br><span class="line">dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9</span><br><span class="line">dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</span><br></pre></td></tr></table></figure><p>在这个例子中，你可以在 “dangling commit” 后看到你丢失的提交。 现在你可以用和之前相同的方法恢复这个提交，也就是添加一个指向这个提交的分支。</p><h4 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h4><p>Git 有很多很棒的功能，但是其中一个特性会导致问题，<code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。 如果所有的东西都是源代码那么这很好，因为 Git 被高度优化来有效地存储这种数据。 然而，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。 之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p><p>当你迁移 Subversion 或 Perforce 仓库到 Git 的时候，这会是一个严重的问题。 因为这些版本控制系统并不下载所有的历史文件，所以这种文件所带来的问题比较少。 如果你从其他的版本控制系统迁移到 Git 时发现仓库比预期的大得多，那么你就需要找到并移除这些大文件。</p><p><strong>警告：这个操作对提交历史的修改是破坏性的</strong>。 它会从你必须修改或移除一个大文件引用最早的树对象开始重写每一次提交。 如果你在导入仓库后，在任何人开始基于这些提交工作前执行这个操作，那么将不会有任何问题——否则，你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上。</p><p>为了演示，我们将添加一个大文件到测试仓库中，并在下一次提交中删除它，现在我们需要找到它，并将它从仓库中永久删除。 首先，添加一个大文件到仓库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz</span><br><span class="line">$ git add git.tgz</span><br><span class="line">$ git commit -m &apos;add git tarball&apos;</span><br><span class="line">[master 7b30847] add git tarball</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 git.tgz</span><br></pre></td></tr></table></figure><p>哎呀——其实这个项目并不需要这个巨大的压缩文件。 现在我们将它移除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm git.tgz</span><br><span class="line">rm &apos;git.tgz&apos;</span><br><span class="line">$ git commit -m &apos;oops - removed large tarball&apos;</span><br><span class="line">[master dadf725] oops - removed large tarball</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 git.tgz</span><br></pre></td></tr></table></figure><p>现在，我们执行 <code>gc</code> 来查看数据库占用了多少空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">Counting objects: 17, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (13/13), done.</span><br><span class="line">Writing objects: 100% (17/17), done.</span><br><span class="line">Total 17 (delta 1), reused 10 (delta 0)</span><br></pre></td></tr></table></figure><p>你也可以执行 <code>count-objects</code> 命令来快速的查看占用空间大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git count-objects -v</span><br><span class="line">count: 7</span><br><span class="line">size: 32</span><br><span class="line">in-pack: 17</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 4868</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><p><code>size-pack</code> 的数值指的是你的包文件以 KB 为单位计算的大小，所以你大约占用了 5MB 的空间。 在最后一次提交前，使用了不到 2KB ——显然，从之前的提交中移除文件并不能从历史中移除它。 每一次有人克隆这个仓库时，他们将必须克隆所有的 5MB 来获得这个微型项目，只因为你意外地添加了一个大文件。 现在来让我们彻底的移除这个文件。</p><p>首先你必须找到它。 在本例中，你已经知道是哪个文件了。 但是假设你不知道；该如何找出哪个文件或哪些文件占用了如此多的空间？ 如果你执行 <code>git gc</code> 命令，所有的对象将被放入一个包文件中，你可以通过运行 <code>git verify-pack</code> 命令，然后对输出内容的第三列（即文件大小）进行排序，从而找出这个大文件。 你也可以将这个命令的执行结果通过管道传送给 <code>tail</code> 命令，因为你只需要找到列在最后的几个大对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \</span><br><span class="line">  | sort -k 3 -n \</span><br><span class="line">  | tail -3</span><br><span class="line">dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12</span><br><span class="line">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696</span><br><span class="line">82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</span><br></pre></td></tr></table></figure><p>你可以看到这个大对象出现在返回结果的最底部：占用 5MB 空间。 为了找出具体是哪个文件，可以使用 <code>rev-list</code> 命令，我们在 指定特殊的提交信息格式 中曾提到过。 如果你传递 <code>--objects</code> 参数给 <code>rev-list</code> 命令，它就会列出所有提交的 SHA-1、数据对象的 SHA-1 和与它们相关联的文件路径。 可以使用以下命令来找出你的数据对象的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-list --objects --all | grep 82c99a3</span><br><span class="line">82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</span><br></pre></td></tr></table></figure><p>现在，你只需要从过去所有的树中移除这个文件。 使用以下命令可以轻松地查看哪些提交对这个文件产生改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --branches -- git.tgz</span><br><span class="line">dadf725 oops - removed large tarball</span><br><span class="line">7b30847 add git tarball</span><br></pre></td></tr></table></figure><p>现在，你必须重写 <code>7b30847</code> 提交之后的所有提交来从 Git 历史中完全移除这个文件。 为了执行这个操作，我们要使用 <code>filter-branch</code> 命令，这个命令在 重写历史 中也使用过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --index-filter \</span><br><span class="line">  &apos;git rm --ignore-unmatch --cached git.tgz&apos; -- 7b30847^..</span><br><span class="line">Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm &apos;git.tgz&apos;</span><br><span class="line">Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)</span><br><span class="line">Ref &apos;refs/heads/master&apos; was rewritten</span><br></pre></td></tr></table></figure><p><code>--index-filter</code> 选项类似于在 重写历史 中提到的的 <code>--tree-filter</code> 选项，不过这个选项并不会让命令将修改在硬盘上检出的文件，而只是修改在暂存区或索引中的文件。</p><p>你必须使用 <code>git rm --cached</code> 命令来移除文件，而不是通过类似 <code>rm file</code> 的命令——因为你需要从索引中移除它，而不是磁盘中。 还有一个原因是速度—— Git 在运行过滤器时，并不会检出每个修订版本到磁盘中，所以这个过程会非常快。 如果愿意的话，你也可以通过 <code>--tree-filter</code> 选项来完成同样的任务。 <code>git rm</code> 命令的 <code>--ignore-unmatch</code> 选项告诉命令：如果尝试删除的模式不存在时，不提示错误。 最后，使用 <code>filter-branch</code> 选项来重写自 7b30847 提交以来的历史，也就是这个问题产生的地方。 否则，这个命令会从最旧的提交开始，这将会花费许多不必要的时间。</p><p>你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 <code>.git/refs/original</code> 通过 <code>filter-branch</code> 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据库。 在重新打包前需要移除任何包含指向那些旧提交的指针的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf .git/refs/original</span><br><span class="line">$ rm -Rf .git/logs/</span><br><span class="line">$ git gc</span><br><span class="line">Counting objects: 15, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (11/11), done.</span><br><span class="line">Writing objects: 100% (15/15), done.</span><br><span class="line">Total 15 (delta 1), reused 12 (delta 0)</span><br></pre></td></tr></table></figure><p>让我们看看你省了多少空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git count-objects -v</span><br><span class="line">count: 11</span><br><span class="line">size: 4904</span><br><span class="line">in-pack: 15</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 8</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><p>打包的仓库大小下降到了 8K，比 5MB 好很多。 可以从 size 的值看出，这个大文件还在你的松散对象中，并没有消失；但是它不会在推送或接下来的克隆中出现，这才是最重要的。 如果真的想要删除它，可以通过有 <code>--expire</code> 选项的 <code>git prune</code> 命令来完全地移除那个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git prune --expire now</span><br><span class="line">$ git count-objects -v</span><br><span class="line">count: 0</span><br><span class="line">size: 0</span><br><span class="line">in-pack: 15</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 8</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Git 总是在一个 <code>bash shell</code> 中运行，并借助一些 shell 环境变量来决定它的运行方式。 有时候，知道它们是什么以及它们如何让 Git 按照你想要的方式去运行会很有用。 这里不会列出所有的 Git 环境变量，但我们会涉及最有的那部分。</p><h4 id="全局行为"><a href="#全局行为" class="headerlink" title="全局行为"></a>全局行为</h4><p>像通常的程序一样，Git 的常规行为依赖于环境变量。</p><p><strong>GIT_EXEC_PATH</strong> 决定 Git 到哪找它的子程序 （像 <code>git-commit</code>, <code>git-diff</code> 等等）。 你可以用 <code>git --exec-path</code> 来查看当前设置。</p><p>通常不会考虑修改 <strong>HOME</strong> 这个变量（太多其它东西都依赖它），这是 Git 查找全局配置文件的地方。 如果你想要一个包括全局配置的真正的便携版 Git， 你可以在便携版 Git 的 shell 配置中覆盖 HOME 设置。</p><p><strong>PREFIX</strong> 也类似，除了用于系统级别的配置。 Git 在 <code>$PREFIX/etc/gitconfig</code> 查找此文件。</p><p>如果设置了 <strong>GIT_CONFIG_NOSYSTEM</strong>，就禁用系统级别的配置文件。 这在系统配置影响了你的命令，而你又无权限修改的时候很有用。</p><p><strong>GIT_PAGER</strong> 控制在命令行上显示多页输出的程序。 如果这个没有设置，就会用 <code>PAGER</code> 。</p><p><strong>GIT_EDITOR</strong> 当用户需要编辑一些文本（比如提交信息）时， Git 会启动这个编辑器。 如果没设置，就会用 <code>EDITOR</code> 。</p><h4 id="版本库位置"><a href="#版本库位置" class="headerlink" title="版本库位置"></a>版本库位置</h4><p>Git 用了几个变量来确定它如何与当前版本库交互。</p><p><strong>GIT_DIR</strong> 是 <code>.git</code> 目录的位置。 如果这个没有设置， Git 会按照目录树逐层向上查找 <code>.git</code> 目录，直到到达 <code>~</code> 或 <code>/</code>。</p><p><strong>GIT_CEILING_DIRECTORIES</strong> 控制查找 <code>.git</code> 目录的行为。 如果你访问加载很慢的目录（如那些磁带机上的或通过网络连接访问的），你可能会想让 Git 早点停止尝试，尤其是 shell 构建时调用了 Git 。</p><p><strong>GIT_WORK_TREE</strong> 是非空版本库的工作目录的根路径。 如果没指定，就使用 <code>$GIT_DIR</code> 的父目录。</p><p><strong>GIT_INDEX_FILE</strong> 是索引文件的路径（只有非空版本库有）。</p><p><strong>GIT_OBJECT_DIRECTORY</strong> 用来指定 <code>.git/objects</code> 目录的位置。</p><p><strong>GIT_ALTERNATE_OBJECT_DIRECTORIES</strong> 一个冒号分割的列表（格式类似 <code>/dir/one:/dir/two:…</code>）用来告诉 Git 到哪里去找不在 <code>GIT_OBJECT_DIRECTORY</code> 目录中的对象。 如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。</p><h4 id="路径规则"><a href="#路径规则" class="headerlink" title="路径规则"></a>路径规则</h4><p>所谓 “pathspec” 是指你在 Git 中如何指定路径，包括通配符的使用。 它们会在 <code>.gitignore</code> 文件中用到，命令行里也会用到（<code>git add *.c</code>）。</p><p><strong>GIT_GLOB_PATHSPECS and GIT_NOGLOB_PATHSPECS</strong> 控制通配符在路径规则中的默认行为。 如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。意思是 <code>*.c</code> 只会匹配 文件名是 <code>“*.c”</code> 的文件，而不是以 <code>.c</code> 结尾的文件。 你可以在各个路径规格中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 <code>:(glob)*.c</code> 。</p><p><strong>GIT_LITERAL_PATHSPECS</strong> 禁用上面的两种行为；通配符将不能用，前缀覆盖也不能用。</p><p><strong>GIT_ICASE_PATHSPECS</strong> 让所有的路径规格忽略大小写。</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p><p><strong>GIT_AUTHOR_NAME</strong> 是 “author” 字段的可读名字。</p><p><strong>GIT_AUTHOR_EMAIL</strong> 是 “author” 字段的邮件。</p><p><strong>GIT_AUTHOR_DATE</strong> 是 “author” 字段的时间戳。</p><p><strong>GIT_COMMITTER_NAME</strong> 是 “committer” 字段的可读名字。</p><p><strong>GIT_COMMITTER_EMAIL</strong> 是 “committer” 字段的邮件。</p><p><strong>GIT_COMMITTER_DATE</strong> 是 “committer” 字段的时间戳。</p><p>如果 <code>user.email</code> 没有配置， 就会用到 <strong>EMAIL</strong> 指定的邮件地址。 如果 这个 也没有设置， Git 继续回退使用系统用户和主机名。</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>Git 使用 <code>curl</code> 库通过 HTTP 来完成网络操作， 所以 <strong>GIT_CURL_VERBOSE</strong> 告诉 Git 显示所有由那个库产生的消息。 这跟在命令行执行 <code>curl -v</code> 差不多。</p><p><strong>GIT_SSL_NO_VERIFY</strong> 告诉 Git 不用验证 SSL 证书。 这在有些时候是需要的， 例如你用一个自己签名的证书通过 HTTPS 来提供 Git 服务， 或者你正在搭建 Git 服务器，还没有安装完全的证书。</p><p>如果 Git 操作在网速低于 <strong>GIT_HTTP_LOW_SPEED_LIMIT</strong> 字节／秒，并且持续 <strong>GIT_HTTP_LOW_SPEED_TIME</strong> 秒以上的时间，Git 会终止那个操作。 这些值会覆盖 <code>http.lowSpeedLimit</code> 和 <code>http.lowSpeedTime</code> 配置的值。</p><p><strong>GIT_HTTP_USER_AGENT</strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。 默认值类似于 <code>git/2.0.0</code> 。</p><h4 id="比较和合并"><a href="#比较和合并" class="headerlink" title="比较和合并"></a>比较和合并</h4><p><strong>GIT_DIFF_OPTS</strong> 这个有点起错名字了。 有效值仅支持 <code>-u&lt;n&gt;</code> 或 <code>--unified=&lt;n&gt;</code>，用来控制在 <code>git diff</code> 命令中显示的内容行数。</p><p><strong>GIT_EXTERNAL_DIFF</strong> 用来覆盖 <code>diff.external</code> 配置的值。 如果设置了这个值， 当执行 <code>git diff</code> 时，Git 会调用该程序。</p><p><strong>GIT_DIFF_PATH_COUNTER</strong> 和 <strong>GIT_DIFF_PATH_TOTAL</strong> 对于 <code>GIT_EXTERNAL_DIFF</code> 或 <code>diff.external</code> 指定的程序有用。 前者表示在一系列文件中哪个是被比较的（从 1 开始），后者表示每批文件的总数。</p><p><strong>GIT_MERGE_VERBOSITY</strong> 控制递归合并策略的输出。 允许的值有下面这些：</p><ul><li><p>0 什么都不输出，除了可能会有一个错误信息。</p></li><li><p>1 只显示冲突。</p></li><li><p>2 还显示文件改变。</p></li><li><p>3 显示因为没有改变被跳过的文件。</p></li><li><p>4 显示处理的所有路径。</p></li><li><p>5 显示详细的调试信息。</p></li></ul><p>默认值是 2。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>想 <strong>真正地</strong> 知道 Git 正在做什么? Git 内置了相当完整的跟踪信息，你需要做的就是把它们打开。 这些变量的可用值如下：</p><ul><li><p>“true”“1” 或 “2”——跟踪类别写到标准错误输出。</p></li><li><p>以 / 开头的绝对路径——跟踪输出会被写到那个文件。</p></li></ul><p><strong>GIT_TRACE</strong> 控制常规跟踪，它并不适用于特殊情况。 它跟踪的范围包括别名的展开和其他子程序的委托。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE=true git lga</span><br><span class="line">20:12:49.877982 git.c:554               trace: exec: &apos;git-lga&apos;</span><br><span class="line">20:12:49.878369 run-command.c:341       trace: run_command: &apos;git-lga&apos;</span><br><span class="line">20:12:49.879529 git.c:282               trace: alias expansion: lga =&gt; &apos;log&apos; &apos;--graph&apos; &apos;--pretty=oneline&apos; &apos;--abbrev-commit&apos; &apos;--decorate&apos; &apos;--all&apos;</span><br><span class="line">20:12:49.879885 git.c:349               trace: built-in: git &apos;log&apos; &apos;--graph&apos; &apos;--pretty=oneline&apos; &apos;--abbrev-commit&apos; &apos;--decorate&apos; &apos;--all&apos;</span><br><span class="line">20:12:49.899217 run-command.c:341       trace: run_command: &apos;less&apos;</span><br><span class="line">20:12:49.899675 run-command.c:192       trace: exec: &apos;less&apos;</span><br></pre></td></tr></table></figure><p><strong>GIT_TRACE_PACK_ACCESS</strong> 控制访问打包文件的跟踪信息。 第一个字段是被访问的打包文件，第二个是文件的偏移量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_PACK_ACCESS=true git status</span><br><span class="line">20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 12</span><br><span class="line">20:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 34662</span><br><span class="line">20:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175</span><br><span class="line"># […]</span><br><span class="line">20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 56914983</span><br><span class="line">20:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p><strong>GIT_TRACE_PACKET</strong> 打开网络操作包级别的跟踪信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_PACKET=true git ls-remote origin</span><br><span class="line">20:15:14.867043 pkt-line.c:46           packet:          git&lt; # service=git-upload-pack</span><br><span class="line">20:15:14.867071 pkt-line.c:46           packet:          git&lt; 0000</span><br><span class="line">20:15:14.867079 pkt-line.c:46           packet:          git&lt; 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.4</span><br><span class="line">20:15:14.867088 pkt-line.c:46           packet:          git&lt; 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name</span><br><span class="line">20:15:14.867094 pkt-line.c:46           packet:          git&lt; 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config</span><br><span class="line"># […]</span><br></pre></td></tr></table></figure><p><strong>GIT_TRACE_PERFORMANCE</strong> 控制性能数据的日志打印。 输出显示了每个 Git 命令调用花费的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_PERFORMANCE=true git gc</span><br><span class="line">20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: &apos;git&apos; &apos;pack-refs&apos; &apos;--all&apos; &apos;--prune&apos;</span><br><span class="line">20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: &apos;git&apos; &apos;reflog&apos; &apos;expire&apos; &apos;--all&apos;</span><br><span class="line">Counting objects: 170994, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (43413/43413), done.</span><br><span class="line">Writing objects: 100% (170994/170994), done.</span><br><span class="line">Total 170994 (delta 126176), reused 170524 (delta 125706)</span><br><span class="line">20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: &apos;git&apos; &apos;pack-objects&apos; &apos;--keep-true-parents&apos; &apos;--honor-pack-keep&apos; &apos;--non-empty&apos; &apos;--all&apos; &apos;--reflog&apos; &apos;--unpack-unreachable=2.weeks.ago&apos; &apos;--local&apos; &apos;--delta-base-offset&apos; &apos;.git/objects/pack/.tmp-49190-pack&apos;</span><br><span class="line">20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: &apos;git&apos; &apos;prune-packed&apos;</span><br><span class="line">20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: &apos;git&apos; &apos;update-server-info&apos;</span><br><span class="line">20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: &apos;git&apos; &apos;repack&apos; &apos;-d&apos; &apos;-l&apos; &apos;-A&apos; &apos;--unpack-unreachable=2.weeks.ago&apos;</span><br><span class="line">Checking connectivity: 170994, done.</span><br><span class="line">20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: &apos;git&apos; &apos;prune&apos; &apos;--expire&apos; &apos;2.weeks.ago&apos;</span><br><span class="line">20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: &apos;git&apos; &apos;rerere&apos; &apos;gc&apos;</span><br><span class="line">20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: &apos;git&apos; &apos;gc&apos;</span><br></pre></td></tr></table></figure><p><strong>GIT_TRACE_SETUP</strong> 显示 Git 发现的关于版本库和交互环境的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE_SETUP=true git status</span><br><span class="line">20:19:47.086765 trace.c:315             setup: git_dir: .git</span><br><span class="line">20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git</span><br><span class="line">20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git</span><br><span class="line">20:19:47.087194 trace.c:318             setup: prefix: (null)</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>如果指定了 <strong>GIT_SSH</strong>， Git 连接 SSH 主机时会用指定的程序代替 <code>ssh</code> 。 它会被用 <code>$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code> 的命令方式调用。 这不是配置定制 ssh 调用方式的最简单的方法; 它不支持额外的命令行参数， 所以你必须写一个封装脚本然后让 <code>GIT_SSH</code> 指向它。 可能用 <code>~/.ssh/config</code> 会更简单。</p><p><strong>GIT_ASKPASS</strong> 覆盖了 <code>core.askpass</code> 配置。 这是 Git 需要向用户请求验证时用到的程序，它接受一个文本提示作为命令行参数，并在 <code>stdout</code> 中返回应答。 </p><p><strong>GIT_NAMESPACE</strong> 控制有命令空间的引用的访问，与 <code>--namespace</code> 标志是相同的。 这主要在服务器端有用， 如果你想在一个版本库中存储单个版本库的多个 fork, 只要保持引用是隔离的就可以。</p><p><strong>GIT_FLUSH</strong> 强制 Git 在向标准输出增量写入时使用没有缓存的 I/O。 设置为 1 让 Git 刷新更多， 设置为 0 则使所有的输出被缓存。 默认值（若此变量未设置）是根据活动和输出模式的不同选择合适的缓存方案。</p><p><strong>GIT_REFLOG_ACTION</strong> 让你可以指定描述性的文字写到 reflog 中。 这有个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_REFLOG_ACTION=&quot;my action&quot; git commit --allow-empty -m &apos;my message&apos;</span><br><span class="line">[master 9e3d55a] my message</span><br><span class="line">$ git reflog -1</span><br><span class="line">9e3d55a HEAD@&#123;0&#125;: my action: my message</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：自定义</title>
      <link href="/2018/06/11/Git%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
      <url>/2018/06/11/Git%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>到目前为止，我们已经阐述了 Git 基本的运作机制和使用方式，介绍了许多 Git 提供的工具来帮助你简单且有效地使用它。 在本章，我们将演示如何借助 Git 的一些重要的配置方法和钩子机制，来满足自定义的需求。 通过这些工具，它会和你、你的公司或你的团队配合得天衣无缝。</p><p>你在 Git 基础 中看到，可以用 git config 配置 Git。 首先要做的事情就是设置你的名字和邮件地址：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>现在，你会了解到许多更有趣的选项，并用类似的方式来定制 Git。</p><p>首先，快速回忆下：Git 使用一系列配置文件来保存你自定义的行为。 它首先会查找 <code>/etc/gitconfig</code> 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 <code>git config</code>，它就会读写该文件。</p><p>接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（或者 <code>~/.config/git/config</code> 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。</p><p>最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（<code>.git/config</code>）。 这个文件中的值只对该版本库有效。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 <code>.git/config</code> 中的值会覆盖掉 <code>/etc/gitconfig</code> 中所对应的值。</p><h4 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h4><p>Git 能够识别的配置项分为两大类：客户端和服务器端。 其中大部分属于客户端配置 —— 可以依你个人的工作偏好进行配置。 尽管 Git 支持的选项 繁多，但其中大部分仅仅在某些罕见的情况下有意义。 我们只讲述最平常和最有用的选项。 如果想得到你当前版本的 Git 支持的选项列表，请运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man git-config</span><br></pre></td></tr></table></figure><p>这个命令列出了所有可用的选项，以及与之相关的介绍。 你也可以在 [<a href="http://git-scm.com/docs/git-config.html]" target="_blank" rel="noopener">http://git-scm.com/docs/git-config.html]</a>(这个命令列出了所有可用的选项，以及与之相关的介绍。 你也可以在 <a href="http://git-scm.com/docs/git-config.html" target="_blank" rel="noopener">http://git-scm.com/docs/git-config.html</a>) 找到同样的内容。</p><p><strong>core.editor</strong><br>默认情况下，Git 会调用环境变量（<code>$VISUAL</code> 或 <code>$EDITOR</code>）设置的任意文本编辑器，如果没有设置，会调用 <code>vi</code> 来创建和编辑你的提交以及标签信息。 你可以使用 <code>core.editor</code> 选项来修改默认的编辑器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure><p>现在，无论你定义了什么终端编辑器，Git 都会调用 Emacs 编辑信息。</p><p><strong>commit.template</strong><br>如果把此项指定为你的系统上某个文件的路径，当你提交的时候， Git 会使用该文件的内容作为提交的默认信息。 例如：假设你创建了一个叫 <code>~/.gitmessage.txt</code> 的模板文件，类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subject line</span><br><span class="line"></span><br><span class="line">what happened</span><br><span class="line"></span><br><span class="line">[ticket: X]</span><br></pre></td></tr></table></figure><p>要想让 Git 把它作为运行 <code>git commit</code> 时显示在你的编辑器中的默认信息， 如下设置 <code>commit.template</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global commit.template ~/.gitmessage.txt</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>然后当你提交时，编辑器中就会显示如下的提交信息占位符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">subject line</span><br><span class="line"></span><br><span class="line">what happened</span><br><span class="line"></span><br><span class="line">[ticket: X]</span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line"># modified:   lib/test.rb</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</span><br></pre></td></tr></table></figure><p>如果你的团队对提交信息有格式要求，可以在系统上创建一个文件，并配置 Git 把它作为默认的模板，这样可以更加容易地使提交信息遵循格式。</p><p><strong>core.pager</strong><br>该配置项指定 Git 运行诸如 <code>log</code> 和 <code>diff</code> 等命令所使用的分页器。 你可以把它设置成用 <code>more</code> 或者任何你喜欢的分页器（默认用的是 <code>less</code>），当然也可以设置成空字符串，关闭该选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.pager &apos;&apos;</span><br></pre></td></tr></table></figure><p>这样不管命令的输出量多少，Git 都会在一页显示所有内容。</p><p><strong>user.signingkey</strong><br>如果你要创建经签署的含附注的标签，那么把你的 GPG 签署密钥设置为配置项会更好。 如下设置你的密钥 ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.signingkey &lt;gpg-key-id&gt;</span><br></pre></td></tr></table></figure><p>现在，你每次运行 <code>git tag</code> 命令时，即可直接签署标签，而无需定义密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><p>正如 忽略文件 所述，你可以在你的项目的 <code>.gitignore</code> 文件里面规定无需纳入 Git 管理的文件的模板，这样它们既不会出现在未跟踪列表，也不会在你运行 <code>git add</code> 后被暂存。</p><p>不过有些时候，你想要在你所有的版本库中忽略掉某一类文件。 如果你的操作系统是 OS X，很可能就是指 <code>.DS_Store</code>。 如果你把 Emacs 或 Vim 作为首选的编辑器，你肯定知道以 <code>~</code> 结尾的临时文件。</p><p>这个配置允许你设置类似于全局生效的 <code>.gitignore</code> 文件。 如果你按照下面的内容创建一个 <code>~/.gitignore_global</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure><p>……然后运行 <code>git config --global core.excludesfile ~/.gitignore_global</code>，Git 将把那些文件永远地拒之门外。</p><p><strong>help.autocorrect</strong><br>假如你打错了一条命令，会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git chekcout master</span><br><span class="line">git：&apos;chekcout&apos; 不是一个 git 命令。参见 &apos;git --help&apos;。</span><br><span class="line"></span><br><span class="line">您指的是这个么？</span><br><span class="line">  checkout</span><br></pre></td></tr></table></figure><p>Git 会尝试猜测你的意图，但是它不会越俎代庖。 如果你把 <code>help.autocorrect</code> 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git chekcout master</span><br><span class="line">警告：您运行一个不存在的 Git 命令 &apos;chekcout&apos;。继续执行假定您要要运行的</span><br><span class="line">是 &apos;checkout&apos;</span><br><span class="line">在 0.1 秒钟后自动运行...</span><br></pre></td></tr></table></figure><p>注意提示信息中的“0.1 秒”。<code>help.autocorrect</code> 接受一个代表十分之一秒的整数。 所以如果你把它设置为 50, Git 将在自动执行命令前给你 5 秒的时间改变主意。</p><h4 id="Git-中的着色"><a href="#Git-中的着色" class="headerlink" title="Git 中的着色"></a>Git 中的着色</h4><p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。 你可以设置许多的相关选项来满足自己的偏好。</p><p><strong>color.ui</strong><br>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui false</span><br></pre></td></tr></table></figure><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><p><strong>color.*</strong><br>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color.branch</span><br><span class="line">color.diff</span><br><span class="line">color.interactive</span><br><span class="line">color.status</span><br></pre></td></tr></table></figure><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.diff.meta &quot;blue black bold&quot;</span><br></pre></td></tr></table></figure><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h4 id="外部的合并与比较工具"><a href="#外部的合并与比较工具" class="headerlink" title="外部的合并与比较工具"></a>外部的合并与比较工具</h4><p>虽然 Git 自己内置了一个 <code>diff</code> 实现，而且到目前为止我们一直在使用它，但你能够用一个外部的工具替代它。 除此以外，你还能设置一个图形化的工具来合并和解决冲突，从而不必自己手动解决。 这里我们以一个不错且免费的工具 —— Perforce 图形化合并工具（P4Merge） —— 来展示如何用一个外部的工具来合并和解决冲突。</p><p>P4Merge 可以在所有主流平台上运行，所以安装上应该没有什么困难。 在这个例子中，我们使用的路径名可以直接应用在 Mac 和 Linux 上；在 Windows 上，<code>/usr/local/bin</code> 需要被改为你的环境中可执行文件所在的目录路径。</p><p>首先， 从 <a href="http://www.perforce.com/downloads/Perforce" target="_blank" rel="noopener">http://www.perforce.com/downloads/Perforce</a> 下载 P4Merge。 接下来，你要编写一个全局包装脚本来运行你的命令。 我们会使用 Mac 上的路径来指定该脚本的位置，在其他系统上，它将是 <code>p4merge</code> 二进制文件所在的目录。 创建一个名为 <code>extMerge</code> 的脚本包装 <code>merge</code> 命令，让它把参数转发给 <code>p4merge</code> 二进制文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/local/bin/extMerge</span><br><span class="line">#!/bin/sh</span><br><span class="line">/Applications/p4merge.app/Contents/MacOS/p4merge $*</span><br></pre></td></tr></table></figure><p>包装 <code>diff</code> 命令的脚本首先确保传递了七个参数过来，随后把其中两个转发给包装了 <code>merge</code> 的脚本。 默认情况下， Git 传递以下参数给 <code>diff</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path old-file old-hex old-mode new-file new-hex new-mode</span><br></pre></td></tr></table></figure><p>由于你仅仅需要 <code>old-file</code> 和 <code>new-file</code> 参数，由包装 <code>diff</code> 的脚本来转发它们吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/local/bin/extDiff</span><br><span class="line">#!/bin/sh</span><br><span class="line">[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge &quot;$2&quot; &quot;$5&quot;</span><br></pre></td></tr></table></figure><p>你也需要确保这些脚本具有可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x /usr/local/bin/extMerge</span><br><span class="line">$ sudo chmod +x /usr/local/bin/extDiff</span><br></pre></td></tr></table></figure><p>现在你可以修改配置文件来使用你自定义的合并和比较工具了。 这将涉及许多自定义设置：<code>merge.tool</code> 通知 Git 该使用哪个合并工具， <code>mergetool.&lt;tool&gt;.cmd</code> 规定命令运行的方式，<code>mergetool.&lt;tool&gt;.trustExitCode</code> 会通知 Git 程序的返回值是否表示合并操作成功，<code>diff.external</code> 通知 Git 该用什么命令做比较。 因此，你可以运行以下四条配置命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool extMerge</span><br><span class="line">$ git config --global mergetool.extMerge.cmd \</span><br><span class="line">  &apos;extMerge \&quot;$BASE\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$MERGED\&quot;&apos;</span><br><span class="line">$ git config --global mergetool.extMerge.trustExitCode false</span><br><span class="line">$ git config --global diff.external extDiff</span><br></pre></td></tr></table></figure><p>或编辑你的 <code>~/.gitconfig</code> 文件，添加以下各行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[merge]</span><br><span class="line">  tool = extMerge</span><br><span class="line">[mergetool &quot;extMerge&quot;]</span><br><span class="line">  cmd = extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;</span><br><span class="line">  trustExitCode = false</span><br><span class="line">[diff]</span><br><span class="line">  external = extDiff</span><br></pre></td></tr></table></figure><p>待一切设置妥当后，如果你像这样运行 <code>diff</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff 32d1776b1^ 32d1776b1</span><br></pre></td></tr></table></figure><p>Git 将启动 P4Merge，而不是在命令行输出比较的结果，就像这样：</p><p><img src="git-chapter-1/img1.png" alt></p><p>如果你尝试合并两个分支，随后遇到了合并冲突，运行 <code>git mergetool</code>，Git 会调用 P4Merge 让你通过图形界面来解决冲突。</p><p>设置包装脚本的好处在于大大降低了改变 diff 和 merge 工具的工作量。 举个例子，想把 <code>extDiff</code> 和 <code>extMerge</code> 的工具改成 KDiff3，你要做的仅仅是编辑 <code>extMerge</code> 脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/local/bin/extMerge</span><br><span class="line">#!/bin/sh</span><br><span class="line">/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</span><br></pre></td></tr></table></figure><p>现在，Git 将使用 KDiff3 作为查看比较和解决合并冲突的工具。</p><p>Git 预设了许多其他的合并和解决冲突的工具，无需特别的设置你就能用上它们。 要想看到它支持的工具列表，试一下这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool --tool-help</span><br><span class="line">&apos;git mergetool --tool=&lt;tool&gt;&apos; may be set to one of the following:</span><br><span class="line">        emerge</span><br><span class="line">        gvimdiff</span><br><span class="line">        gvimdiff2</span><br><span class="line">        opendiff</span><br><span class="line">        p4merge</span><br><span class="line">        vimdiff</span><br><span class="line">        vimdiff2</span><br><span class="line"></span><br><span class="line">The following tools are valid, but not currently available:</span><br><span class="line">        araxis</span><br><span class="line">        bc3</span><br><span class="line">        codecompare</span><br><span class="line">        deltawalker</span><br><span class="line">        diffmerge</span><br><span class="line">        diffuse</span><br><span class="line">        ecmerge</span><br><span class="line">        kdiff3</span><br><span class="line">        meld</span><br><span class="line">        tkdiff</span><br><span class="line">        tortoisemerge</span><br><span class="line">        xxdiff</span><br><span class="line"></span><br><span class="line">Some of the tools listed above only work in a windowed</span><br><span class="line">environment. If run in a terminal-only session, they will fail.</span><br></pre></td></tr></table></figure><p>如果你不想用到 KDiff3 的所有功能，只是想用它来合并，那么 kdiff3 正符合你的要求，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool kdiff3</span><br></pre></td></tr></table></figure><p>如果运行了以上命令，而没有设置 <code>extMerge</code> 和 <code>extDiff</code> 文件，Git 会用 KDiff3 做合并，让内置的 <code>diff</code> 来做比较。</p><h4 id="格式化与多余的空白字符"><a href="#格式化与多余的空白字符" class="headerlink" title="格式化与多余的空白字符"></a>格式化与多余的空白字符</h4><p>格式化与多余的空白字符是许多开发人员在协作时，特别是在跨平台情况下，不时会遇到的令人头疼的琐碎的问题。 由于编辑器的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交的补丁或其它协作成果中。 不用怕，Git 提供了一些配置项来帮助你解决这些问题。</p><p><strong>core.autocrlf</strong><br>假如你正在 Windows 上写程序，而你的同伴用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 Mac 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行，或在用户按下 Enter 键时，插入回车和换行两个字符。</p><p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 <code>core.autocrlf</code> 来打开此项功能。 如果是在 Windows 系统上，把它设置成 <code>true</code>，这样在检出代码时，换行会被转换成回车和换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf true</span><br></pre></td></tr></table></figure><p>如果使用以换行作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换；然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 <code>core.autocrlf</code> 设置成 <code>input</code> 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf input</span><br></pre></td></tr></table></figure><p>这样在 Windows 上的检出文件中会保留回车和换行，而在 Mac 和 Linux 上，以及版本库中会保留换行。</p><p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 <code>false</code> 取消此功能，把回车保留在版本库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf false</span><br></pre></td></tr></table></figure><p><strong>core.whitespace</strong><br>Git 预先设置了一些选项来探测和修正多余空白字符问题。 它提供了六种处理多余空白字符的主要选项 —— 其中三个默认开启，另外三个默认关闭，不过你可以自由地设置它们。</p><p>默认被打开的三个选项是：<code>blank-at-eol</code>，查找行尾的空格；<code>blank-at-eof</code>，盯住文件底部的空行；<code>space-before-tab</code>，警惕行头 tab 前面的空格。</p><p>默认被关闭的三个选项是：<code>indent-with-non-tab</code>，揪出以空格而非 tab 开头的行（你可以用 tabwidth 选项控制它）；<code>tab-in-indent</code>，监视在行头表示缩进的 tab；<code>cr-at-eol</code>，告诉 Git 忽略行尾的回车。</p><p>通过设置 <code>core.whitespace</code>，你可以让 Git 按照你的意图来打开或关闭以逗号分割的选项。 要想关闭某个选项，你可以在输入设置选项时不指定它或在它前面加个 <code>-</code>。 例如，如果你想要打开除 <code>cr-at-eol</code> 之外的所有选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.whitespace \</span><br><span class="line">    trailing-space,space-before-tab,indent-with-non-tab</span><br></pre></td></tr></table></figure><p>当你运行 <code>git diff</code> 命令并尝试给输出着色时，Git 将探测到这些问题，因此你在提交前就能修复它们。 用 <code>git apply</code> 打补丁时你也会从中受益。 如果正准备应用的补丁存有特定的空白问题，你可以让 Git 在应用补丁时发出警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git apply --whitespace=warn &lt;patch&gt;</span><br></pre></td></tr></table></figure><p>或者让 Git 在打上补丁前自动修正此问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git apply --whitespace=fix &lt;patch&gt;</span><br></pre></td></tr></table></figure><p>这些选项也能运用于 <code>git rebase</code>。 如果提交了有空白问题的文件，但还没推送到上游，你可以运行 <code>git rebase --whitespace=fix</code> 来让 Git 在重写补丁时自动修正它们。</p><h4 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h4><p>Git 服务器端的配置项相对来说并不多，但仍有一些饶有生趣的选项值得你一看。</p><p><strong>receive.fsckObjects</strong><br>Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。 但 Git 不会在每次推送时都这么做。这个操作很耗时间，很有可能会拖慢提交的过程，特别是当库或推送的文件很大的情况下。 如果想在每次推送时都要求 Git 检查一致性，设置 <code>receive.fsckObjects</code> 为 true 来强迫它这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system receive.fsckObjects true</span><br></pre></td></tr></table></figure><p>现在 Git 会在每次推送生效前检查库的完整性，确保没有被有问题的客户端引入破坏性数据。</p><p><strong>receive.denyNonFastForwards</strong><br>如果你变基已经被推送的提交，继而再推送，又或者推送一个提交到远程分支，而这个远程分支当前指向的提交不在该提交的历史中，这样的推送会被拒绝。 这通常是个很好的策略，但有时在变基的过程中，你确信自己需要更新远程分支，可以在 <code>push</code> 命令后加 <code>-f</code> 标志来强制更新（force-update）。</p><p>要禁用这样的强制更新推送（force-pushes），可以设置 <code>receive.denyNonFastForwards</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system receive.denyNonFastForwards true</span><br></pre></td></tr></table></figure><p>稍后我们会提到，用服务器端的接收钩子也能达到同样的目的。 那种方法可以做到更细致的控制，例如禁止某一类用户做非快进（non-fast-forwards）推送。</p><p><strong>receive.denyDeletes</strong><br>有一些方法可以绕过 <code>denyNonFastForwards</code> 策略。其中一种是先删除某个分支，再连同新的引用一起推送回该分支。 把 <code>receive.denyDeletes</code> 设置为 <code>true</code> 可以把这个漏洞补上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system receive.denyDeletes true</span><br></pre></td></tr></table></figure><p>这样会禁止通过推送删除分支和标签 — 没有用户可以这么做。 要删除远程分支，必须从服务器手动删除引用文件。 通过用户访问控制列表（ACL）也能够在用户级的粒度上实现同样的功能，你将在 使用强制策略的一个例子 一节学到具体的做法。</p><h3 id="Git-属性"><a href="#Git-属性" class="headerlink" title="Git 属性"></a>Git 属性</h3><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。 这些基于路径的设置项被称为 Git 属性，可以在你的目录下的 <code>.gitattributes</code> 文件内进行设置（通常是你的项目的根目录）。如果不想让这些属性文件与其它文件一同提交，你也可以在 <code>.git/info/attributes</code> 文件中进行设置。</p><p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。 在本节，你将学习到一些能在自己的项目中用到的属性，并看到几个实际的例子。</p><h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>你可以用 Git 属性让 Git 知道哪些是二进制文件（以防它没有识别出来），并指示其如何处理这些文件。 例如，一些文本文件是由机器产生的，没有办法进行比较，但是一些二进制文件可以比较。 你将了解到怎样让 Git 区分这些文件。</p><h5 id="识别二进制文件"><a href="#识别二进制文件" class="headerlink" title="识别二进制文件"></a>识别二进制文件</h5><p>有些文件表面上是文本文件，实质上应被作为二进制文件处理。 例如，Mac 平台上的 Xcode 项目会包含一个以 <code>.pbxproj</code> 结尾的文件，它通常是一个记录项目构建配置等信息的 JSON（纯文本 Javascript 数据类型）数据集，由 IDE 写入磁盘。 虽然技术上看它是由 UTF-8 编码的文本文件，但你并不会希望将它当作文本文件来处理，因为它其实是一个轻量级数据库——如果有两个人修改了它，你通常无法合并内容，diff 的输出也帮不上什么忙。 它本应被机器处理。 因此，你想把它当成二进制文件。</p><p>要让 Git 把所有 <code>pbxproj</code> 文件当成二进制文件，在 <code>.gitattributes</code> 文件中如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.pbxproj binary</span><br></pre></td></tr></table></figure><p>现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 <code>git show</code> 或 <code>git diff</code> 时，Git 也不会比较或打印该文件的变化。</p><h5 id="比较二进制文件"><a href="#比较二进制文件" class="headerlink" title="比较二进制文件"></a>比较二进制文件</h5><p>你也可以使用 Git 属性来有效地比较两个二进制文件。 秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。</p><p>首先，让我们尝试用这个技术解决世人最头疼的问题之一：对 Microsoft Word 文档进行版本控制。 大家都知道，Microsoft Word 几乎是世上最难缠的编辑器，尽管如此，大家还是在用它。 如果想对 Word 文档进行版本控制，你可以把文件加入到 Git 库中，每次修改后提交即可。但这样做有什么实际意义呢？ 毕竟运行 <code>git diff</code> 命令后，你只能得到如下的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/chapter1.docx b/chapter1.docx</span><br><span class="line">index 88839c4..4afcb7c 100644</span><br><span class="line">Binary files a/chapter1.docx and b/chapter1.docx differ</span><br></pre></td></tr></table></figure><p>除了检出之后睁大眼睛逐行扫描，就真的没有办法直接比较两个不同版本的 Word 文档吗？ Git 属性能很好地解决此问题。 把下面这行文本加到你的 <code>.gitattributes</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.docx diff=word</span><br></pre></td></tr></table></figure><p>这告诉 Git 当你尝试查看包含变更的比较结果时，所有匹配 <code>.docx</code> 模式的文件都应该使用“word”过滤器。 “word”过滤器是什么？ 我们现在就来设置它。 我们会对 Git 进行配置，令其能够借助 <code>docx2txt</code> 程序将 Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。</p><p>首先，你需要安装 <code>docx2txt</code>；它可以从 <a href="http://docx2txt.sourceforge.net" target="_blank" rel="noopener">http://docx2txt.sourceforge.net</a> 下载。 按照 <code>INSTALL</code> 文件的说明，把它放到你的可执行路径下。 接下来，你还需要写一个脚本把输出结果包装成 Git 支持的格式。 在你的可执行路径下创建一个叫 <code>docx2txt</code> 文件，添加这些内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">docx2txt.pl $1 -</span><br></pre></td></tr></table></figure><p>别忘了用 <code>chmod a+x</code> 给这个文件加上可执行权限。 最后，你需要配置 Git 来使用这个脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config diff.word.textconv docx2txt</span><br></pre></td></tr></table></figure><p>现在如果在两个快照之间进行比较，Git 就会对那些以 <code>.docx</code> 结尾的文件应用“word”过滤器，即 <code>docx2txt</code>。 这样你的 Word 文件就能被高效地转换成文本文件并进行比较了。</p><p>作为例子，我把本书的第一章另存为 Word 文件，并提交到 Git 版本库。 接着，往其中加入一个新的段落。 运行 <code>git diff</code>，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/chapter1.docx b/chapter1.docx</span><br><span class="line">index 0b013ca..ba25db5 100644</span><br><span class="line">--- a/chapter1.docx</span><br><span class="line">+++ b/chapter1.docx</span><br><span class="line">@@ -2,6 +2,7 @@</span><br><span class="line"> This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.</span><br><span class="line"> 1.1. About Version Control</span><br><span class="line"> What is &quot;version control&quot;, and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.</span><br><span class="line">+Testing: 1, 2, 3.</span><br><span class="line"> If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.</span><br><span class="line"> 1.1.1. Local Version Control Systems</span><br><span class="line"> Many people&apos;s version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they&apos;re clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you&apos;re in and accidentally write to the wrong file or copy over files you don&apos;t mean to.</span><br></pre></td></tr></table></figure><p>Git 成功地挑出了我们添加的那句话“Testing: 1, 2, 3.”，一字不差。 还算不上完美——格式上的变动显示不出来——但已经足够了。</p><p>你还能用这个方法比较图像文件。 其中一个办法是，在比较时对图像文件运用一个过滤器，提炼出 EXIF 信息——这是在大部分图像格式中都有记录的一种元数据。 如果你下载并安装了 <code>exiftool</code> 程序，可以利用它将图像转换为关于元数据的文本信息，这样比较时至少能以文本的形式显示发生过的变动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;*.png diff=exif&apos; &gt;&gt; .gitattributes</span><br><span class="line">$ git config diff.exif.textconv exiftool</span><br></pre></td></tr></table></figure><p>如果在项目中替换了一个图像文件，运行 <code>git diff</code> 命令的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/image.png b/image.png</span><br><span class="line">index 88839c4..4afcb7c 100644</span><br><span class="line">--- a/image.png</span><br><span class="line">+++ b/image.png</span><br><span class="line">@@ -1,12 +1,12 @@</span><br><span class="line"> ExifTool Version Number         : 7.74</span><br><span class="line">-File Size                       : 70 kB</span><br><span class="line">-File Modification Date/Time     : 2009:04:21 07:02:45-07:00</span><br><span class="line">+File Size                       : 94 kB</span><br><span class="line">+File Modification Date/Time     : 2009:04:21 07:02:43-07:00</span><br><span class="line"> File Type                       : PNG</span><br><span class="line"> MIME Type                       : image/png</span><br><span class="line">-Image Width                     : 1058</span><br><span class="line">-Image Height                    : 889</span><br><span class="line">+Image Width                     : 1056</span><br><span class="line">+Image Height                    : 827</span><br><span class="line"> Bit Depth                       : 8</span><br><span class="line"> Color Type                      : RGB with Alpha</span><br></pre></td></tr></table></figure><p>你一眼就能看出文件大小和图像尺寸发生了变化。</p><h4 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h4><p>SVN 或 CVS 风格的关键字展开（keyword expansion）功能经常会被习惯于上述系统的开发者使用到。 在 Git 中，这项功能有一个主要问题，就是你无法利用它往文件中加入其关联提交的相关信息，因为 Git 总是先对文件做校验和运算（译者注：Git 中提交对象的校验依赖于文件的校验和，而 Git 属性针对特定文件或路径，因此基于 Git 属性的关键字展开无法仅根据文件反推出对应的提交）。 不过，我们可以在检出某个文件后对其注入文本，并在再次提交前删除这些文本。 Git 属性提供了两种方法来达到这一目的。</p><p>一种方法是，你可以把文件所对应数据对象的 SHA-1 校验和自动注入到文件中的 <code>$Id$</code> 字段。 如果在一个或多个文件上设置了该属性，下次当你检出相关分支的时候，Git 会用相应数据对象的 SHA-1 值替换上述字段。 注意，这不是提交对象的 SHA-1 校验和，而是数据对象本身的校验和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;*.txt ident&apos; &gt;&gt; .gitattributes</span><br><span class="line">$ echo &apos;$Id$&apos; &gt; test.txt</span><br></pre></td></tr></table></figure><p>当你下次检出文件时，Git 将注入数据对象的 SHA-1 校验和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br><span class="line">$ git checkout -- test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</span><br></pre></td></tr></table></figure><p>然而，这个结果的用途比较有限。 如果用过 CVS 或 Subversion 的关键字替换功能，我们会想加上一个时间戳信息——光有 SHA-1 校验和用途不大，它仅仅是个随机字符串，你无法凭字面值来区分不同 SHA-1 时间上的先后。</p><p>因此 Git 属性提供了另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。 一个过滤器由“clean”和“smudge”两个子过滤器组成。 在 <code>.gitattributes 文件中</code>，你能对特定的路径设置一个过滤器，然后设置文件检出前的处理脚本和文件暂存前的处理脚本。 这两个过滤器能够被用来做各种有趣的事。</p><p><img src="git-chapter-2/img1.png" alt></p><p><img src="git-chapter-2/img2.png" alt></p><p>在（Git 源码中）实现这个特性的原始提交信息里给出了一个简单的例子：在提交前，用 <code>indent</code> 程序过滤所有 C 源码。 你可以在 <code>.gitattributes</code> 文件中对 filter 属性设置“indent”过滤器来过滤 <code>*.c</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.c filter=indent</span><br></pre></td></tr></table></figure><p>然后，通过以下配置，让 Git 知道“indent”过滤器在 smudge 和 clean 时分别该做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global filter.indent.clean indent</span><br><span class="line">$ git config --global filter.indent.smudge cat</span><br></pre></td></tr></table></figure><p>在这个例子中，当你暂存 <code>*.c</code> 文件时，<code>indent</code> 程序会先被触发；在把它们检出回硬盘时，<code>cat</code> 程序会先被触发。 <code>cat</code> 在这里没什么实际作用：它仅仅把输入的数据重新输出。 这样的组合可以有效地在暂存前用 <code>indent</code> 过滤所有的 C 源码。</p><p>另一个有趣的例子是实现 RCS 风格的 <code>$Date$</code> 关键字展开。 要想演示这个例子，我们需要实现这样的一个小脚本：接受文件名参数，得到项目的最新提交日期，并把日期写入该文件。 下面是一个实现了该功能的 Ruby 小脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line">data = STDIN.read</span><br><span class="line">last_date = `git log --pretty=format:&quot;%ad&quot; -1`</span><br><span class="line">puts data.gsub(&apos;$Date$&apos;, &apos;$Date: &apos; + last_date.to_s + &apos;$&apos;)</span><br></pre></td></tr></table></figure><p>这个脚本从 <code>git log</code> 中得到最新提交日期，将其注入所有输入文件的 <code>$Date$</code> 字段，并输出结果——你可以使用最顺手的语言轻松实现一个类似的脚本。 把该脚本命名为 <code>expand_date</code>，放到你的可执行路中。 现在，你需要在 Git 中设置一个过滤器（就叫它 dater 吧），让它在检出文件时调用你的 <code>expand_date</code> 来注入时间戳，完成 smudge 操作。 暂存文件时的 clean 操作则是用一行 Perl 表达式清除注入的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config filter.dater.smudge expand_date</span><br><span class="line">$ git config filter.dater.clean &apos;perl -pe &quot;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&quot;&apos;</span><br></pre></td></tr></table></figure><p>这段 Perl 代码会删除 <code>$Date$</code> 后面注入的内容，恢复它的原貌。 过滤器终于准备完成了，是时候测试一下。创建一个带有 <code>$Date$</code> 关键字的文件，然后给它设置一个 Git 属性，关联我们的新过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;# $Date$&apos; &gt; date_test.txt</span><br><span class="line">$ echo &apos;date*.txt filter=dater&apos; &gt;&gt; .gitattributes</span><br></pre></td></tr></table></figure><p>提交该文件，并再次检出，你会发现关键字如期被替换了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git add date_test.txt .gitattributes</span><br><span class="line">$ git commit -m &quot;Testing date expansion in Git&quot;</span><br><span class="line">$ rm date_test.txt</span><br><span class="line">$ git checkout date_test.txt</span><br><span class="line">$ cat date_test.txt</span><br><span class="line"># $Date: Tue Apr 21 07:26:52 2009 -0700$</span><br></pre></td></tr></table></figure><p>自定义过滤器真的很强大。 不过你需要注意的是，因为 <code>.gitattributes</code> 文件会随着项目一起提交，而过滤器（例如这里的 <code>dater</code>）不会，所以过滤器有可能会失效。 当你在设计这些过滤器时，要注重容错性——它们在出错时应该能优雅地退出，从而不至于影响项目的正常运行。</p><h4 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h4><p>Git 属性在导出项目归档（archive）时也能发挥作用。</p><p><strong>export-ignore</strong><br>当归档的时候，可以设置 Git 不导出某些文件和目录。 如果你不想在归档中包含某个子目录或文件，但想把它们纳入项目的版本管理中，你可以在 <code>export-ignore</code> 属性中指定它们。</p><p>例如，假设你在 <code>test/</code> 子目录下有一些测试文件，不希望它们被包含在项目导出的压缩包（tarball）中。 你可以增加下面这行到 Git 属性文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test/ export-ignore</span><br></pre></td></tr></table></figure><p>现在，当你运行 <code>git archive</code> 来创建项目的压缩包时，那个目录不会被包括在归档中。</p><p><strong>export-subst</strong><br>在导出文件进行部署的时候，你可以将 <code>git log</code> 的格式化和关键字展开处理应用于被 <code>export-subst</code> 属性标记的部分文件。</p><p>举个例子，如果你想在项目中包含一个叫做 <code>LAST_COMMIT</code> 的文件，并在运行 <code>git archive</code> 的时候自动向它注入最新提交的元数据，可以像这样设置该文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;Last commit date: $Format:%cd by %aN$&apos; &gt; LAST_COMMIT</span><br><span class="line">$ echo &quot;LAST_COMMIT export-subst&quot; &gt;&gt; .gitattributes</span><br><span class="line">$ git add LAST_COMMIT .gitattributes</span><br><span class="line">$ git commit -am &apos;adding LAST_COMMIT file for archives&apos;</span><br></pre></td></tr></table></figure><p>运行 <code>git archive</code> 之后，该文件被归档后的内容会被替换成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git archive HEAD | tar xCf ../deployment-testing -</span><br><span class="line">$ cat ../deployment-testing/LAST_COMMIT</span><br><span class="line">Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</span><br></pre></td></tr></table></figure><p>你也可以用诸如提交信息或者任意的 git 注解进行替换，并且 <code>git log</code> 还能做简单的字词包装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$&apos; &gt; LAST_COMMIT</span><br><span class="line">$ git commit -am &apos;export-subst 使用 git log 的自定义格式化工具</span><br><span class="line"></span><br><span class="line">git archive 直接使用 git log 的 `pretty=format:`</span><br><span class="line">处理器，并在输出中移除两侧的 `$Format:` 和 `$`</span><br><span class="line">标记。</span><br><span class="line">&apos;</span><br><span class="line">$ git archive @ | tar xfO - LAST_COMMIT</span><br><span class="line">Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700</span><br><span class="line">       export-subst 使用 git log 的自定义格式化工具</span><br><span class="line"></span><br><span class="line">         git archive 直接使用 git log 的 `pretty=format:` 处理器，并</span><br><span class="line">         在输出中移除两侧的 `$Format:` 和 `$` 标记。</span><br></pre></td></tr></table></figure><p>由此得到的归档适用于（当前的）部署工作。然而和其他的导出归档一样，它并不适用于后继的部署工作。</p><h4 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h4><p>通过 Git 属性，你还能对项目中的特定文件指定不同的合并策略。 一个非常有用的选项就是，告诉 Git 当特定文件发生冲突时不要尝试合并它们，而是直接使用你这边的内容。</p><p>考虑如下场景：项目中有一个分叉的或者定制过的特性分支，你希望该分支上的更改能合并回你的主干分支，同时需要忽略其中某些文件。此时这个合并策略就能派上用场。 假设你有一个数据库设置文件 <code>database.xml</code>，在两个分支中它是不同的，而你想合并另一个分支到你的分支上，又不想弄乱该数据库文件。 你可以设置属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.xml merge=ours</span><br></pre></td></tr></table></figure><p>然后定义一个虚拟的合并策略，叫做 <code>ours</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.ours.driver true</span><br></pre></td></tr></table></figure><p>如果你合并了另一个分支，<code>database.xml</code> 文件不会有合并冲突，相反会显示如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge topic</span><br><span class="line">Auto-merging database.xml</span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure><p>这里，<code>database.xml</code> 保持了主干分支中的原始版本。</p><h3 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h3><p>和其它版本控制系统一样，Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。</p><h4 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h4><p>钩子都被存储在 Git 目录下的 <code>hooks</code> 子目录中。 也即绝大部分项目中的 <code>.git/hooks</code> 。 当你用 <code>git init</code> 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 这些示例的名字都是以 <code>.sample</code> 结尾，如果你想启用它们，得先移除这个后缀。</p><p>把一个正确命名且可执行的文件放入 Git 目录下的 <code>hooks</code> 子目录中，即可激活该钩子脚本。 这样一来，它就能被 Git 调用。 接下来，我们会讲解常用的钩子脚本类型。</p><h4 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h4><p>客户端钩子分为很多种。 下面把它们分为：提交工作流钩子、电子邮件工作流钩子和其它钩子。</p><h5 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h5><p>前四个钩子涉及提交的过程。</p><p><code>pre-commit</code> 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify</code> 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 <code>lint</code> 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p><p><code>prepare-commit-msg</code> 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</p><p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p><p><code>post-commit</code> 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 <code>git log -1 HEAD</code> 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。</p><h5 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h5><p>你可以给电子邮件工作流设置三个客户端钩子。 它们都是由 <code>git am</code> 命令调用的，因此如果你没有在你的工作流中用到这个命令，可以跳到下一节。 如果你需要通过电子邮件接收由 <code>git format-patch</code> 产生的补丁，这些钩子也许用得上。</p><p>第一个运行的钩子是 <code>applypatch-msg</code> 。 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</p><p>下一个在 <code>git am</code> 运行期间被调用的是 <code>pre-applypatch</code> 。 有些难以理解的是，它正好运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 <code>git am</code> 的运行，这样补丁就不会被提交。</p><p><code>post-applypatch</code> 运行于提交产生之后，是在 <code>git am</code> 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程。</p><h5 id="其它客户端钩子"><a href="#其它客户端钩子" class="headerlink" title="其它客户端钩子"></a>其它客户端钩子</h5><p><code>pre-rebase</code> 钩子运行于变基之前，以非零值退出可以中止变基的过程。 你可以使用这个钩子来禁止对已经推送的提交变基。 Git 自带的 <code>pre-rebase</code> 钩子示例就是这么做的，不过它所做的一些假设可能与你的工作流程不匹配。</p><p><code>post-rewrite</code> 钩子被那些会替换提交记录的命令调用，比如 <code>git commit --amend</code> 和 <code>git rebase</code>（不过不包括 <code>git filter-branch</code>）。 它唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。 这个钩子的用途很大程度上跟 <code>post-checkout</code> 和 <code>post-merge</code> 差不多。</p><p>在 <code>git checkout</code> 成功运行后，<code>post-checkout</code> 钩子会被调用。你可以根据你的项目环境用它调整你的工作目录。 其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。</p><p>在 <code>git merge</code> 成功运行后，<code>post-merge</code> 钩子会被调用。 你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。 这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。</p><p><code>pre-push</code> 钩子会在 <code>git push</code> 运行期间， 更新了远程引用但尚未传送对象时被调用。 它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。 你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。</p><p>Git 的一些日常操作在运行时，偶尔会调用 <code>git gc --auto</code> 进行垃圾回收。 <code>pre-auto-gc</code> 钩子会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。</p><h4 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h4><p>除了客户端钩子，作为系统管理员，你还可以使用若干服务器端的钩子对项目强制执行各种类型的策略。 这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息，还可以依你所想设置足够复杂的推送策略。</p><p><strong>pre-receive</strong><br>处理来自客户端的推送操作时，最先被调用的脚本是 <code>pre-receive</code>。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p><p><strong>update</strong><br><code>update</code> 脚本和 <code>pre-receive</code> 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，<code>pre-receive</code> 只运行一次，相比之下 <code>update</code> 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 <code>update</code> 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。</p><p><strong>post-receive</strong><br><code>post-receive</code> 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 <code>pre-receive</code> 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。</p><h3 id="使用强制策略的一个例子"><a href="#使用强制策略的一个例子" class="headerlink" title="使用强制策略的一个例子"></a>使用强制策略的一个例子</h3><p>在本节中，你将应用前面学到的知识建立这样一个 Git 工作流程：检查提交信息的格式，并且指定只能由特定用户修改项目中特定的子目录。 你将编写一个客户端脚本来提示开发人员他们的推送是否会被拒绝，以及一个服务器端脚本来实际执行这些策略。</p><p>我们待会展示的脚本是用 Ruby 写的，部分是由于我习惯用它写脚本，另外也因为 Ruby 简单易懂，即便你没写过它也能看明白。 不过任何其他语言也一样适用。所有 Git 自带的示例钩子脚本都是用 Perl 或 Bash 写的，所以你能从它们中找到相当多的这两种语言的钩子示例。</p><h4 id="服务器端钩子-1"><a href="#服务器端钩子-1" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h4><p>所有服务器端的工作都将在你的 <code>hooks</code> 目录下的 <code>update</code> 脚本中完成。 <code>update</code> 脚本会为每一个提交的分支各运行一次，它接受三个参数：</p><ul><li><p>被推送的引用的名字</p></li><li><p>推送前分支的修订版本（revision）</p></li><li><p>用户准备推送的修订版本（revision）</p></li></ul><p>如果推送是通过 SSH 进行的，还可以获知进行此次推送的用户的信息。 如果你允许所有操作都通过公匙授权的单一帐号（比如“git”）进行，就有必要通过一个 shell 包装脚本依据公匙来判断用户的身份，并且相应地设定环境变量来表示该用户的身份。 下面就假设 <code>$USER</code> 环境变量里存储了当前连接的用户的身份，你的 update 脚本首先搜集一切需要的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">$refname = ARGV[0]</span><br><span class="line">$oldrev  = ARGV[1]</span><br><span class="line">$newrev  = ARGV[2]</span><br><span class="line">$user    = ENV[&apos;USER&apos;]</span><br><span class="line"></span><br><span class="line">puts &quot;Enforcing Policies...&quot;</span><br><span class="line">puts &quot;(#&#123;$refname&#125;) (#&#123;$oldrev[0,6]&#125;) (#&#123;$newrev[0,6]&#125;)&quot;</span><br></pre></td></tr></table></figure><p>是的，我们这里用的都是全局变量。 请勿在此吐槽——这样做只是为了方便展示而已。</p><h5 id="指定特殊的提交信息格式"><a href="#指定特殊的提交信息格式" class="headerlink" title="指定特殊的提交信息格式"></a>指定特殊的提交信息格式</h5><p>你的第一项任务是要求每一条提交信息都必须遵循某种特殊的格式。 作为目标，假定每一条信息必须包含一条形似“ref: 1234”的字符串，因为你想把每一次提交对应到问题追踪系统（ticketing system）中的某个事项。 你要逐一检查每一条推送上来的提交内容，看看提交信息是否包含这么一个字符串，然后，如果某个提交里不包含这个字符串，以非零返回值退出从而拒绝此次推送。</p><p>把 <code>$newrev</code> 和 <code>$oldrev</code> 变量的值传给一个叫做 <code>git rev-list</code> 的 Git 底层命令，你可以获取所有提交的 SHA-1 值列表。 <code>git rev-list</code> 基本类似 <code>git log</code> 命令，但它默认只输出 SHA-1 值而已，没有其他信息。 所以要获取由一次提交到另一次提交之间的所有 SHA-1 值，可以像这样运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-list 538c33..d14fc7</span><br><span class="line">d14fc7c847ab946ec39590d87783c69b031bdfb7</span><br><span class="line">9f585da4401b0a3999e84113824d15245c13f0be</span><br><span class="line">234071a1be950e2a8d078e6141f5cd20c1e61ad3</span><br><span class="line">dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a</span><br><span class="line">17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</span><br></pre></td></tr></table></figure><p>你可以截取这些输出内容，循环遍历其中每一个 SHA-1 值，找出与之对应的提交信息，然后用正则表达式来测试该信息包含的内容。</p><p>下一步要实现从每个提交中提取出提交信息。 使用另一个叫做 <code>git cat-file</code> 的底层命令来获得原始的提交数据。 我们将在 Git 内部原理 了解到这些底层命令的细节；现在暂时先看一下这条命令的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file commit ca82a6</span><br><span class="line">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700</span><br><span class="line">committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</span><br><span class="line"></span><br><span class="line">changed the version number</span><br></pre></td></tr></table></figure><p>通过 SHA-1 值获得提交中的提交信息的一个简单办法是找到提交的第一个空行，然后取从它往后的所有内容。 可以使用 Unix 系统的 <code>sed</code> 命令来实现该效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file commit ca82a6 | sed &apos;1,/^$/d&apos;</span><br><span class="line">changed the version number</span><br></pre></td></tr></table></figure><p>你可以用这条咒语从每一个待推送的提交里提取提交信息，然后在提取的内容不符合要求时退出。 为了退出脚本和拒绝此次推送，返回非零值。 整个脚本大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$regex = /\[ref: (\d+)\]/</span><br><span class="line"></span><br><span class="line"># 指定自定义的提交信息格式</span><br><span class="line">def check_message_format</span><br><span class="line">  missed_revs = `git rev-list #&#123;$oldrev&#125;..#&#123;$newrev&#125;`.split(&quot;\n&quot;)</span><br><span class="line">  missed_revs.each do |rev|</span><br><span class="line">    message = `git cat-file commit #&#123;rev&#125; | sed &apos;1,/^$/d&apos;`</span><br><span class="line">    if !$regex.match(message)</span><br><span class="line">      puts &quot;[POLICY] Your message is not formatted correctly&quot;</span><br><span class="line">      exit 1</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">check_message_format</span><br></pre></td></tr></table></figure><p>把这一段放在 update 脚本里，所有包含不符合指定规则的提交都会遭到拒绝。</p><h5 id="指定基于用户的访问权限控制列表（ACL）系统"><a href="#指定基于用户的访问权限控制列表（ACL）系统" class="headerlink" title="指定基于用户的访问权限控制列表（ACL）系统"></a>指定基于用户的访问权限控制列表（ACL）系统</h5><p>假设你需要添加一个使用访问权限控制列表的机制，来指定哪些用户对项目的哪些部分有推送权限。 某些用户具有全部的访问权，其他人只对某些子目录或者特定的文件具有推送权限。 为了实现这一点，你要把相关的规则写入位于服务器原始 Git 仓库的 acl 文件中。 你还需要让 <code>update</code> 钩子检阅这些规则，审视推送的提交内容中被修改的所有文件，然后决定执行推送的用户是否对所有这些文件都有权限。</p><p>先从写一个 ACL 文件开始吧。 这里使用的格式和 CVS 的 ACL 机制十分类似：它由若干行构成，第一项内容是 <code>avail</code> 或者 <code>unavail</code>，接着是逗号分隔的适用该规则的用户列表，最后一项是适用该规则的路径（该项空缺表示没有路径限制）。 各项由管道符 <code>|</code> 隔开。</p><p>在本例中，你会有几个管理员，一些对 <code>doc</code> 目录具有权限的文档作者，以及一位仅对 <code>lib</code> 和 <code>tests</code> 目录具有权限的开发人员，相应的 ACL 文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avail|nickh,pjhyett,defunkt,tpw</span><br><span class="line">avail|usinclair,cdickens,ebronte|doc</span><br><span class="line">avail|schacon|lib</span><br><span class="line">avail|schacon|tests</span><br></pre></td></tr></table></figure><p>首先把这些数据读入你要用到的数据结构里。 在本例中，为保持简洁，我们暂时只实现 <code>avail</code> 的规则。 下面这个方法生成一个关联数组，它的键是用户名，值是一个由该用户有写权限的所有目录组成的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def get_acl_access_data(acl_file)</span><br><span class="line">  # 读取 ACL 数据</span><br><span class="line">  acl_file = File.read(acl_file).split(&quot;\n&quot;).reject &#123; |line| line == &apos;&apos; &#125;</span><br><span class="line">  access = &#123;&#125;</span><br><span class="line">  acl_file.each do |line|</span><br><span class="line">    avail, users, path = line.split(&apos;|&apos;)</span><br><span class="line">    next unless avail == &apos;avail&apos;</span><br><span class="line">    users.split(&apos;,&apos;).each do |user|</span><br><span class="line">      access[user] ||= []</span><br><span class="line">      access[user] &lt;&lt; path</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  access</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>对于之前给出的 ACL 规则文件，这个 <code>get_acl_access_data</code> 方法返回的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;defunkt&quot;=&gt;[nil],</span><br><span class="line"> &quot;tpw&quot;=&gt;[nil],</span><br><span class="line"> &quot;nickh&quot;=&gt;[nil],</span><br><span class="line"> &quot;pjhyett&quot;=&gt;[nil],</span><br><span class="line"> &quot;schacon&quot;=&gt;[&quot;lib&quot;, &quot;tests&quot;],</span><br><span class="line"> &quot;cdickens&quot;=&gt;[&quot;doc&quot;],</span><br><span class="line"> &quot;usinclair&quot;=&gt;[&quot;doc&quot;],</span><br><span class="line"> &quot;ebronte&quot;=&gt;[&quot;doc&quot;]&#125;</span><br></pre></td></tr></table></figure><p>既然拿到了用户权限的数据，接下来你需要找出提交都修改了哪些路径，从而才能保证推送者对所有这些路径都有权限。</p><p>使用 <code>git log</code> 的 <code>--name-only</code> 选项（在第二章里简单地提过），我们可以轻而易举的找出一次提交里修改的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log -1 --name-only --pretty=format:&apos;&apos; 9f585d</span><br><span class="line"></span><br><span class="line">README</span><br><span class="line">lib/test.rb</span><br></pre></td></tr></table></figure><p>使用 <code>get_acl_access_data</code> 返回的 ACL 结构来一一核对每次提交修改的文件列表，就能找出该用户是否有权限推送所有的提交内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 仅允许特定用户修改项目中的特定子目录</span><br><span class="line">def check_directory_perms</span><br><span class="line">  access = get_acl_access_data(&apos;acl&apos;)</span><br><span class="line"></span><br><span class="line">  # 检查是否有人在向他没有权限的地方推送内容</span><br><span class="line">  new_commits = `git rev-list #&#123;$oldrev&#125;..#&#123;$newrev&#125;`.split(&quot;\n&quot;)</span><br><span class="line">  new_commits.each do |rev|</span><br><span class="line">    files_modified = `git log -1 --name-only --pretty=format:&apos;&apos; #&#123;rev&#125;`.split(&quot;\n&quot;)</span><br><span class="line">    files_modified.each do |path|</span><br><span class="line">      next if path.size == 0</span><br><span class="line">      has_file_access = false</span><br><span class="line">      access[$user].each do |access_path|</span><br><span class="line">        if !access_path  # 用户拥有完全访问权限</span><br><span class="line">           || (path.start_with? access_path) # 或者对此路径有访问权限</span><br><span class="line">          has_file_access = true</span><br><span class="line">        end</span><br><span class="line">      end</span><br><span class="line">      if !has_file_access</span><br><span class="line">        puts &quot;[POLICY] You do not have access to push to #&#123;path&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">check_directory_perms</span><br></pre></td></tr></table></figure><p>通过 <code>git rev-list</code> 获取推送到服务器的所有提交。 接着，对于每一个提交，找出它修改的文件，然后确保推送者具有这些文件的推送权限。</p><p>现在你的用户没法推送带有不正确的提交信息的内容，也不能在准许他们访问范围之外的位置做出修改。</p><h5 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h5><p>如果已经把上面的代码放到 <code>.git/hooks/update</code> 文件里了，运行 <code>chmod u+x .git/hooks/update</code>，然后尝试推送一个不符合格式的提交，你会得到以下的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f origin master</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 323 bytes, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">Enforcing Policies...</span><br><span class="line">(refs/heads/master) (8338c5) (c5b616)</span><br><span class="line">[POLICY] Your message is not formatted correctly</span><br><span class="line">error: hooks/update exited with error code 1</span><br><span class="line">error: hook declined to update refs/heads/master</span><br><span class="line">To git@gitserver:project.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (hook declined)</span><br><span class="line">error: failed to push some refs to &apos;git@gitserver:project.git&apos;</span><br></pre></td></tr></table></figure><p>这里有几个有趣的信息。 首先，我们可以看到钩子运行的起点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enforcing Policies...</span><br><span class="line">(refs/heads/master) (fb8c72) (c56860)</span><br></pre></td></tr></table></figure><p>注意这是从 update 脚本开头输出到标准输出的。 所有从脚本输出到标准输出的内容都会转发给客户端。</p><p>下一个值得注意的部分是错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[POLICY] Your message is not formatted correctly</span><br><span class="line">error: hooks/update exited with error code 1</span><br><span class="line">error: hook declined to update refs/heads/master</span><br></pre></td></tr></table></figure><p>第一行是我们的脚本输出的，剩下两行是 Git 在告诉我们 update 脚本退出时返回了非零值因而推送遭到了拒绝。 最后一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To git@gitserver:project.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (hook declined)</span><br><span class="line">error: failed to push some refs to &apos;git@gitserver:project.git&apos;</span><br></pre></td></tr></table></figure><p>你会看到每个被你的钩子拒之门外的引用都收到了一个 remote rejected 信息，它告诉你正是钩子无法成功运行导致了推送的拒绝。</p><p>又或者某人想修改一个自己不具备权限的文件然后推送了一个包含它的提交，他将看到类似的提示。 比如，一个文档作者尝试推送一个修改到 <code>lib</code> 目录的提交，他会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[POLICY] You do not have access to push to lib/test.rb</span><br></pre></td></tr></table></figure><p>从今以后，只要 <code>update</code> 脚本存在并且可执行，我们的版本库中永远都不会包含不符合格式的提交信息，并且用户都会待在沙箱里面。</p><h4 id="客户端钩子-1"><a href="#客户端钩子-1" class="headerlink" title="客户端钩子"></a>客户端钩子</h4><p>这种方法的缺点在于，用户推送的提交遭到拒绝后无法避免的抱怨。 辛辛苦苦写成的代码在最后时刻惨遭拒绝是十分让人沮丧且具有迷惑性的；更可怜的是他们不得不修改提交历史来解决问题，这个方法并不能让每一个人满意。</p><p>逃离这种两难境地的法宝是给用户一些客户端的钩子，在他们犯错的时候给以警告。 然后呢，用户们就能趁问题尚未变得更难修复，在提交前消除这个隐患。 由于钩子本身不跟随克隆的项目副本分发，所以你必须通过其他途径把这些钩子分发到用户的 .<code>git/hooks</code> 目录并设为可执行文件。 虽然你可以在相同或单独的项目里加入并分发这些钩子，但是 Git 不会自动替你设置它。</p><p>首先，你应该在每次提交前核查你的提交信息，这样才能确保服务器不会因为不合条件的提交信息而拒绝你的更改。 为了达到这个目的，你可以增加 <code>commit-msg</code> 钩子。 如果你使用该钩子来读取作为第一个参数传递的提交信息，然后与规定的格式作比较，你就可以使 Git 在提交信息格式不对的情况下拒绝提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env ruby</span><br><span class="line">message_file = ARGV[0]</span><br><span class="line">message = File.read(message_file)</span><br><span class="line"></span><br><span class="line">$regex = /\[ref: (\d+)\]/</span><br><span class="line"></span><br><span class="line">if !$regex.match(message)</span><br><span class="line">  puts &quot;[POLICY] Your message is not formatted correctly&quot;</span><br><span class="line">  exit 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果这个脚本位于正确的位置（ <code>.git/hooks/commit-msg</code> ）并且是可执行的，你提交信息的格式又是不正确的，你会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;test&apos;</span><br><span class="line">[POLICY] Your message is not formatted correctly</span><br></pre></td></tr></table></figure><p>在这个示例中，提交没有成功。 然而如果你的提交注释信息是符合要求的，Git 会允许你提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;test [ref: 132]&apos;</span><br><span class="line">[master e05c914] test [ref: 132]</span><br><span class="line"> 1 file changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>接下来我们要保证没有修改到 ACL 允许范围之外的文件。 假如你的 <code>.git</code> 目录下有前面使用过的那份 ACL 文件，那么以下的 <code>pre-commit</code> 脚本将把里面的规定执行起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">$user    = ENV[&apos;USER&apos;]</span><br><span class="line"></span><br><span class="line"># [ 插入上文中的 get_acl_access_data 方法 ]</span><br><span class="line"></span><br><span class="line"># 仅允许特定用户修改项目中的特定子目录</span><br><span class="line">def check_directory_perms</span><br><span class="line">  access = get_acl_access_data(&apos;.git/acl&apos;)</span><br><span class="line"></span><br><span class="line">  files_modified = `git diff-index --cached --name-only HEAD`.split(&quot;\n&quot;)</span><br><span class="line">  files_modified.each do |path|</span><br><span class="line">    next if path.size == 0</span><br><span class="line">    has_file_access = false</span><br><span class="line">    access[$user].each do |access_path|</span><br><span class="line">    if !access_path || (path.index(access_path) == 0)</span><br><span class="line">      has_file_access = true</span><br><span class="line">    end</span><br><span class="line">    if !has_file_access</span><br><span class="line">      puts &quot;[POLICY] You do not have access to push to #&#123;path&#125;&quot;</span><br><span class="line">      exit 1</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">check_directory_perms</span><br></pre></td></tr></table></figure><p>这和服务器端的脚本几乎一样，除了两个重要区别。 第一，ACL 文件的位置不同，因为这个脚本在当前工作目录运行，而非 <code>.git</code> 目录。 ACL 文件的路径必须从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access = get_acl_access_data(&apos;acl&apos;)</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access = get_acl_access_data(&apos;.git/acl&apos;)</span><br></pre></td></tr></table></figure><p>另一个重要区别是获取被修改文件列表的方式。 在服务器端的时候使用了查看提交纪录的方式，可是目前的提交都还没被记录下来呢，所以这个列表只能从暂存区域获取。 和原来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files_modified = `git log -1 --name-only --pretty=format:&apos;&apos; #&#123;ref&#125;`</span><br></pre></td></tr></table></figure><p>不同，现在要用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files_modified = `git diff-index --cached --name-only HEAD`</span><br></pre></td></tr></table></figure><p>不同的就只有这两个——除此之外，该脚本完全相同。 有一点要注意的是，它假定在本地运行的用户和推送到远程服务器端的相同。 如果这二者不一样，则需要手动设置一下 <code>$user</code> 变量。</p><p>在这里，我们还可以确保推送内容中不包含非快进（non-fast-forward）的引用。 出现一个不是快进（fast-forward）的引用有两种情形，要么是在某个已经推送过的提交上作变基，要么是从本地推送一个错误的分支到远程分支上。</p><p>假定为了执行这个策略，你已经在服务器上配置好了 <code>receive.denyDeletes</code> 和 <code>receive.denyNonFastForwards</code>，因而唯一还需要避免的是在某个已经推送过的提交上作变基。</p><p>下面是一个检查这个问题的 pre-rebase 脚本示例。 它获取所有待重写的提交的列表，然后检查它们是否存在于远程引用中。 一旦发现其中一个提交是在某个远程引用中可达的（reachable），它就终止此次变基：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">base_branch = ARGV[0]</span><br><span class="line">if ARGV[1]</span><br><span class="line">  topic_branch = ARGV[1]</span><br><span class="line">else</span><br><span class="line">  topic_branch = &quot;HEAD&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target_shas = `git rev-list #&#123;base_branch&#125;..#&#123;topic_branch&#125;`.split(&quot;\n&quot;)</span><br><span class="line">remote_refs = `git branch -r`.split(&quot;\n&quot;).map &#123; |r| r.strip &#125;</span><br><span class="line"></span><br><span class="line">target_shas.each do |sha|</span><br><span class="line">  remote_refs.each do |remote_ref|</span><br><span class="line">    shas_pushed = `git rev-list ^#&#123;sha&#125;^@ refs/remotes/#&#123;remote_ref&#125;`</span><br><span class="line">    if shas_pushed.split(&quot;\n&quot;).include?(sha)</span><br><span class="line">      puts &quot;[POLICY] Commit #&#123;sha&#125; has already been pushed to #&#123;remote_ref&#125;&quot;</span><br><span class="line">      exit 1</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个脚本利用了一个第六章“修订版本选择”一节中不曾提到的语法。通过运行这个命令可以获得一系列之前推送过的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`git rev-list ^#&#123;sha&#125;^@ refs/remotes/#&#123;remote_ref&#125;`</span><br></pre></td></tr></table></figure><p><code>SHA^@</code> 语法会被解析成该提交的所有父提交。 该命令会列出在远程分支最新的提交中可达的，却在所有我们尝试推送的提交的 SHA-1 值的所有父提交中不可达的提交——也就是快进的提交。</p><p>这个解决方案主要的问题在于它有可能很慢而且常常没有必要——只要你不用 <code>-f</code> 来强制推送，服务器就会自动给出警告并且拒绝接受推送。 然而，这是个不错的练习，而且理论上能帮助你避免一次以后可能不得不回头修补的变基。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：工具</title>
      <link href="/2018/06/10/Git%EF%BC%9A%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/06/10/Git%EF%BC%9A%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。 你已经尝试了跟踪和提交文件的基本操作，并且发挥了暂存区和轻量级的分支及合并的威力。</p><p>接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。</p><h3 id="选择修订版本"><a href="#选择修订版本" class="headerlink" title="选择修订版本"></a>选择修订版本</h3><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。</p><a id="more"></a><h4 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h4><p>你可以通过 Git 给出的 SHA-1 值来获取一次提交，不过还有很多更人性化的方式来做同样的事情。 本节将会介绍获取单个提交的多种方法。</p><h4 id="简短的-SHA-1"><a href="#简短的-SHA-1" class="headerlink" title="简短的 SHA-1"></a>简短的 SHA-1</h4><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说，当前仓库中只有一个对象以这段 SHA-1 开头。</p><p>例如查看一次指定的提交，假设你执行 <code>git log</code> 命令来查看之前新增一个功能的那次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &apos;phedders/rdocs&apos;</span><br><span class="line"></span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br></pre></td></tr></table></figure><p>假设这个提交是 <code>1c002dd....</code>，如果你想 <code>git show</code> 这个提交，下面的命令是等价的（假设简短的版本没有歧义）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">$ git show 1c002dd4b536e7479f</span><br><span class="line">$ git show 1c002d</span><br></pre></td></tr></table></figure><p>Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 <code>git log</code> 后加上 <code>--abbrev-commit</code> 参数，输出结果里就会显示简短且唯一的值；默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --abbrev-commit --pretty=oneline</span><br><span class="line">ca82a6d changed the version number</span><br><span class="line">085bb3b removed unnecessary test code</span><br><span class="line">a11bef0 first commit</span><br></pre></td></tr></table></figure><p>通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。</p><p>比如 Linux 内核这个相当大的 Git 项目，目前有超过 45 万个提交，包含 360 万个对象，也只需要前 11 个字符就能保证唯一性。</p><h4 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h4><p>指明一次提交最直接的方法是有一个指向它的分支引用。 这样你就可以在任意一个 Git 命令中使用这个分支名来代替对应的提交对象或者 SHA-1 值。 例如，你想要查看一个分支的最后一次提交的对象，假设 <code>topic1</code> 分支指向 <code>ca82a6d</code> ，那么以下的命令是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">$ git show topic1</span><br></pre></td></tr></table></figure><p>如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1 ，你可以使用一个叫做 <code>rev-parse</code> 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。简单来说，<code>rev-parse</code> 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 <code>rev-parse</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-parse topic1</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure><h4 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用日志</h4><p>当你在工作时， Git 会在后台保存一个引用日志（reflog），引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p><p>你可以使用 <code>git reflog</code> 来查看引用日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">734713b HEAD@&#123;0&#125;: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">d921970 HEAD@&#123;1&#125;: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">1c002dd HEAD@&#123;2&#125;: commit: added some blame and merge stuff</span><br><span class="line">1c36188 HEAD@&#123;3&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">95df984 HEAD@&#123;4&#125;: commit: # This is a combination of two commits.</span><br><span class="line">1c36188 HEAD@&#123;5&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">7e05da5 HEAD@&#123;6&#125;: rebase -i (pick): updating HEAD</span><br></pre></td></tr></table></figure><p>每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 通过这些数据，你可以很方便地获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 <code>@{n}</code> 来引用 reflog 中输出的提交记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD@&#123;5&#125;</span><br></pre></td></tr></table></figure><p>你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 <code>master</code> 分支在昨天的时候指向了哪个提交，你可以输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show master@&#123;yesterday&#125;</span><br></pre></td></tr></table></figure><p>就会显示昨天该分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。</p><p>可以运行 <code>git log -g</code> 来查看类似于 <code>git log</code> 输出格式的引用日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log -g master</span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Reflog: master@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Reflog: master@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &apos;phedders/rdocs&apos;</span><br></pre></td></tr></table></figure><p>值得注意的是，引用日志只存在于本地仓库，一个记录你在你自己的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 <code>git show HEAD@{2.months.ago}</code> 这条命令只有在你克隆了一个项目至少两个月时才会有用——如果你是五分钟前克隆的仓库，那么它将不会有结果返回。</p><h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h4><p>祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 <code>^</code>， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&apos;%h %s&apos; --graph</span><br><span class="line">* 734713b fixed refs handling, added gc auto, updated tests</span><br><span class="line">*   d921970 Merge commit &apos;phedders/rdocs&apos;</span><br><span class="line">|\</span><br><span class="line">| * 35cfb2b Some rdoc changes</span><br><span class="line">* | 1c002dd added some blame and merge stuff</span><br><span class="line">|/</span><br><span class="line">* 1c36188 ignore *.gem</span><br><span class="line">* 9b29157 add open3_detach to gemspec file list</span><br></pre></td></tr></table></figure><p>你可以使用 <code>HEAD^</code> 来查看上一个提交，也就是 “HEAD 的父提交”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^</span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &apos;phedders/rdocs&apos;</span><br></pre></td></tr></table></figure><p>你也可以在 <code>^</code> 后面添加一个数字——例如 <code>d921970^2</code> 代表 “d921970 的第二父提交” 这个语法只适用于合并（merge）的提交，因为合并提交会有多个父提交。 第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show d921970^</span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br><span class="line"></span><br><span class="line">$ git show d921970^2</span><br><span class="line">commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548</span><br><span class="line">Author: Paul Hedderly &lt;paul+git@mjr.org&gt;</span><br><span class="line">Date:   Wed Dec 10 22:22:03 2008 +0000</span><br><span class="line"></span><br><span class="line">    Some rdoc changes</span><br></pre></td></tr></table></figure><p>另一种指明祖先提交的方法是 <code>~</code>。 同样是指向第一父提交，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。 而区别在于你在后面加数字的时候。 <code>HEAD~2</code> 代表“第一父提交的第一父提交”，也就是“祖父提交”—— Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，<code>HEAD~3</code> 就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD~3</span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure><p>也可以写成 <code>HEAD^^^</code>，也是第一父提交的第一父提交的第一父提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^^^</span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure><p>你也可以组合使用这两个语法——你可以通过 <code>HEAD~3^2</code> 来取得之前引用的第二父提交（假设它是一个合并提交）。</p><h4 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h4><p>你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用，你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题</p><p><strong>双点</strong><br>最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.</p><p><img src="git-chapter-1/img1.png" alt></p><p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 <code>master..experiment</code> 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log master..experiment</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>反过来，如果你想查看在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交，你只要交换分支名即可。 <code>experiment..master</code> 会显示在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log experiment..master</span><br><span class="line">F</span><br><span class="line">E</span><br></pre></td></tr></table></figure><p>这可以让你保持 <code>experiment</code> 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin/master..HEAD</span><br></pre></td></tr></table></figure><p>这个命令会输出在你当前分支中而不在远程 <code>origin</code> 中的提交。 如果你执行 <code>git push</code> 并且你的当前分支正在跟踪 <code>origin/master</code>，由 <code>git log origin/master..HEAD</code> 所输出的提交就是会被传输到远端服务器的提交。 如果你留空了其中的一边， Git 会默认为 HEAD。 例如， <code>git log origin/master..</code> 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。</p><p><strong>多点</strong><br>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 <code>^</code> 字符或者 <code>--not</code> 来指明你不希望提交被包含其中的分支。 因此下列3个命令是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA..refB</span><br><span class="line">$ git log ^refA refB</span><br><span class="line">$ git log refB --not refA</span><br></pre></td></tr></table></figure><p>这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交，你可以输入下面中的任意一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA refB ^refC</span><br><span class="line">$ git log refA refB --not refC</span><br></pre></td></tr></table></figure><p>这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。</p><p><strong>三点</strong><br>最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 <code>master</code> 或者 <code>experiment</code> 中包含的但不是两者共有的提交，你可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log master...experiment</span><br><span class="line">F</span><br><span class="line">E</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>这和通常 <code>log</code> 按日期排序的输出一样，仅仅给出了4个提交的信息。</p><p>这种情形下，<code>log</code> 命令的一个常用参数是 <code>--left-right</code>，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --left-right master...experiment</span><br><span class="line">&lt; F</span><br><span class="line">&lt; E</span><br><span class="line">&gt; D</span><br><span class="line">&gt; C</span><br></pre></td></tr></table></figure><p>有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。</p><h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><p>Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个交互命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 <code>git ad</code>d 时使用 <code>-i</code> 或者 <code>--interactive</code> 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add -i</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure><p>可以看到这个命令以非常不同的视图显示了暂存区——基本上与 <code>git status</code> 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。</p><p>在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。</p><h4 id="暂存与取消暂存文件"><a href="#暂存与取消暂存文件" class="headerlink" title="暂存与取消暂存文件"></a>暂存与取消暂存文件</h4><p>如果在 <code>What now&gt;</code> 提示符后键入 <code>2</code> 或 <code>u</code>，脚本将会提示想要暂存哪个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 2</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure><p>要暂存 TODO 与 index.html 文件，可以输入数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt; 1,2</span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:    unchanged        +0/-1 TODO</span><br><span class="line">* 2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Update&gt;&gt;</span><br></pre></td></tr></table></figure><p>每个文件前面的 <code>*</code> 意味着选中的文件将会被暂存。 如果在 <code>Update&gt;&gt;</code> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Update&gt;&gt;</span><br><span class="line">updated 2 paths</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure><p>现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 <code>3</code> 或 <code>r</code>（撤消）选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 3</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line">Revert&gt;&gt; [enter]</span><br><span class="line">reverted one path</span><br></pre></td></tr></table></figure><p>再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure><p>如果想要查看已暂存内容的区别，可以使用 <code>6</code> 或 <code>d</code>（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 <code>git diff --cached</code> 非常相似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: status     2: update      3: revert     4: add untracked</span><br><span class="line">  5: patch      6: diff        7: quit       8: help</span><br><span class="line">What now&gt; 6</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +1/-1      nothing index.html</span><br><span class="line">Review diff&gt;&gt; 1</span><br><span class="line">diff --git a/index.html b/index.html</span><br><span class="line">index 4d07108..4335f49 100644</span><br><span class="line">--- a/index.html</span><br><span class="line">+++ b/index.html</span><br><span class="line">@@ -16,7 +16,7 @@ Date Finder</span><br><span class="line"></span><br><span class="line"> &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;</span><br><span class="line">+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure><p>通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。</p><h4 id="暂存补丁"><a href="#暂存补丁" class="headerlink" title="暂存补丁"></a>暂存补丁</h4><p>Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 <code>5</code> 或 <code>p</code>（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index dd5ecc4..57399e0 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -22,7 +22,7 @@ class SimpleGit</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def log(treeish = &apos;master&apos;)</span><br><span class="line">-    command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def blame(path)</span><br><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</span><br></pre></td></tr></table></figure><p>这时有很多选项。 输入 <code>?</code> 显示所有可以使用的命令列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">a - stage this and all the remaining hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure><p>通常情况下可以输入 <code>y</code> 或 <code>n</code> 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:        +1/-1        +4/-0 lib/simplegit.rb</span><br></pre></td></tr></table></figure><p>simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 <code>git commit</code> 来提交部分暂存的文件。</p><p>也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code> 来启动同样的脚本。</p><p>更进一步地，可以使用 <code>reset --patch</code> 命令的补丁模式来部分重置文件，通过 <code>checkout --patch</code> 命令来部分检出文件与 <code>stash save --patch</code> 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。</p><h3 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h3><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p><p>储藏会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。</p><h4 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a>储藏工作</h4><p>为了演示，进入项目并改动几个文件，然后可能暂存其中的一个改动。 如果运行 <code>git status</code>，可以看到有改动的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   index.html</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   lib/simplegit.rb</span><br></pre></td></tr></table></figure><p>现在想要切换分支，但是还不想要提交之前的工作；所以储藏修改。 将新的储藏推送到栈上，运行 <code>git stash</code> 或 <code>git stash save</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \</span><br><span class="line">  &quot;WIP on master: 049d078 added the index file&quot;</span><br><span class="line">HEAD is now at 049d078 added the index file</span><br><span class="line">(To restore them type &quot;git stash apply&quot;)</span><br></pre></td></tr></table></figure><p>工作目录是干净的了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>在这时，你能够轻易地切换分支并在其他地方工作；你的修改被存储在栈上。 要查看储藏的东西，可以使用 <code>git stash list</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br></pre></td></tr></table></figure><p>在本例中，有两个之前做的储藏，所以你接触到了三个不同的储藏工作。 可以通过原来 <code>stash</code> 命令的帮助提示中的命令将你刚刚储藏的工作重新应用：<code>git stash apply</code>。 如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：<code>git stash apply stash@{2}</code>。 如果不指定一个储藏，Git 认为指定的是最近的储藏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line"># On branch master</span><br><span class="line"># Changed but not updated:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>可以看到 Git 重新修改了当你保存储藏时撤消的文件。 在本例中，当尝试应用储藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支；但是有一个干净的工作目录与应用在同一分支并不是成功应用储藏的充分必要条件。 可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用储藏时工作目录中也可以有修改与未提交的文件——如果有任何东西不能干净地应用，Git 会产生合并冲突。</p><p>文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 <code>--index</code> 选项来运行 <code>git stash apply</code> 命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply --index</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changed but not updated:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>应用选项只会尝试应用暂存的工作——在堆栈上还有它。 可以运行 <code>git stash drop</code> 加上将要移除的储藏的名字来移除它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><p>也可以运行 <code>git stash pop</code> 来应用储藏然后立即从栈上扔掉它。</p><h4 id="创造性的储藏"><a href="#创造性的储藏" class="headerlink" title="创造性的储藏"></a>创造性的储藏</h4><p>有几个储藏的变种可能也很有用。 第一个非常流行的选项是 <code>stash save</code> 命令的 <code>--keep-index</code> 选项。 它告诉 Git 不要储藏任何你通过 <code>git add</code> 命令已暂存的东西。</p><p>当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  index.html</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">$ git stash --keep-index</span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br><span class="line">HEAD is now at 1b65b17 added the index file</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">M  index.html</span><br></pre></td></tr></table></figure><p>另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。 默认情况下，<code>git stash</code> 只会储藏已经在索引中的文件。 如果指定 <code>--include-untracked</code> 或 <code>-u</code> 标记，Git 也会储藏任何创建的未跟踪文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  index.html</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line">?? new-file.txt</span><br><span class="line"></span><br><span class="line">$ git stash -u</span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br><span class="line">HEAD is now at 1b65b17 added the index file</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>最终，如果指定了 <code>--patch</code> 标记，Git 不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git stash --patch</span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index 66d332e..8bb5674 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -16,6 +16,10 @@ class SimpleGit</span><br><span class="line">         return `#&#123;git_cmd&#125; 2&gt;&amp;1`.chomp</span><br><span class="line">       end</span><br><span class="line">     end</span><br><span class="line">+</span><br><span class="line">+    def show(treeish = &apos;master&apos;)</span><br><span class="line">+      command(&quot;git show #&#123;treeish&#125;&quot;)</span><br><span class="line">+    end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line"> test</span><br><span class="line">Stash this hunk [y,n,q,a,d,/,e,?]? y</span><br><span class="line"></span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br></pre></td></tr></table></figure><h4 id="从储藏创建一个分支"><a href="#从储藏创建一个分支" class="headerlink" title="从储藏创建一个分支"></a>从储藏创建一个分支</h4><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash branch testchanges</span><br><span class="line">Switched to a new branch &quot;testchanges&quot;</span><br><span class="line"># On branch testchanges</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#      modified:   index.html</span><br><span class="line">#</span><br><span class="line"># Changed but not updated:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#</span><br><span class="line">#      modified:   lib/simplegit.rb</span><br><span class="line">#</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><p>这是在新分支轻松恢复储藏工作并继续工作的一个很不错的途径。</p><h4 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h4><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。 <code>git clean</code> 命令会帮你做这些事。</p><p>有一些通用的原因比如说为了移除由合并或外部工具生成的东西，或是为了运行一个干净的构建而移除之前构建的残留。</p><p>你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 <code>git stash --all</code> 来移除每一样东西并存放在栈中。</p><p>你可以使用 <code>git clean</code> 命令去除冗余文件或者清理工作目录。 使用 <code>git clean -f -d</code> 命令来移除工作目录中所有未追踪的文件以及空的子目录。 <code>-f</code> 意味着 强制 或 “确定移除”。</p><p>如果只是想要看看它会做什么，可以使用 <code>-n</code> 选项来运行命令，这意味着 “做一次演习然后告诉你 将要 移除什么”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -d -n</span><br><span class="line">Would remove test.o</span><br><span class="line">Would remove tmp/</span><br></pre></td></tr></table></figure><p>默认情况下，<code>git clean</code> 命令只会移除没有忽略的未跟踪文件。 任何与 <code>.gitiignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 <code>.o</code> 文件，可以给 <code>clean</code> 命令增加一个 <code>-x</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line">?? build.TMP</span><br><span class="line">?? tmp/</span><br><span class="line"></span><br><span class="line">$ git clean -n -d</span><br><span class="line">Would remove build.TMP</span><br><span class="line">Would remove tmp/</span><br><span class="line"></span><br><span class="line">$ git clean -n -d -x</span><br><span class="line">Would remove build.TMP</span><br><span class="line">Would remove test.o</span><br><span class="line">Would remove tmp/</span><br></pre></td></tr></table></figure><p>如果不知道 <code>git clean</code> 命令将会做什么，在将 <code>-n</code> 改为 <code>-f</code> 来真正做之前总是先用 <code>-n</code> 来运行它做双重检查。 另一个小心处理过程的方式是使用 <code>-i</code> 或 “interactive” 标记来运行它。</p><p>这将会以交互模式运行 <code>clean</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -x -i</span><br><span class="line">Would remove the following items:</span><br><span class="line">  build.TMP  test.o</span><br><span class="line">*** Commands ***</span><br><span class="line">    1: clean    2: filter by pattern    3: select by numbers    4: ask each    5: quit    6: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure><p>这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。</p><h3 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h3><p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。</p><h4 id="GPG-介绍"><a href="#GPG-介绍" class="headerlink" title="GPG 介绍"></a>GPG 介绍</h4><p>首先，在开始签名之前你需要先配置 GPG 并安装个人密钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line">/Users/schacon/.gnupg/pubring.gpg</span><br><span class="line">---------------------------------</span><br><span class="line">pub   2048R/0A46826A 2014-06-04</span><br><span class="line">uid                  Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line">sub   2048R/874529A9 2014-06-04</span><br></pre></td></tr></table></figure><p>如果你还没有安装一个密钥，可以使用 <code>gpg --gen-key</code> 生成一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure><p>一旦你有一个可以签署的私钥，可以通过设置 Git 的 <code>user.signingkey</code> 选项来签署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.signingkey 0A46826A</span><br></pre></td></tr></table></figure><p>现在 Git 默认使用你的密钥来签署标签与提交。</p><h4 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h4><p>如果已经设置好一个 GPG 私钥，可以使用它来签署新的标签。 所有需要做的只是使用 <code>-s</code> 代替 <code>-a</code> 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Ben Straub &lt;ben@straub.cc&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 800430EB, created 2014-05-04</span><br></pre></td></tr></table></figure><p>如果在那个标签上运行 <code>git show</code>，会看到你的 GPG 签名附属在后面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.5</span><br><span class="line">tag v1.5</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:29:41 2014 -0700</span><br><span class="line"></span><br><span class="line">my signed 1.5 tag</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut</span><br><span class="line">LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b</span><br><span class="line">hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm</span><br><span class="line">ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp</span><br><span class="line">8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi</span><br><span class="line">RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=</span><br><span class="line">=EFTF</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><h4 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h4><p>要验证一个签署的标签，可以运行 <code>git tag -v [tag-name]</code>。 这个命令使用 GPG 来验证签名。 为了验证能正常工作，签署者的公钥需要在你的钥匙链中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -v v1.4.2.1</span><br><span class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line">type commit</span><br><span class="line">tag v1.4.2.1</span><br><span class="line">tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700</span><br><span class="line"></span><br><span class="line">GIT 1.4.2.1</span><br><span class="line"></span><br><span class="line">Minor fixes since 1.4.2, including git-mv and git-http with alternates.</span><br><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;</span><br><span class="line">gpg:                 aka &quot;[jpeg image of size 1513]&quot;</span><br><span class="line">Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</span><br></pre></td></tr></table></figure><p>如果没有签署者的公钥，那么你将会得到类似下面的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can&apos;t check signature: public key not found</span><br><span class="line">error: could not verify the tag &apos;v1.4.2.1&apos;</span><br></pre></td></tr></table></figure><h4 id="签署提交"><a href="#签署提交" class="headerlink" title="签署提交"></a>签署提交</h4><p>在最新版本的 Git 中（v1.7.9 及以上），也可以签署个人提交。 如果相对于标签而言你对直接签署到提交更感兴趣的话，所有要做的只是增加一个 <code>-S</code> 到 <code>git commit</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -S -m &apos;signed commit&apos;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 0A46826A, created 2014-06-04</span><br><span class="line"></span><br><span class="line">[master 5c3386c] signed commit</span><br><span class="line"> 4 files changed, 4 insertions(+), 24 deletions(-)</span><br><span class="line"> rewrite Rakefile (100%)</span><br><span class="line"> create mode 100644 lib/git.rb</span><br><span class="line">git log 也有一个 --show-signature 选项来查看及验证这些签名。</span><br><span class="line"></span><br><span class="line">$ git log --show-signature -1</span><br><span class="line">commit 5c3386cf54bba0a33a32da706aa52bc0155503c2</span><br><span class="line">gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A</span><br><span class="line">gpg: Good signature from &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Jun 4 19:49:17 2014 -0700</span><br><span class="line"></span><br><span class="line">    signed commit</span><br></pre></td></tr></table></figure><p>另外，也可以配置 <code>git log</code> 来验证任何找到的签名并将它们以 <code>%G?</code> 格式列在输出中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=&quot;format:%h %G? %aN  %s&quot;</span><br><span class="line"></span><br><span class="line">5c3386c G Scott Chacon  signed commit</span><br><span class="line">ca82a6d N Scott Chacon  changed the version number</span><br><span class="line">085bb3b N Scott Chacon  removed unnecessary test code</span><br><span class="line">a11bef0 N Scott Chacon  first commit</span><br></pre></td></tr></table></figure><p>这里我们可以看到只有最后一次提交是签署并有效的，而之前的提交都不是。</p><p>在 Git 1.8.3 及以后的版本中，“git merge” 与“git pull” 可以使用 <code>--verify-signatures</code> 选项来检查并拒绝没有携带可信 GPG 签名的提交。</p><p>如果使用这个选项来合并一个包含未签名或有效的提交的分支时，合并不会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --verify-signatures non-verify</span><br><span class="line">fatal: Commit ab06180 does not have a GPG signature.</span><br></pre></td></tr></table></figure><p>如果合并包含的只有有效的签名的提交，合并命令会提示所有的签名它已经检查过了然后会继续向前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --verify-signatures signed-branch</span><br><span class="line">Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line">Updating 5c3386c..13ad65e</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>也可以给 <code>git merge</code> 命令附加 <code>-S</code> 选项来签署自己生成的合并提交。 下面的例子演示了验证将要合并的分支的每一个提交都是签名的并且签署最后生成的合并提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --verify-signatures -S  signed-branch</span><br><span class="line">Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 0A46826A, created 2014-06-04</span><br><span class="line"></span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> README | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><h4 id="每个人必须签署"><a href="#每个人必须签署" class="headerlink" title="每个人必须签署"></a>每个人必须签署</h4><p>签署标签与提交很棒，但是如果决定在正常的工作流程中使用它，你必须确保团队中的每一个人都理解如何这样做。 如果没有，你将会花费大量时间帮助其他人找出并用签名的版本重写提交。 在采用签署成为标准工作流程的一部分前，确保你完全理解 GPG 及签署带来的好处。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。 我们来简单的看一下。</p><h4 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h4><p>Git 提供了一个 <code>grep</code> 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。</p><p>默认情况下 Git 会查找你工作目录的文件。 你可以传入 <code>-n</code> 参数来输出 Git 所找到的匹配行行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -n gmtime_r</span><br><span class="line">compat/gmtime.c:3:#undef gmtime_r</span><br><span class="line">compat/gmtime.c:8:      return git_gmtime_r(timep, &amp;result);</span><br><span class="line">compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)</span><br><span class="line">compat/gmtime.c:16:     ret = gmtime_r(timep, result);</span><br><span class="line">compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm *result)</span><br><span class="line">compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm *result);</span><br><span class="line">date.c:429:             if (gmtime_r(&amp;now, &amp;now_tm))</span><br><span class="line">date.c:492:             if (gmtime_r(&amp;time, tm)) &#123;</span><br><span class="line">git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm *);</span><br><span class="line">git-compat-util.h:723:#define gmtime_r git_gmtime_r</span><br></pre></td></tr></table></figure><p><code>grep</code> 命令有一些有趣的选项。</p><p>例如，你可以使用 <code>--count</code> 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git grep --count gmtime_r</span><br><span class="line">compat/gmtime.c:4</span><br><span class="line">compat/mingw.c:1</span><br><span class="line">compat/mingw.h:1</span><br><span class="line">date.c:2</span><br><span class="line">git-compat-util.h:2</span><br></pre></td></tr></table></figure><p>如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 <code>-p</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -p gmtime_r *.c</span><br><span class="line">date.c=static int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)</span><br><span class="line">date.c:         if (gmtime_r(&amp;now, &amp;now_tm))</span><br><span class="line">date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)</span><br><span class="line">date.c:         if (gmtime_r(&amp;time, tm)) &#123;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到在 date.c 文件中有 <code>match_multi_number</code> 和 <code>match_digit</code> 两个函数调用了 <code>gmtime_r</code>。</p><p>你还可以使用 <code>--and</code> 标志来查看复杂的字符串组合，也就是在同一行同时包含多个匹配。 比如，我们要查看在旧版本 1.8.0 的 Git 代码库中定义了常量名包含 “LINK” 或者 “BUF_MAX” 这两个字符串所在的行。</p><p>这里我们也用到了 <code>--break</code> 和 <code>--heading</code> 选项来使输出更加容易阅读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git grep --break --heading \</span><br><span class="line">    -n -e &apos;#define&apos; --and \( -e LINK -e BUF_MAX \) v1.8.0</span><br><span class="line">v1.8.0:builtin/index-pack.c</span><br><span class="line">62:#define FLAG_LINK (1u&lt;&lt;20)</span><br><span class="line"></span><br><span class="line">v1.8.0:cache.h</span><br><span class="line">73:#define S_IFGITLINK  0160000</span><br><span class="line">74:#define S_ISGITLINK(m)       (((m) &amp; S_IFMT) == S_IFGITLINK)</span><br><span class="line"></span><br><span class="line">v1.8.0:environment.c</span><br><span class="line">54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS</span><br><span class="line"></span><br><span class="line">v1.8.0:strbuf.c</span><br><span class="line">326:#define STRBUF_MAXLINK (2*PATH_MAX)</span><br><span class="line"></span><br><span class="line">v1.8.0:symlinks.c</span><br><span class="line">53:#define FL_SYMLINK  (1 &lt;&lt; 2)</span><br><span class="line"></span><br><span class="line">v1.8.0:zlib.c</span><br><span class="line">30:/* #define ZLIB_BUF_MAX ((uInt)-1) */</span><br><span class="line">31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</span><br></pre></td></tr></table></figure><p>相比于一些常用的搜索命令比如 <code>grep</code> 和 <code>ack</code>，<code>git grep</code> 命令有一些的优点。 第一就是速度非常快，第二是你不仅仅可以可以搜索工作目录，还可以搜索任意的 Git 树。 在上一个例子中，我们在一个旧版本的 Git 源代码中查找，而不是当前检出的版本。</p><h4 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h4><p>或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。 <code>git log</code> 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p><p>例如，如果我们想找到 <code>ZLIB_BUF_MAX</code> 常量是什么时候引入的，我们可以使用 <code>-S</code> 选项来显示新增和删除该字符串的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log -SZLIB_BUF_MAX --oneline</span><br><span class="line">e01503b zlib: allow feeding more than 4GB in one go</span><br><span class="line">ef49a7a zlib: zlib can only process 4GB at a time</span><br></pre></td></tr></table></figure><p>如果我们查看这些提交的 diff，我们可以看到在 <code>ef49a7a</code> 这个提交引入了常量，并且在 <code>e01503b</code> 这个提交中被修改了。</p><p>如果你希望得到更精确的结果，你可以使用 <code>-G</code> 选项来使用正则表达式搜索。</p><p><strong>行日志搜索</strong><br>行日志搜索是另一个相当高级并且有用的日志搜索功能。 这是一个最近新增的不太知名的功能，但却是十分有用。 在 <code>git log</code> 后加上 <code>-L</code> 选项即可调用，它可以展示代码中一行或者一个函数的历史。</p><p>例如，假设我们想查看 <code>zlib.c</code> 文件中<code>git_deflate_bound</code> 函数的每一次变更，我们可以执行 <code>git log -L :git_deflate_bound:zlib.c</code>。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ git log -L :git_deflate_bound:zlib.c</span><br><span class="line">commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca</span><br><span class="line">Author: Junio C Hamano &lt;gitster@pobox.com&gt;</span><br><span class="line">Date:   Fri Jun 10 11:52:15 2011 -0700</span><br><span class="line"></span><br><span class="line">    zlib: zlib can only process 4GB at a time</span><br><span class="line"></span><br><span class="line">diff --git a/zlib.c b/zlib.c</span><br><span class="line">--- a/zlib.c</span><br><span class="line">+++ b/zlib.c</span><br><span class="line">@@ -85,5 +130,5 @@</span><br><span class="line">-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)</span><br><span class="line">+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)</span><br><span class="line"> &#123;</span><br><span class="line">-       return deflateBound(strm, size);</span><br><span class="line">+       return deflateBound(&amp;strm-&gt;z, size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit 225a6f1068f71723a910e8565db4e252b3ca21fa</span><br><span class="line">Author: Junio C Hamano &lt;gitster@pobox.com&gt;</span><br><span class="line">Date:   Fri Jun 10 11:18:17 2011 -0700</span><br><span class="line"></span><br><span class="line">    zlib: wrap deflateBound() too</span><br><span class="line"></span><br><span class="line">diff --git a/zlib.c b/zlib.c</span><br><span class="line">--- a/zlib.c</span><br><span class="line">+++ b/zlib.c</span><br><span class="line">@@ -81,0 +85,5 @@</span><br><span class="line">+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)</span><br><span class="line">+&#123;</span><br><span class="line">+       return deflateBound(strm, size);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure><p>如果 Git 无法计算出如何匹配你代码中的函数或者方法，你可以提供一个正则表达式。 例如，这个命令和上面的是等同的：<code>git log -L &#39;/unsigned long git_deflate_bound/&#39;,/^}/:zlib.c</code>。 你也可以提供单行或者一个范围的行号来获得相同的输出。</p><h3 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h3><p>许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，或完全地移除提交——在将你的工作成果与他人共享之前。</p><p>在本节中，你可以学到如何完成这些非常有用的工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。</p><h4 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h4><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。</p><p>如果，你只是想修改最近一次提交的提交信息，那么很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。 当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。</p><p>如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行 <code>git add</code> 或 <code>git rm</code> 一个已追踪的文件，随后运行 <code>git commit --amend</code> 拿走当前的暂存区域并使其做为新提交的快照。</p><p>使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。</p><h4 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h4><p>为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 <code>git rebase</code> 增加 <code>-i</code> 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。</p><p>例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给 <code>git rebase -i</code> 命令，即 <code>HEAD~2^</code> 或 <code>HEAD~3</code>。 记住 <code>~3</code> 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>再次记住这是一个变基命令——在 <code>HEAD~3..HEAD</code> 范围内的每一个提交都会被重写，无论你是否修改信息。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。</p><p>运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"></span><br><span class="line"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure><p>需要重点注意的是相对于正常使用的 <code>log</code> 命令，这些提交显示的顺序是相反的。 运行一次 <code>log</code> 命令，会看到类似这样的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEAD</span><br><span class="line">a5f4a0d added cat-file</span><br><span class="line">310154e updated README formatting and added blame</span><br><span class="line">f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure><p>注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（<code>HEAD~3</code>）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。</p><p>你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure><p>当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br><span class="line">Stopped at f7f3f6d... changed my name a bit</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">       git commit --amend</span><br><span class="line"></span><br><span class="line">Once you’re satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">       git rebase --continue</span><br></pre></td></tr></table></figure><p>这些指令准确地告诉你该做什么。 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>修改提交信息，然后退出编辑器。 然后，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure><p>这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。</p><h4 id="重新排序提交"><a href="#重新排序提交" class="headerlink" title="重新排序提交"></a>重新排序提交</h4><p>也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure><p>改为这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure><p>当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 <code>310154e</code> 然后应用 <code>f7f3f6d</code>，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。</p><h4 id="压缩提交"><a href="#压缩提交" class="headerlink" title="压缩提交"></a>压缩提交</h4><p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure><p>如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">squash 310154e updated README formatting and added blame</span><br><span class="line">squash a5f4a0d added cat-file</span><br></pre></td></tr></table></figure><p>当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># The first commit&apos;s message is:</span><br><span class="line">changed my name a bit</span><br><span class="line"></span><br><span class="line"># This is the 2nd commit message:</span><br><span class="line"></span><br><span class="line">updated README formatting and added blame</span><br><span class="line"></span><br><span class="line"># This is the 3rd commit message:</span><br><span class="line"></span><br><span class="line">added cat-file</span><br></pre></td></tr></table></figure><p>当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。</p><h4 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h4><p>拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 <code>rebase -i</code> 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">edit 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure><p>然后，当脚本将你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（<code>f7f3f6d</code>），应用第二个提交（<code>310154e</code>），然后让你进入命令行。 那里，可以通过 <code>git reset HEAD^</code> 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件未暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 <code>git rebase --continue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &apos;updated README formatting&apos;</span><br><span class="line">$ git add lib/simplegit.rb</span><br><span class="line">$ git commit -m &apos;added blame&apos;</span><br><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure><p>Git 在脚本中应用最后一次提交（<code>a5f4a0d</code>），历史记录看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log -4 --pretty=format:&quot;%h %s&quot;</span><br><span class="line">1c002dd added cat-file</span><br><span class="line">9b29157 added blame</span><br><span class="line">35cfb2b updated README formatting</span><br><span class="line">f3cc40e changed my name a bit</span><br></pre></td></tr></table></figure><p>再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。</p><h4 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h4><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 <code>filter-branch</code>，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。</p><p><strong>从每一个提交移除一个文件</strong><br>这经常发生。 有人粗心地通过 <code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除它。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 <code>filter-branch</code> 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 <code>--tree-filter</code> 选项给 <code>filter-branch</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</span><br><span class="line">Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)</span><br><span class="line">Ref &apos;refs/heads/master&apos; was rewritten</span><br></pre></td></tr></table></figure><p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 <code>git filter-branch --tree-filter &#39;rm -f *~&#39; HEAD</code> 的命令。</p><p>最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 <code>filter-branch</code> 在所有分支上运行，可以给命令传递 <code>--all</code> 选项。</p><p><strong>使一个子目录做为新的根目录</strong><br>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，<code>filter-branch</code> 也可以帮助你那么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --subdirectory-filter trunk HEAD</span><br><span class="line">Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)</span><br><span class="line">Ref &apos;refs/heads/master&apos; was rewritten</span><br></pre></td></tr></table></figure><p>现在新项目根目录是 <code>trunk</code> 子目录了。 Git 会自动移除所有不影响子目录的提交。</p><p><strong>全局修改邮箱地址</strong><br>另一个常见的情形是在你开始工作时忘记运行 <code>git config</code> 来设置你的名字与邮箱地址，或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 <code>filter-branch</code> 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 <code>--commit-filter</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --commit-filter &apos;</span><br><span class="line">        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&apos; HEAD</span><br></pre></td></tr></table></figure><p>这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和，而不仅仅只是那些匹配邮箱地址的提交。</p><h3 id="重置揭密"><a href="#重置揭密" class="headerlink" title="重置揭密"></a>重置揭密</h3><p>在继续了解更专业的工具前，我们先讨论一下 <code>reset</code> 与 <code>checkout</code>。 在你初次遇到的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。</p><h4 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h4><p>理解 <code>reset</code> 和 <code>checkout</code> 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）</p><p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p><table><thead><tr><th>树</th><th>用途</th></tr></thead><tbody><tr><td>HEAD</td><td>上一次提交的快照，下一次提交的父结点</td></tr><tr><td>Index</td><td>预期的下一次提交的快照</td></tr><tr><td>Working Directory</td><td>沙盒</td></tr></tbody></table><p><strong>HEAD</strong><br>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。</p><p>其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">author Scott Chacon  1301511835 -0700</span><br><span class="line">committer Scott Chacon  1301511835 -0700</span><br><span class="line"></span><br><span class="line">initial commit</span><br><span class="line"></span><br><span class="line">$ git ls-tree -r HEAD</span><br><span class="line">100644 blob a906cb2a4a904a152...   README</span><br><span class="line">100644 blob 8f94139338f9404f2...   Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19...   lib</span><br></pre></td></tr></table></figure><p><code>cat-file</code> 与 <code>ls-tree</code> 是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。</p><p><strong>索引</strong><br>索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区域”，这就是当你运行 <code>git commit</code> 时 Git 看起来的样子。</p><p>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 <code>git commit</code> 将它们转换为树来用作新的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 a906cb2a4a904a152e80877d4088654daad0c859 0README</span><br><span class="line">100644 8f94139338f9404f26296befa88755fc2598c289 0Rakefile</span><br><span class="line">100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0lib/simplegit.rb</span><br></pre></td></tr></table></figure><p>再说一次，我们在这里又用到了 <code>ls-files</code> 这个幕后的命令，它会显示出索引当前的样子。</p><p>确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。</p><p><strong>工作目录</strong><br>最后，你就有了自己的工作目录。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 <code>.git</code> 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── README</span><br><span class="line">├── Rakefile</span><br><span class="line">└── lib</span><br><span class="line">    └── simplegit.rb</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>Git 主要的目的是通过操纵这三棵树来以更加连续的状态记录项目的快照。</p><p><img src="git-chapter-7/img1.png" alt></p><p>让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 <code>git init</code>，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（<code>master</code> 还不存在）。</p><p><img src="git-chapter-7/img2.png" alt></p><p>此时，只有工作目录有内容。</p><p>现在我们想要提交这个文件，所以用 <code>git add</code> 来获取工作目录中的内容，并将其复制到索引中。</p><p><img src="git-chapter-7/img3.png" alt></p><p>接着运行 <code>git commit</code>，它会取得索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 <code>master</code> 来指向本次提交。</p><p><img src="git-chapter-7/img4.png" alt></p><p>此时如果我们运行 <code>git status</code>，会发现没有任何改动，因为现在三棵树完全相同。</p><p>现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。</p><p><img src="git-chapter-7/img5.png" alt></p><p>如果现在运行 <code>git status</code>，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 <code>git add</code> 来将它暂存到索引中。</p><p><img src="git-chapter-7/img6.png" alt></p><p>此时，由于索引和 HEAD 不同，若运行 <code>git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 <code>git commit</code> 来完成提交。</p><p><img src="git-chapter-7/img7.png" alt></p><p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了。</p><p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。</p><h4 id="重置的作用"><a href="#重置的作用" class="headerlink" title="重置的作用"></a>重置的作用</h4><p>在以下情景中观察 <code>reset</code> 命令会更有意义。</p><p>为了演示这些例子，假设我们再次修改了 <code>file.txt</code> 文件并第三次提交它。 现在的历史看起来是这样的：</p><p><img src="git-chapter-7/img8.png" alt></p><p>让我们跟着 <code>reset</code> 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。</p><p><strong>第 1 步：移动 HEAD</strong><br><code>reset</code> 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（<code>checkout</code> 所做的）；<code>reset</code> 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 <code>master</code> 分支（例如，你正在 <code>master</code> 分支上），运行 <code>git reset 9e5e6a4</code> 将会使 <code>master</code> 指向 <code>9e5e6a4</code>。</p><p><img src="git-chapter-7/img9.png" alt></p><p>无论你调用了何种形式的带有一个提交的 <code>reset</code>，它首先都会尝试这样做。 使用 <code>reset --soft</code>，它将仅仅停在那儿。</p><p>现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code>git commit</code> 命令。 当你在运行 <code>git commit</code> 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 <code>reset</code> 回 <code>HEAD~</code>（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit --amend</code> 所要做的事情了（见 修改最后一次提交）。</p><p><strong>第 2 步：更新索引（–mixed）</strong><br>注意，如果你现在运行 <code>git status</code> 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。</p><p>接下来，<code>reset</code> 会用 HEAD 指向的当前快照的内容来更新索引。</p><p><img src="git-chapter-7/img10.png" alt></p><p>如果指定 <code>--mixed</code> 选项，<code>reset</code> 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 <code>git reset HEAD~</code>），这就是命令将会停止的地方。</p><p>现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 <code>git add</code> 和 <code>git commit</code> 的命令执行之前。</p><p><strong>第 3 步：更新工作目录（–hard）</strong><br><code>reset</code> 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 <code>--hard</code> 选项，它将会继续这一步。</p><p><img src="git-chapter-7/img11.png" alt></p><p>现在让我们回想一下刚才发生的事情。 你撤销了最后的提交 <code>git add</code> 和 <code>git commit</code> 命令以及工作目录中的所有工作。</p><p>必须注意，<code>--hard</code> 标记是 <code>reset</code> 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 <code>reset</code> 调用都可以轻松撤消，但是 <code>--hard</code> 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本，我们可以通过 <code>reflog</code> 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。</p><p><strong>回顾</strong><br><code>reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p><ol><li><p>移动 HEAD 分支的指向 （若指定了 <code>--soft</code>，则到此停止）</p></li><li><p>使索引看起来像 HEAD （若未指定 <code>--hard</code>，则到此停止）</p></li><li><p>使工作目录看起来像索引</p></li></ol><h4 id="通过路径来重置"><a href="#通过路径来重置" class="headerlink" title="通过路径来重置"></a>通过路径来重置</h4><p>前面讲述了 <code>reset</code> 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，<code>reset</code> 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。</p><p>现在，假如我们运行 <code>git reset file.txt</code> （这其实是 <code>git reset --mixed HEAD file.txt</code> 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 <code>--soft</code> 或 <code>--hard</code>），它会：</p><ol><li><p>移动 HEAD 分支的指向 （已跳过）</p></li><li><p>让索引看起来像 HEAD （到此处停止）</p></li></ol><p>所以它本质上只是将 <code>file.txt</code> 从 HEAD 复制到索引中。</p><p><img src="git-chapter-7/img12.png" alt></p><p>它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 <code>git add</code> 所做的事，就会发现它们正好相反。</p><p><img src="git-chapter-7/img13.png" alt></p><p>这就是为什么 <code>git status</code> 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）</p><p>我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 <code>git reset eb43bf file.txt</code> 的命令即可。</p><p><img src="git-chapter-7/img14.png" alt></p><p>它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 <code>git add</code> 添加它，然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 <code>git commit</code>，它就会记录一条“将该文件恢复到 v1 版本”的更改，尽管我们并未在工作目录中真正地再次拥有它。</p><p>还有一点同 <code>git add</code> 一样，就是 <code>reset</code> 命令也可以接受一个 <code>--patch</code> 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。</p><p>假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 <code>reset</code> 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）</p><p>假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。</p><p><img src="git-chapter-7/img15.png" alt></p><p>那么可以运行 <code>git reset --soft HEAD~2</code> 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的第一个提交）：</p><p><img src="git-chapter-7/img16.png" alt></p><p>然后只需再次运行 <code>git commit</code>：</p><p><img src="git-chapter-7/img17.png" alt></p><p>现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 <code>file-a.txt</code> 的提交，接着第二个提交将 <code>file-a.txt</code> 修改成了 v3 版并增加了 <code>file-b.txt</code>。 包含 v2 版本的文件已经不在历史中了。</p><h4 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h4><p>最后，你大概还想知道 <code>checkout</code> 和 <code>reset</code> 之间的区别。 和 <code>reset</code> 一样，<code>checkout</code> 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p><p><strong>不带路径</strong><br>运行 <code>git checkout [branch]</code> 与运行 <code>git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code>[branch]</code>，不过有两点重要的区别。</p><p>首先不同于 <code>reset --hard</code>，<code>checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。</p><p>第二个重要的区别是如何更新 HEAD。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 只会移动 HEAD 自身来指向另一个分支。</p><p>例如，假设我们有 <code>master</code> 和 <code>develop</code> 分支，它们分别指向不同的提交；我们现在在 <code>develop</code> 上（所以 HEAD 指向它）。 如果我们运行 <code>git reset master</code>，那么 <code>develop</code> 自身现在会和 <code>master</code> 指向同一个提交。 而如果我们运行 <code>git checkout master</code> 的话，<code>develop</code> 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 <code>master</code>。</p><p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 则移动 HEAD 自身。</p><p><img src="git-chapter-7/img18.png" alt></p><p><strong>带路径</strong><br>运行 <code>checkout</code> 的另一种方式就是指定一个文件路径，这会像 <code>reset</code> 一样不会移动 HEAD。 它就像 <code>git reset [branch] file</code> 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 <code>git reset --hard [branch] file</code>（如果 <code>reset</code> 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。</p><p>此外，同 <code>git reset</code> 和 <code>git add</code> 一样，<code>checkout</code> 也接受一个 <code>--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>希望你现在熟悉并理解了 <code>reset</code> 命令，不过关于它和 <code>checkout</code> 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。</p><p>下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。</p><table><thead><tr><th></th><th>HEAD</th><th>Index</th><th>Workdir</th><th>WD Safe?</th></tr></thead><tbody><tr><td><strong>Commit Level</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>reset –soft [commit]</td><td>REF</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>reset  [commit]</td><td>REF</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>reset –hard [commit]</td><td>REF</td><td>YES</td><td>YES</td><td><strong>NO</strong></td></tr><tr><td>checkout [commit]</td><td>HEAD</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td><strong>File  Level</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>reset (commit) [file]</td><td>NO</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>checkout (commit) [file]</td><td>NO</td><td>YES</td><td>YES</td><td><strong>NO</strong></td></tr></tbody></table><h3 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h3><p>在 Git 中合并是相当容易的。 因为 Git 使多次合并另一个分支变得很容易，这意味着你可以有一个始终保持最新的长期分支，经常解决小的冲突，比在一系列提交后解决一个巨大的冲突要好。</p><p>然而，有时也会有棘手的冲突。 不像其他的版本控制系统，Git 并不会尝试过于聪明的合并冲突解决方案。 Git 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。 因此，如果很久之后才合并两个分叉的分支，你可能会撞上一些问题。</p><p>在本节中，我们将会仔细查看那些问题是什么以及 Git 给了我们什么工具来帮助我们处理这些更难办的情形。我们也会了解你可以做的不同的、非标准类型的合并，也会看到如何后退到合并之前。</p><h4 id="高级合并-1"><a href="#高级合并-1" class="headerlink" title="高级合并"></a>高级合并</h4><p>我们在 遇到冲突时的分支合并 介绍了解决合并冲突的一些基础知识，对于更复杂的冲突，Git 提供了几个工具来帮助你指出将会发生什么以及如何更好地处理冲突。</p><p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。 如果你有正在做的工作，要么提交到一个临时分支要么储藏它。 这使你可以撤消在这里尝试做的 任何事情 。 如果在你尝试一次合并时工作目录中有未保存的改动，下面的这些技巧可能会使你丢失那些工作。</p><p>让我们通过一个非常简单的例子来了解一下。 我们有一个超级简单的打印 hello world 的 Ruby 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">  puts &apos;hello world&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>在我们的仓库中，创建一个名为 <code>whitespace</code> 的新分支并将所有 Unix 换行符修改为 DOS 换行符，实质上虽然改变了文件的每一行，但改变的都只是空白字符。 然后我们修改行 “hello world” 为 “hello mundo”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b whitespace</span><br><span class="line">Switched to a new branch &apos;whitespace&apos;</span><br><span class="line"></span><br><span class="line">$ unix2dos hello.rb</span><br><span class="line">unix2dos: converting file hello.rb to DOS format ...</span><br><span class="line">$ git commit -am &apos;converted hello.rb to DOS&apos;</span><br><span class="line">[whitespace 3270f76] converted hello.rb to DOS</span><br><span class="line"> 1 file changed, 7 insertions(+), 7 deletions(-)</span><br><span class="line"></span><br><span class="line">$ vim hello.rb</span><br><span class="line">$ git diff -b</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..e85207e 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,7 +1,7 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line"> def hello</span><br><span class="line">-  puts &apos;hello world&apos;</span><br><span class="line">+  puts &apos;hello mundo&apos;^M</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br><span class="line"></span><br><span class="line">$ git commit -am &apos;hello mundo change&apos;</span><br><span class="line">[whitespace 6d338d2] hello mundo change</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>现在我们切换回我们的 <code>master</code> 分支并为函数增加一些注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line"></span><br><span class="line">$ vim hello.rb</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..36c06c8 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">   puts &apos;hello world&apos;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line">$ git commit -am &apos;document the function&apos;</span><br><span class="line">[master bec6336] document the function</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>现在我们尝试合并入我们的 <code>whitespace</code> 分支，因为修改了空白字符，所以合并会出现冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge whitespace</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><h5 id="中断一次合并"><a href="#中断一次合并" class="headerlink" title="中断一次合并"></a>中断一次合并</h5><p>我们现在有几个选项。 首先，让我们介绍如何摆脱这个情况。 你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status -sb</span><br><span class="line">## master</span><br><span class="line">UU hello.rb</span><br><span class="line"></span><br><span class="line">$ git merge --abort</span><br><span class="line"></span><br><span class="line">$ git status -sb</span><br><span class="line">## master</span><br></pre></td></tr></table></figure><p><code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p><p>如果因为某些原因你发现自己处在一个混乱的状态中然后只是想要重来一次，也可以运行 <code>git reset --hard HEAD</code> 回到之前的状态或其他你想要恢复的状态。 请牢记这会将清除工作目录中的所有内容，所以确保你不需要保存这里的任意改动。</p><h5 id="忽略空白"><a href="#忽略空白" class="headerlink" title="忽略空白"></a>忽略空白</h5><p>在这个特定的例子中，冲突与空白有关。 我们知道这点是因为这个例子很简单，但是在实际的例子中发现这样的冲突也很容易，因为每一行都被移除而在另一边每一行又被加回来了。 默认情况下，Git 认为所有这些行都改动了，所以它不会合并文件。</p><p>默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。 如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用 <code>-Xignore-all-space</code> 或 <code>-Xignore-space-change</code> 选项。 第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -Xignore-space-change whitespace</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> hello.rb | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>因为在本例中，实际上文件修改并没有冲突，一旦我们忽略空白修改，每一行都能被很好地合并。</p><p>如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草。</p><h5 id="手动文件再合并"><a href="#手动文件再合并" class="headerlink" title="手动文件再合并"></a>手动文件再合并</h5><p>虽然 Git 对空白的预处理做得很好，还有很多其他类型的修改，Git 也许无法自动处理，但是脚本可以处理它们。 例如，假设 Git 无法处理空白修改因此我们需要手动处理。</p><p>我们真正想要做的是对将要合并入的文件在真正合并前运行 <code>dos2unix</code> 程序。 所以如果那样的话，我们该如何做？</p><p>首先，我们进入到了合并冲突状态。 然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。 然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。</p><p>获得这三个文件版本实际上相当容易。 Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。 Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 <code>MERGE_HEAD</code>，即你将要合并入的版本（“theirs”）。</p><p>通过 git show 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git show :1:hello.rb &gt; hello.common.rb</span><br><span class="line">$ git show :2:hello.rb &gt; hello.ours.rb</span><br><span class="line">$ git show :3:hello.rb &gt; hello.theirs.rb</span><br></pre></td></tr></table></figure><p>如果你想要更专业一点，也可以使用 <code>ls-files -u</code> 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -u</span><br><span class="line">100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1hello.rb</span><br><span class="line">100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2hello.rb</span><br><span class="line">100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3hello.rb</span><br></pre></td></tr></table></figure><p><code>:1:hello.rb</code> 只是查找那个 blob 对象 SHA-1 值的简写。</p><p>既然在我们的工作目录中已经有这所有三个阶段的内容，我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 <code>git merge-file</code> 命令来重新合并那个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ dos2unix hello.theirs.rb</span><br><span class="line">dos2unix: converting file hello.theirs.rb to Unix format ...</span><br><span class="line"></span><br><span class="line">$ git merge-file -p \</span><br><span class="line">    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb</span><br><span class="line"></span><br><span class="line">$ git diff -b</span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 36c06c8,e85207e..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,8 -1,7 +1,8 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line"> +# prints out a greeting</span><br><span class="line">  def hello</span><br><span class="line">-   puts &apos;hello world&apos;</span><br><span class="line">+   puts &apos;hello mundo&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure><p>在这时我们已经漂亮地合并了那个文件。 实际上，这比使用 <code>ignore-space-change</code> 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。 在使用 <code>ignore-space-change</code> 进行合并操作后，我们最终得到了有几行是 DOS 行尾的文件，从而使提交内容混乱了。</p><p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 <code>git diff</code> 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。 让我们看看它们。</p><p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --ours</span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index 36c06c8..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -2,7 +2,7 @@</span><br><span class="line"></span><br><span class="line"> # prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">-  puts &apos;hello world&apos;</span><br><span class="line">+  puts &apos;hello mundo&apos;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br></pre></td></tr></table></figure><p>这里我们可以很容易地看到在我们的分支上发生了什么，在这次合并中我们实际引入到这个文件的改动，是修改了其中一行。</p><p>如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code>。 在本例及后续的例子中，我们会使用 <code>-b</code> 来去除空白，因为我们将它与 Git 中的，而不是我们清理过的 <code>hello.theirs.rb</code> 文件比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --theirs -b</span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index e85207e..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">   puts &apos;hello mundo&apos;</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p>最终，你可以通过 <code>git diff --base</code> 来查看文件在两边是如何改动的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --base -b</span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,7 +1,8 @@</span><br><span class="line"> #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">-  puts &apos;hello world&apos;</span><br><span class="line">+  puts &apos;hello mundo&apos;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br></pre></td></tr></table></figure><p>在这时我们可以使用 <code>git clean</code> 命令来清理我们为手动合并而创建但不再有用的额外文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -f</span><br><span class="line">Removing hello.common.rb</span><br><span class="line">Removing hello.ours.rb</span><br><span class="line">Removing hello.theirs.rb</span><br></pre></td></tr></table></figure><h5 id="检出冲突"><a href="#检出冲突" class="headerlink" title="检出冲突"></a>检出冲突</h5><p>也许有时我们并不满意这样的解决方案，或许有时还要手动编辑一边或者两边的冲突，但还是依旧无法正常工作，这时我们需要更多的上下文关联来解决这些冲突。</p><p>让我们来稍微改动下例子。 对于本例，我们有两个长期分支，每一个分支都有几个提交，但是在合并时却创建了一个合理的冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --oneline --decorate --all</span><br><span class="line">* f1270f7 (HEAD, master) update README</span><br><span class="line">* 9af9d3b add a README</span><br><span class="line">* 694971d update phrase to hola world</span><br><span class="line">| * e3eb223 (mundo) add more tests</span><br><span class="line">| * 7cff591 add testing script</span><br><span class="line">| * c3ffff1 changed text to hello mundo</span><br><span class="line">|/</span><br><span class="line">* b7dcc89 initial hello world code</span><br></pre></td></tr></table></figure><p>现在有只在 <code>master</code> 分支上的三次单独提交，还有其他三次提交在 <code>mundo</code> 分支上。 如果我们尝试将 <code>mundo</code> 分支合并入 <code>master</code> 分支，我们得到一个冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge mundo</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>我们想要看一下合并冲突是什么。 如果我们打开这个文件，我们将会看到类似下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">  puts &apos;hola world&apos;</span><br><span class="line">=======</span><br><span class="line">  puts &apos;hello mundo&apos;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>合并的两边都向这个文件增加了内容，但是导致冲突的原因是其中一些提交修改了文件的同一个地方。</p><p>让我们探索一下现在你手边可用来查明这个冲突是如何产生的工具。 应该如何修复这个冲突看起来或许并不明显。 这时你需要更多上下文。</p><p>一个很有用的工具是带 <code>--conflict</code> 选项的 <code>git checkout</code>。 这会重新检出文件并替换合并冲突标记。 如果想要重置标记并尝试再次解决它们的话这会很有用。</p><p>可以传递给 <code>--conflict</code> 参数 <code>diff3</code> 或 <code>merge</code>（默认选项）。 如果传给它 <code>diff3</code>，Git 会使用一个略微不同版本的冲突标记：不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --conflict=diff3 hello.rb</span><br></pre></td></tr></table></figure><p>一旦我们运行它，文件看起来会像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours</span><br><span class="line">  puts &apos;hola world&apos;</span><br><span class="line">||||||| base</span><br><span class="line">  puts &apos;hello world&apos;</span><br><span class="line">=======</span><br><span class="line">  puts &apos;hello mundo&apos;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>如果你喜欢这种格式，可以通过设置 <code>merge.conflictstyle</code> 选项为 <code>diff3</code> 来做为以后合并冲突的默认选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.conflictstyle diff3</span><br></pre></td></tr></table></figure><p><code>git checkout</code> 命令也可以使用 <code>--ours</code> 和 <code>--theirs</code> 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。</p><p>当有二进制文件冲突时这可能会特别有用，因为可以简单地选择一边，或者可以只合并另一个分支的特定文件——可以做一次合并然后在提交前检出一边或另一边的特定文件。</p><h5 id="合并日志"><a href="#合并日志" class="headerlink" title="合并日志"></a>合并日志</h5><p>另一个解决合并冲突有用的工具是 <code>git log</code>。 这可以帮助你得到那些对冲突有影响的上下文。 回顾一点历史来记起为什么两条线上的开发会触碰同一片代码有时会很有用。</p><p>为了得到此次合并中包含的每一个分支的所有独立提交的列表，我们可以使用之前在 三点 学习的“三点”语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --left-right HEAD...MERGE_HEAD</span><br><span class="line">&lt; f1270f7 update README</span><br><span class="line">&lt; 9af9d3b add a README</span><br><span class="line">&lt; 694971d update phrase to hola world</span><br><span class="line">&gt; e3eb223 add more tests</span><br><span class="line">&gt; 7cff591 add testing script</span><br><span class="line">&gt; c3ffff1 changed text to hello mundo</span><br></pre></td></tr></table></figure><p>这个漂亮的列表包含 6 个提交和每一个提交所在的不同开发路径。</p><p>我们可以通过更加特定的上下文来进一步简化这个列表。 如果我们添加 <code>--merge</code> 选项到 <code>git log</code> 中，它会只显示任何一边接触了合并冲突文件的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --left-right --merge</span><br><span class="line">&lt; 694971d update phrase to hola world</span><br><span class="line">&gt; c3ffff1 changed text to hello mundo</span><br></pre></td></tr></table></figure><p>如果你运行命令时用 <code>-p</code> 选项代替，你会得到所有冲突文件的区别。 快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 非常 有用。</p><h5 id="组合式差异格式"><a href="#组合式差异格式" class="headerlink" title="组合式差异格式"></a>组合式差异格式</h5><p>因为 Git 暂存合并成功的结果，当你在合并冲突状态下运行 <code>git diff</code> 时，只会得到现在还在冲突状态的区别。 当需要查看你还需要解决哪些冲突时这很有用。</p><p>在合并冲突后直接运行的 <code>git diff</code> 会给你一个相当独特的输出格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,11 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> +  puts &apos;hola world&apos;</span><br><span class="line">++=======</span><br><span class="line">+   puts &apos;hello mundo&apos;</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure><p>这种叫作“组合式差异”的格式会在每一行给你两列数据。 第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除），第二列显示 “theirs” 分支与工作目录的拷贝区别。</p><p>所以在上面的例子中可以看到 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 与 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 行在工作拷贝中但是并不在合并的任意一边中。 这很有意义，合并工具因为我们的上下文被困住了，它期望我们去移除它们。</p><p>如果我们解决冲突再次运行 <code>git diff</code>，我们将会看到同样的事情，但是它有一点帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.rb</span><br><span class="line">$ git diff</span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &apos;hola world&apos;</span><br><span class="line"> -  puts &apos;hello mundo&apos;</span><br><span class="line">++  puts &apos;hola mundo&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure><p>这里显示出 “hola world” 在我们这边但不在工作拷贝中，那个 “hello mundo” 在他们那边但不在工作拷贝中，最终 “hola mundo” 不在任何一边但是现在在工作拷贝中。 在提交解决方案前这对审核很有用。</p><p>也可以在合并后通过 <code>git log</code> 来获取相同信息，并查看冲突是如何解决的。 如果你对一个合并提交运行 <code>git show</code> 命令 Git 将会输出这种格式，或者你也可以在 <code>git log -p</code>（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 <code>--cc</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git log --cc -p -1</span><br><span class="line">commit 14f41939956d80b9e17bb8721354c33f8d5b5a79</span><br><span class="line">Merge: f1270f7 e3eb223</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 19 18:14:49 2014 +0200</span><br><span class="line"></span><br><span class="line">    Merge branch &apos;mundo&apos;</span><br><span class="line"></span><br><span class="line">    Conflicts:</span><br><span class="line">        hello.rb</span><br><span class="line"></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..e1d0799</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line">  #! /usr/bin/env ruby</span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &apos;hola world&apos;</span><br><span class="line"> -  puts &apos;hello mundo&apos;</span><br><span class="line">++  puts &apos;hola mundo&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure><h4 id="撤消合并"><a href="#撤消合并" class="headerlink" title="撤消合并"></a>撤消合并</h4><p>虽然你已经知道如何创建一个合并提交，但有时出错是在所难免的。 使用 Git 最棒的一件事情是犯错是可以的，因为有可能（大多数情况下都很容易）修复它们。</p><p>合并提交并无不同。 假设现在在一个特性分支上工作，不小心将其合并到 <code>master</code> 中，现在提交历史看起来是这样：</p><p><img src="git-chapter-8/img1.png" alt></p><p>有两种方法来解决这个问题，这取决于你想要的结果是什么。</p><h5 id="修复引用"><a href="#修复引用" class="headerlink" title="修复引用"></a>修复引用</h5><p>如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 <code>git merge</code> 后运行 <code>git reset --hard HEAD~</code>，这会重置分支指向所以它们看起来像这样：</p><p><img src="git-chapter-8/img2.png" alt></p><p>我们之前在 重置揭密 已经介绍了 <code>reset</code>，所以现在指出这里发生了什么并不是很困难。 让我们快速复习下：<code>reset --hard</code> 通常会经历三步：</p><ol><li><p>移动 HEAD 指向的分支。 在本例中，我们想要移动 <code>master</code> 到合并提交（<code>C6</code>）之前所在的位置。</p></li><li><p>使索引看起来像 HEAD。</p></li><li><p>使工作目录看起来像索引。</p></li></ol><p>这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 查阅 变基的风险 来了解更多可能发生的事情；用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 <code>reset</code>。 如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。</p><h5 id="还原提交"><a href="#还原提交" class="headerlink" title="还原提交"></a>还原提交</h5><p>如果移动分支指针并不适合你，Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。 Git 称这个操作为“还原”，在这个特定的场景下，你可以像这样调用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git revert -m 1 HEAD</span><br><span class="line">[master b1d8379] Revert &quot;Merge branch &apos;topic&apos;&quot;</span><br></pre></td></tr></table></figure><p><code>-m 1</code> 标记指出 “mainline” 需要被保留下来的父结点。 当你引入一个合并到 <code>HEAD（git merge topic）</code>，新提交有两个父结点：第一个是 <code>HEAD</code>（<code>C6</code>），第二个是将要合并入分支的最新提交（<code>C4</code>）。 在本例中，我们想要撤消所有由父结点 #2（<code>C4</code>）合并引入的修改，同时保留从父结点 #1（<code>C4</code>）开始的所有内容。</p><p>有还原提交的历史看起来像这样：</p><p><img src="git-chapter-8/img3.png" alt></p><p>新的提交 <code>^M</code> 与 <code>C6</code> 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 <code>HEAD</code> 的历史中。 如果你尝试再次合并 <code>topic</code> 到 <code>master</code> Git 会感到困惑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge topic</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure><p><code>topic</code> 中并没有东西不能从 <code>master</code> 中追踪到达。 更糟的是，如果你在 <code>topic</code> 中增加工作然后再次合并，Git 只会引入被还原的合并 之后 的修改。</p><p><img src="git-chapter-8/img4.png" alt></p><p>解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，然后 创建一个新的合并提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git revert ^M</span><br><span class="line">[master 09f0126] Revert &quot;Revert &quot;Merge branch &apos;topic&apos;&quot;&quot;</span><br><span class="line">$ git merge topic</span><br></pre></td></tr></table></figure><p><img src="git-chapter-8/img5.png" alt></p><p>在本例中，<code>M</code> 与 <code>^M</code> 抵消了。 <code>^^M</code> 事实上合并入了 <code>C3</code> 与 <code>C4</code> 的修改，<code>C8</code> 合并了 <code>C7</code> 的修改，所以现在 <code>topic</code> 已经完全被合并了。</p><h4 id="其他类型的合并"><a href="#其他类型的合并" class="headerlink" title="其他类型的合并"></a>其他类型的合并</h4><p>到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。 然而还有其他方式来合并两个分支到一起。 让我们来快速介绍其中的几个。</p><h5 id="我们的或他们的偏好"><a href="#我们的或他们的偏好" class="headerlink" title="我们的或他们的偏好"></a>我们的或他们的偏好</h5><p>首先，有另一种我们可以通过 “recursive” 合并模式做的有用工作。 我们之前已经看到传递给 <code>-X</code> 的 <code>ignore-all-space</code> 与 <code>ignore-space-change</code> 选项，但是我们也可以告诉 Git 当它看见一个冲突时直接选择一边。</p><p>默认情况下，当 Git 看到两个分支合并中的冲突时，它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决。 如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动合并冲突，你可以传递给 <code>merge</code> 命令一个 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数。</p><p>如果 Git 看到这个，它并不会增加冲突标记。 任何可以合并的区别，它会直接合并。 任何有冲突的区别，它会简单地选择你全局指定的一边，包括二进制文件。</p><p>如果我们回到之前我们使用的 “hello world” 例子中，我们可以看到合并入我们的分支时引发了冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge mundo</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Resolved &apos;hello.rb&apos; using previous resolution.</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>然而如果我们运行时增加 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数就不会有冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -Xours mundo</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> hello.rb | 2 +-</span><br><span class="line"> test.sh  | 2 ++</span><br><span class="line"> 2 files changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 test.sh</span><br></pre></td></tr></table></figure><p>在上例中，它并不会为 “hello mundo” 与 “hola world” 标记合并冲突，它只会简单地选取 “hola world”。 然而，在那个分支上所有其他非冲突的改动都可以被成功地合并入。</p><p>这个选项也可以传递给我们之前看到的 <code>git merge-file</code> 命令，通过运行类似 <code>git merge-file --ours</code> 的命令来合并单个文件。</p><p>如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改，有一个更严格的选项，它是 “ours” 合并 策略。 这与 “ours” recursive 合并 选项 不同。</p><p>这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -s ours mundo</span><br><span class="line">Merge made by the &apos;ours&apos; strategy.</span><br><span class="line">$ git diff HEAD HEAD~</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>你可以看到合并后与合并前我们的分支并没有任何区别。</p><p>当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。 例如，假设你有一个分叉的 <code>release</code> 分支并且在上面做了一些你想要在未来某个时候合并回 <code>master</code> 的工作。 与此同时 <code>master</code> 分支上的某些 <code>bugfix</code> 需要向后移植回 <code>release</code> 分支。 你可以合并 <code>bugfix</code> 分支进入 <code>release</code> 分支同时也 <code>merge -s ours</code> 合并进入你的 <code>master</code> 分支（即使那个修复已经在那儿了）这样当你之后再次合并 <code>release</code> 分支时，就不会有来自 <code>bugfix</code> 的冲突。</p><h5 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h5><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。 当你执行一个子树合并时，Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。</p><p>我们来看一个例子如何将一个项目加入到一个已存在的项目中，然后将第二个项目的代码合并到第一个项目的子目录中。</p><p>首先，我们将 Rack 应用添加到你的项目里。 我们把 Rack 项目作为一个远程的引用添加到我们的项目里，然后检出到它自己的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add rack_remote https://github.com/rack/rack</span><br><span class="line">$ git fetch rack_remote</span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 3184, done.</span><br><span class="line">remote: Compressing objects: 100% (1465/1465), done.</span><br><span class="line">remote: Total 3184 (delta 1952), reused 2770 (delta 1675)</span><br><span class="line">Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1952/1952), done.</span><br><span class="line">From https://github.com/rack/rack</span><br><span class="line"> * [new branch]      build      -&gt; rack_remote/build</span><br><span class="line"> * [new branch]      master     -&gt; rack_remote/master</span><br><span class="line"> * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4</span><br><span class="line"> * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9</span><br><span class="line">$ git checkout -b rack_branch rack_remote/master</span><br><span class="line">Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.</span><br><span class="line">Switched to a new branch &quot;rack_branch&quot;</span><br></pre></td></tr></table></figure><p>现在在我们的 <code>rack_branch</code> 分支里就有 Rack 项目的根目录，而我们的项目则在 <code>master</code> 分支里。 如果你从一个分支切换到另一个分支，你可以看到它们的项目根目录是不同的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib</span><br><span class="line">COPYING         README         bin           example         test</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &quot;master&quot;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure><p>这个是一个比较奇怪的概念。 并不是仓库中的所有分支都是必须属于同一个项目的分支. 这并不常见，因为没啥用，但是却是在不同分支里包含两条完全不同提交历史的最简单的方法。</p><p>在这个例子中，我们希望将 Rack 项目拉到 <code>master</code> 项目中作为一个子目录。 我们可以在 Git 中执行 <code>git read-tree</code> 来实现。 你可以在 Git 内部原理 中查看更多 <code>read-tree</code> 的相关信息，现在你只需要知道它会读取一个分支的根目录树到当前的暂存区和工作目录里。 先切回你的 <code>master</code> 分支，将 <code>rack_back</code> 分支拉取到我们项目的 <code>master</code> 分支中的 <code>rack</code> 子目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=rack/ -u rack_branch</span><br></pre></td></tr></table></figure><p>当我们提交时，那个子目录中拥有所有 Rack 项目的文件 —— 就像我们直接从压缩包里复制出来的一样。 有趣的是你可以很容易地将一个分支的变更合并到另一个分支里。 所以，当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout rack_branch</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>接着，我们可以将这些变更合并回我们的 <code>master</code> 分支。 使用 <code>--squash</code> 选项和使用 <code>-Xsubtree</code> 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。 （递归策略在这里是默认的，提到它是为了让读者有个清晰的概念。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --squash -s recursive -Xsubtree=rack rack_branch</span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line">Automatic merge went well; stopped before committing as requested</span><br></pre></td></tr></table></figure><p>Rack 项目中所有的改动都被合并了，等待被提交到本地。 你也可以用相反的方法——在 <code>master</code> 分支上的 <code>rack</code> 子目录中做改动然后将它们合并入你的 <code>rack_branch</code> 分支中，之后你可能将其提交给项目维护着或者将它们推送到上游。</p><p>这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块（有关子模块的内容我们会在 子模块 中介绍）。 我们可以在自己的仓库中保持一些和其他项目相关的分支，偶尔使用子树合并将它们合并到我们的项目中。 某些时候这种方式很有用，例如当所有的代码都提交到一个地方的时候。 然而，它同时也有缺点，它更加复杂且更容易让人犯错，例如重复合并改动或者不小心将分支提交到一个无关的仓库上去。</p><p>另外一个有点奇怪的地方是，当你想查看 <code>rack</code> 子目录和 <code>rack_branch</code> 分支的差异——来确定你是否需要合并它们——你不能使用普通的 <code>diff</code> 命令。 取而代之的是，你必须使用 <code>git diff-tree</code> 来和你的目标分支做比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff-tree -p rack_branch</span><br></pre></td></tr></table></figure><p>或者，将你的 <code>rack</code> 子目和最近一次从服务器上抓取的 <code>master</code> 分支进行比较，你可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff-tree -p rack_remote/master</span><br></pre></td></tr></table></figure><h3 id="使用-Git-调试"><a href="#使用-Git-调试" class="headerlink" title="使用 Git 调试"></a>使用 Git 调试</h3><p>Git 也提供了两个工具来辅助你调试项目中的问题。 由于 Git 被设计成适用于几乎所有类型的项目，这些工具是比较通用的，但它们可以在出现问题的时候帮助你找到 bug 或者错误。</p><h4 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h4><p>如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。 它展示了文件中每一行最后一次修改的提交。 所以，如果你在代码中看到一个有问题的方法，你可以使用 <code>git blame</code> 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。 这个例子使用 <code>-L</code> 选项来限制输出范围在第12至22行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git blame -L 12,22 simplegit.rb</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &apos;master&apos;)</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #&#123;tree&#125;&quot;)</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end</span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &apos;master&apos;)</span><br><span class="line">79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #&#123;tree&#125;&quot;)</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end</span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #&#123;path&#125;&quot;)</span><br><span class="line">42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</span><br></pre></td></tr></table></figure><p>请注意，第一个字段是最后一次修改该行的提交的部分 SHA-1 值。 接下来两个字段的值是从提交中提取出来的——作者的名字以及提交的时间——所以你就可以很轻易地找到是谁在什么时候修改了那一行。 接下来就是行号和文件内容。 注意一下 <code>^4832fe2</code> 这个提交的那些行，这些指的是这个文件第一次提交的那些行。 这个提交是这个文件第一次加入到这个项目时的提交，并且这些行从未被修改过。 这会带来小小的困惑，因为你已经至少看到三种 Git 使用 <code>^</code> 来修饰一个提交的 SHA-1 值的不同含义，但这里确实就是这个意思。</p><p>另一件比较酷的事情是 Git 不会显式地记录文件的重命名。 它会记录快照，然后在事后尝试计算出重命名的动作。 这其中有一个很有意思的特性就是你可以让 Git 找出所有的代码移动。 如果你在 <code>git blame</code> 后面加上一个 <code>-C</code>，Git 会分析你正在标注的文件，并且尝试找出文件中从别的地方复制过来的代码片段的原始出处。 比如，你将 <code>GITServerHandler.m</code> 这个文件拆分为数个文件，其中一个文件是 <code>GITPackUpload.m</code>。 对 <code>GITPackUpload.m</code> 执行带 <code>-C</code> 参数的 <code>blame</code> 命令，你就可以看到代码块的原始出处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git blame -C -L 141,153 GITPackUpload.m</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 141)</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC</span><br><span class="line">f344f58d GITServerHandler.m (Scott 2009-01-04 143) &#123;</span><br><span class="line">70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI</span><br><span class="line">ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) &#123;</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb</span><br><span class="line">56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</span><br></pre></td></tr></table></figure><p>这个功能很有用。 通常来说，你会认为复制代码过来的那个提交是最原始的提交，因为那是你第一次在这个文件中修改了这几行。 但 Git 会告诉你，你第一次写这几行代码的那个提交才是原始提交，即使这是在另外一个文件里写的。</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。 如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 <code>git bisect</code> 来帮助查找。 <code>bisect</code> 命令会对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题。</p><p>假设你刚刚在线上环境部署了你的代码，接着收到一些 bug 反馈，但这些 bug 在你之前的开发环境里没有出现过，这让你百思不得其解。 你重新查看了你的代码，发现这个问题是可以被重现的，但是你不知道哪里出了问题。 你可以用二分法来找到这个问题。 首先执行 <code>git bisect start</code> 来启动，接着执行 <code>git bisect bad</code> 来告诉系统当前你所在的提交是有问题的。 然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用 <code>git bisect good [good_commit]</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect start</span><br><span class="line">$ git bisect bad</span><br><span class="line">$ git bisect good v1.0</span><br><span class="line">Bisecting: 6 revisions left to test after this</span><br><span class="line">[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</span><br></pre></td></tr></table></figure><p>Git 发现在你标记为正常的提交（v1.0）和当前的错误版本之间有大约12次提交，于是 Git 检出中间的那个提交。 现在你可以执行测试，看看在这个提交下问题是不是还是存在。 如果还存在，说明问题是在这个提交之前引入的；如果问题不存在，说明问题是在这个提交之后引入的。 假设测试结果是没有问题的，你可以通过 <code>git bisect good</code> 来告诉 Git，然后继续寻找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect good</span><br><span class="line">Bisecting: 3 revisions left to test after this</span><br><span class="line">[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</span><br></pre></td></tr></table></figure><p>现在你在另一个提交上了，这个提交是刚刚那个测试通过的提交和有问题的提交的中点。 你再一次执行测试，发现这个提交下是有问题的，因此你可以通过 <code>git bisect bad</code> 告诉 Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect bad</span><br><span class="line">Bisecting: 1 revisions left to test after this</span><br><span class="line">[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</span><br></pre></td></tr></table></figure><p>这个提交是正常的，现在 Git 拥有的信息已经可以确定引入问题的位置在哪里。 它会告诉你第一个错误提交的 SHA-1 值并显示一些提交说明，以及哪些文件在那次提交里修改过，这样你可以找出引入 bug 的根源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect good</span><br><span class="line">b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit</span><br><span class="line">commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04</span><br><span class="line">Author: PJ Hyett &lt;pjhyett@example.com&gt;</span><br><span class="line">Date:   Tue Jan 27 14:48:32 2009 -0800</span><br><span class="line"></span><br><span class="line">    secure this thing</span><br><span class="line"></span><br><span class="line">:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730</span><br><span class="line">f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</span><br></pre></td></tr></table></figure><p>当你完成这些操作之后，你应该执行 <code>git bisect reset</code> 重置你的 HEAD 指针到最开始的位置，否则你会停留在一个很奇怪的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect reset</span><br></pre></td></tr></table></figure><p>这是一个可以帮助你在几分钟内从数百个提交中找到 bug 的强大工具。 事实上，如果你有一个脚本在项目是正常的情况下返回 0，在不正常的情况下返回非 0，你可以使 <code>git bisect</code> 自动化这些操作。 首先，你设定好项目正常以及不正常所在提交的二分查找范围。 你可以通过 <code>bisect start</code> 命令的参数来设定这两个提交，第一个参数是项目不正常的提交，第二个参数是项目正常的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git bisect start HEAD v1.0</span><br><span class="line">$ git bisect run test-error.sh</span><br></pre></td></tr></table></figure><p>Git 会自动在每个被检出的提交里执行 <code>test-error.sh</code> 直到找到第一个项目不正常的提交。 你也可以执行 <code>make</code> 或者 <code>make tests</code> 或者其他东西来进行自动化测试。</p><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p><p>我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。 如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。</p><p>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p><h4 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h4><p>我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。</p><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 <code>git submodule add</code> 命令后面加上想要跟踪的项目 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">Cloning into &apos;DbConnector&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure><p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p><p>如果这时运行 <code>git status</code>，你会注意到几件事。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   .gitmodules</span><br><span class="line">new file:   DbConnector</span><br></pre></td></tr></table></figure><p>首先应当注意到新的 <code>.gitmodules</code> 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitmodules</span><br><span class="line">[submodule &quot;DbConnector&quot;]</span><br><span class="line">path = DbConnector</span><br><span class="line">url = https://github.com/chaconinc/DbConnector</span><br></pre></td></tr></table></figure><p>如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p><p>在 <code>git status</code> 输出中列出的另一个是项目文件夹记录。 如果你运行 <code>git diff</code>，会看到类似下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached DbConnector</span><br><span class="line">diff --git a/DbConnector b/DbConnector</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..c3f01dc</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</span><br></pre></td></tr></table></figure><p>虽然 <code>DbConnector</code> 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作该仓库中的一个特殊提交。</p><p>如果你想看到更漂亮的差异输出，可以给 <code>git diff</code> 传递 <code>--submodule</code> 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached --submodule</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..71fc376</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+[submodule &quot;DbConnector&quot;]</span><br><span class="line">+       path = DbConnector</span><br><span class="line">+       url = https://github.com/chaconinc/DbConnector</span><br><span class="line">Submodule DbConnector 0000000...c3f01dc (new submodule)</span><br></pre></td></tr></table></figure><p>当你提交时，会看到类似下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;added DbConnector module&apos;</span><br><span class="line">[master fb9093c] added DbConnector module</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 DbConnector</span><br></pre></td></tr></table></figure><p>注意 DbConnector 记录的 <code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p><h4 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h4><p>接下来我们将会克隆一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into &apos;MainProject&apos;...</span><br><span class="line">remote: Counting objects: 14, done.</span><br><span class="line">remote: Compressing objects: 100% (13/13), done.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">$ cd MainProject</span><br><span class="line">$ ls -la</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .</span><br><span class="line">drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..</span><br><span class="line">drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git</span><br><span class="line">-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules</span><br><span class="line">drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector</span><br><span class="line">-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile</span><br><span class="line">drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src</span><br><span class="line">$ cd DbConnector/</span><br><span class="line">$ ls</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>其中有 <code>DbConnector</code> 目录，不过是空的。 你必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule &apos;DbConnector&apos; (https://github.com/chaconinc/DbConnector) registered for path &apos;DbConnector&apos;</span><br><span class="line">$ git submodule update</span><br><span class="line">Cloning into &apos;DbConnector&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;c3f01dc8862123d317dd46284b05b6892c7b29bc&apos;</span><br></pre></td></tr></table></figure><p>现在 <code>DbConnector</code> 子目录是处在和之前提交时相同的状态了。</p><p>不过还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recursive</code> 选项，它就会自动初始化并更新仓库中的每一个子模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --recursive https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into &apos;MainProject&apos;...</span><br><span class="line">remote: Counting objects: 14, done.</span><br><span class="line">remote: Compressing objects: 100% (13/13), done.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule &apos;DbConnector&apos; (https://github.com/chaconinc/DbConnector) registered for path &apos;DbConnector&apos;</span><br><span class="line">Cloning into &apos;DbConnector&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;c3f01dc8862123d317dd46284b05b6892c7b29bc&apos;</span><br></pre></td></tr></table></figure><h4 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h4><p>现在我们有一份包含子模块的项目副本，我们将会同时在主项目和子模块项目上与队员协作。</p><h5 id="拉取上游修改"><a href="#拉取上游修改" class="headerlink" title="拉取上游修改"></a>拉取上游修改</h5><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。 我们来看一个简单的例子。</p><p>如果想要在子模块中查看新工作，可以进入到目录中运行 <code>git fetch</code> 与 <code>git merge</code>，合并上游分支来更新本地代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c3f01dc..d0354fc  master     -&gt; origin/master</span><br><span class="line">$ git merge origin/master</span><br><span class="line">Updating c3f01dc..d0354fc</span><br><span class="line">Fast-forward</span><br><span class="line"> scripts/connect.sh | 1 +</span><br><span class="line"> src/db.c           | 1 +</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>如果你现在返回到主项目并运行 <code>git diff --submodule</code>，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。 如果你不想每次运行 <code>git diff</code> 时都输入 <code>--submodle</code>，那么可以将 <code>diff.submodule</code> 设置为 “log” 来将其作为默认行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global diff.submodule log</span><br><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c3f01dc..d0354fc:</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure><p>如果在此时提交，那么你会将子模块锁定为其他人更新时的新代码。</p><p>如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 <code>git submodule update --remote</code>，Git 将会进入子模块然后抓取并更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote DbConnector</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   3f19983..d0354fc  master     -&gt; origin/master</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;d0354fc054692d3906c85c3af05ddce39a1c0644&apos;</span><br></pre></td></tr></table></figure><p>此命令默认会假定你想要更新并检出子模块仓库的 <code>master</code> 分支。 不过你也可以设置为想要的其他分支。 例如，你想要 DbConnector 子模块跟踪仓库的 “stable” 分支，那么既可以在 <code>.gitmodules</code> 文件中设置（这样其他人也可以跟踪它），也可以只在本地的 <code>.git/config</code> 文件中设置。 让我们在 <code>.gitmodules</code> 文件中设置它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git config -f .gitmodules submodule.DbConnector.branch stable</span><br><span class="line"></span><br><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   27cf5d3..c87d55d  stable -&gt; origin/stable</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687&apos;</span><br></pre></td></tr></table></figure><p>如果不用 <code>-f .gitmodules</code> 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。</p><p>这时我们运行 <code>git status</code>，Git 会显示子模块中有“新提交”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   .gitmodules</span><br><span class="line">  modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>如果你设置了配置选项 <code>status.submodulesummary</code>，Git 也会显示你的子模块的更改摘要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git config status.submodulesummary 1</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   .gitmodules</span><br><span class="line">modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">Submodules changed but not updated:</span><br><span class="line"></span><br><span class="line">* DbConnector c3f01dc...c87d55d (4):</span><br><span class="line">  &gt; catch non-null terminated lines</span><br></pre></td></tr></table></figure><p>这时如果运行 <code>git diff</code>，可以看到我们修改了 <code>.gitmodules</code> 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule &quot;DbConnector&quot;]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line"> Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure><p>这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 <code>git log -p</code> 查看这个信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p --submodule</span><br><span class="line">commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Sep 17 16:37:02 2014 +0200</span><br><span class="line"></span><br><span class="line">    updating DbConnector for bug fixes</span><br><span class="line"></span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule &quot;DbConnector&quot;]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line">Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure><p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新所有子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。</p><h5 id="在子模块上工作"><a href="#在子模块上工作" class="headerlink" title="在子模块上工作"></a>在子模块上工作</h5><p>你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。</p><p>现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。</p><p>到目前为止，当我们运行 <code>git submodule update</code> 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支（例如 “master” ）跟踪改动。 所以你做的任何改动都不会被跟踪。</p><p>为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 <code>git submodule update --remote</code> 来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。</p><p>首先，让我们进入子模块目录然后检出一个分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout stable</span><br><span class="line">Switched to branch &apos;stable&apos;</span><br></pre></td></tr></table></figure><p>然后尝试用 “merge” 选项。 为了手动指定它，我们只需给 <code>update</code> 添加 <code>--merge</code> 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --merge</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c87d55d..92c7337  stable     -&gt; origin/stable</span><br><span class="line">Updating c87d55d..92c7337</span><br><span class="line">Fast-forward</span><br><span class="line"> src/main.c | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">Submodule path &apos;DbConnector&apos;: merged in &apos;92c7337b30ef9e0893e758dac2459d07362ab5ea&apos;</span><br></pre></td></tr></table></figure><p>如果我们进入 DbConnector 目录，可以发现新的改动已经合并入本地 <code>stable</code> 分支。 现在让我们看看当我们对库做一些本地的改动而同时其他人推送另外一个修改到上游时会发生什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd DbConnector/</span><br><span class="line">$ vim src/db.c</span><br><span class="line">$ git commit -am &apos;unicode support&apos;</span><br><span class="line">[stable f906e16] unicode support</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: unicode support</span><br><span class="line">Submodule path &apos;DbConnector&apos;: rebased into &apos;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&apos;</span><br></pre></td></tr></table></figure><p>如果你忘记 <code>--rebase</code> 或 <code>--merge</code>，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">Submodule path &apos;DbConnector&apos;: checked out &apos;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&apos;</span><br></pre></td></tr></table></figure><p>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 <code>origin/stable</code>（或任何一个你想要的远程分支）就行了。</p><p>如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 4 (delta 0), reused 4 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   5d60ef9..c75e92a  stable     -&gt; origin/stable</span><br><span class="line">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class="line">scripts/setup.sh</span><br><span class="line">Please, commit your changes or stash them before you can switch branches.</span><br><span class="line">Aborting</span><br><span class="line">Unable to checkout &apos;c75e92a2b3855c9e5b66f915308390d9db204aca&apos; in submodule path &apos;DbConnector&apos;</span><br></pre></td></tr></table></figure><p>如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --merge</span><br><span class="line">Auto-merging scripts/setup.sh</span><br><span class="line">CONFLICT (content): Merge conflict in scripts/setup.sh</span><br><span class="line">Recorded preimage for &apos;scripts/setup.sh&apos;</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line">Unable to merge &apos;c75e92a2b3855c9e5b66f915308390d9db204aca&apos; in submodule path &apos;DbConnector&apos;</span><br></pre></td></tr></table></figure><p>你可以进入子模块目录中然后就像平时那样修复冲突。</p><h5 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h5><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c87d55d..82d2ad3:</span><br><span class="line">  &gt; Merge from origin/stable</span><br><span class="line">  &gt; updated setup script</span><br><span class="line">  &gt; unicode support</span><br><span class="line">  &gt; remove unnecessary method</span><br><span class="line">  &gt; add new option for conn pooling</span><br></pre></td></tr></table></figure><p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。</p><p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 <code>git push</code> 命令接受可以设置为 “check” 或 “on-demand” 的 <code>--recurse-submodules</code> 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 <code>push</code> 操作失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=check</span><br><span class="line">The following submodule paths contain changes that can</span><br><span class="line">not be found on any remote:</span><br><span class="line">  DbConnector</span><br><span class="line"></span><br><span class="line">Please try</span><br><span class="line"></span><br><span class="line">git push --recurse-submodules=on-demand</span><br><span class="line"></span><br><span class="line">or cd to the path and use</span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">to push them to a remote.</span><br></pre></td></tr></table></figure><p>如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。</p><p>另一个选项是使用 “on-demand” 值，它会尝试为你这样做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=on-demand</span><br><span class="line">Pushing submodule &apos;DbConnector&apos;</span><br><span class="line">Counting objects: 9, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (8/8), done.</span><br><span class="line">Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.</span><br><span class="line">Total 9 (delta 3), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/DbConnector</span><br><span class="line">   c75e92a..82d2ad3  stable -&gt; stable</span><br><span class="line">Counting objects: 2, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/MainProject</span><br><span class="line">   3d6d338..9a377d1  master -&gt; master</span><br></pre></td></tr></table></figure><p>如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。 如果那个子模块因为某些原因推送失败，主项目也会推送失败。</p><h5 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h5><p>如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。</p><p>如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。</p><p>不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 2, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1)</span><br><span class="line">Unpacking objects: 100% (2/2), done.</span><br><span class="line">From https://github.com/chaconinc/MainProject</span><br><span class="line">   9a377d1..eb974f8  master     -&gt; origin/master</span><br><span class="line">Fetching submodule DbConnector</span><br><span class="line">warning: Failed to merge submodule DbConnector (merge following commits not found)</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict in DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found” （未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。</p><p>为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 <code>git diff</code>，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br></pre></td></tr></table></figure><p>所以，在本例中，<code>eb41d76</code> 是我们的子模块中大家共有的提交，而 <code>c771610</code> 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 <code>eb41d76</code> 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。</p><p>来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。</p><p>所以，我们将会进入子模块目录，基于 <code>git diff</code> 的第二个 SHA 创建一个分支然后手动合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd DbConnector</span><br><span class="line"></span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"></span><br><span class="line">$ git branch try-merge c771610</span><br><span class="line">(DbConnector) $ git merge try-merge</span><br><span class="line">Auto-merging src/main.c</span><br><span class="line">CONFLICT (content): Merge conflict in src/main.c</span><br><span class="line">Recorded preimage for &apos;src/main.c&apos;</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>我们在这儿得到了一个真正的合并冲突，所以如果想要解决并提交它，那么只需简单地通过结果来更新主项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ vim src/main.c (1)</span><br><span class="line">$ git add src/main.c</span><br><span class="line">$ git commit -am &apos;merged our changes&apos;</span><br><span class="line">Recorded resolution for &apos;src/main.c&apos;.</span><br><span class="line">[master 9fd905e] merged our changes</span><br><span class="line"></span><br><span class="line">$ cd .. (2)</span><br><span class="line">$ git diff (3)</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@@ -1,1 -1,1 +1,1 @@@</span><br><span class="line">- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"> -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d</span><br><span class="line">++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a</span><br><span class="line">$ git add DbConnector (4)</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;Merge Tom&apos;s Changes&quot; (5)</span><br><span class="line">[master 10d2c60] Merge Tom&apos;s Changes</span><br></pre></td></tr></table></figure><ol><li><p>首先解决冲突</p></li><li><p>然后返回到主项目目录中</p></li><li><p>再次检查 SHA-1 值</p></li><li><p>解决冲突的子模块记录</p></li><li><p>提交我们的合并</p></li></ol><p>这可能会让你有点儿困惑，但它确实不难。</p><p>有趣的是，Git 还能处理另一种情况。 如果子模块目录中存在着这样一个合并提交，它的历史中包含了的两边的提交，那么 Git 会建议你将它作为一个可行的解决方案。 它看到有人在子模块项目的某一点上合并了包含这两次提交的分支，所以你可能想要那个。</p><p>这就是为什么前面的错误信息是 “merge following commits not found”，因为它不能 这样 做。 它让人困惑是因为谁能想到它会尝试这样做？</p><p>如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">warning: Failed to merge submodule DbConnector (not fast-forward)</span><br><span class="line">Found a possible merge resolution for the submodule:</span><br><span class="line"> 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes</span><br><span class="line">If this is correct simply add it to the index for example</span><br><span class="line">by using:</span><br><span class="line"></span><br><span class="line">  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a &quot;DbConnector&quot;</span><br><span class="line"></span><br><span class="line">which will accept this suggestion.</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict in DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>它会建议你更新索引，就像你运行了 <code>git add</code> 那样，这样会清除冲突然后提交。不过你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd DbConnector/</span><br><span class="line">$ git merge 9fd905e</span><br><span class="line">Updating eb41d76..9fd905e</span><br><span class="line">Fast-forward</span><br><span class="line"></span><br><span class="line">$ cd ..</span><br><span class="line">$ git add DbConnector</span><br><span class="line">$ git commit -am &apos;Fast forwarded to a common submodule child&apos;</span><br></pre></td></tr></table></figure><p>这些命令完成了同一件事，但是通过这种方式你至少可以验证工作是否有效，以及当你在完成时可以确保子模块目录中有你的代码。</p><h4 id="子模块技巧"><a href="#子模块技巧" class="headerlink" title="子模块技巧"></a>子模块技巧</h4><p>你可以做几件事情来让用子模块工作轻松一点儿。</p><h5 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h5><p>有一个 <code>foreach</code> 子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p><p>例如，假设我们想要开始开发一项新功能或者修复一些错误，并且需要在几个子模块内工作。 我们可以轻松地保存所有子模块的工作进度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach &apos;git stash&apos;</span><br><span class="line">Entering &apos;CryptoLibrary&apos;</span><br><span class="line">No local changes to save</span><br><span class="line">Entering &apos;DbConnector&apos;</span><br><span class="line">Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable</span><br><span class="line">HEAD is now at 82d2ad3 Merge from origin/stable</span><br></pre></td></tr></table></figure><p>然后我们可以创建一个新分支，并将所有子模块都切换过去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach &apos;git checkout -b featureA&apos;</span><br><span class="line">Entering &apos;CryptoLibrary&apos;</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br><span class="line">Entering &apos;DbConnector&apos;</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br></pre></td></tr></table></figure><p>你应该明白。 能够生成一个主项目与所有子项目的改动的统一差异是非常有用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git diff; git submodule foreach &apos;git diff&apos;</span><br><span class="line">Submodule DbConnector contains modified content</span><br><span class="line">diff --git a/src/main.c b/src/main.c</span><br><span class="line">index 210f1ae..1f0acdc 100644</span><br><span class="line">--- a/src/main.c</span><br><span class="line">+++ b/src/main.c</span><br><span class="line">@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)</span><br><span class="line"></span><br><span class="line">      commit_pager_choice();</span><br><span class="line"></span><br><span class="line">+     url = url_decode(url_orig);</span><br><span class="line">+</span><br><span class="line">      /* build alias_argv */</span><br><span class="line">      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));</span><br><span class="line">      alias_argv[0] = alias_string + 1;</span><br><span class="line">Entering &apos;DbConnector&apos;</span><br><span class="line">diff --git a/src/db.c b/src/db.c</span><br><span class="line">index 1aaefb6..5297645 100644</span><br><span class="line">--- a/src/db.c</span><br><span class="line">+++ b/src/db.c</span><br><span class="line">@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)</span><br><span class="line">        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+char *url_decode(const char *url)</span><br><span class="line">+&#123;</span><br><span class="line">+       return url_decode_mem(url, strlen(url));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> char *url_decode_parameter_name(const char **query)</span><br><span class="line"> &#123;</span><br><span class="line">        struct strbuf out = STRBUF_INIT;</span><br></pre></td></tr></table></figure><p>在这里，我们看到子模块中定义了一个函数并在主项目中调用了它。 这明显是个简化了的例子，但是希望它能让你明白这种方法的用处。</p><h5 id="有用的别名"><a href="#有用的别名" class="headerlink" title="有用的别名"></a>有用的别名</h5><p>你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 Git 别名 介绍了设置 Git 别名，但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config alias.sdiff &apos;!&apos;&quot;git diff &amp;&amp; git submodule foreach &apos;git diff&apos;&quot;</span><br><span class="line">$ git config alias.spush &apos;push --recurse-submodules=on-demand&apos;</span><br><span class="line">$ git config alias.supdate &apos;submodule update --remote --merge&apos;</span><br></pre></td></tr></table></figure><p>这样当你想要更新子模块时可以简单地运行 <code>git supdate</code>，或 <code>git spush</code> 检查子模块依赖后推送。</p><h4 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h4><p>然而使用子模块还是有一些小问题。</p><p>例如在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b add-crypto</span><br><span class="line">Switched to a new branch &apos;add-crypto&apos;</span><br><span class="line"></span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into &apos;CryptoLibrary&apos;...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git commit -am &apos;adding crypto library&apos;</span><br><span class="line">[add-crypto 4445836] adding crypto library</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 160000 CryptoLibrary</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">CryptoLibrary/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。 如果你移除它然后切换回有那个子模块的分支，需要运行 <code>submodule update --init</code> 来重新建立和填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -fdx</span><br><span class="line">Removing CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git checkout add-crypto</span><br><span class="line">Switched to branch &apos;add-crypto&apos;</span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git submodule update --init</span><br><span class="line">Submodule path &apos;CryptoLibrary&apos;: checked out &apos;b8dda6aa182ea4464f3f3264b11e0268545172af&apos;</span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line">Makefileincludesscriptssrc</span><br></pre></td></tr></table></figure><p>再说一遍，这真的不难，只是会让人有点儿困惑。</p><p>另一个主要的告诫是许多人遇到了将子目录转换为子模块的问题。 如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行 <code>submodule add</code>，Git 会朝你大喊：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf CryptoLibrary/</span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">&apos;CryptoLibrary&apos; already exists in the index</span><br></pre></td></tr></table></figure><p>你必须要先取消暂存 <code>CryptoLibrary</code> 目录。 然后才可以添加子模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r CryptoLibrary</span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into &apos;CryptoLibrary&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure><p>现在假设你在一个分支下做了这样的工作。 如果尝试切换回的分支中那些文件还在子目录而非子模块中时——你会得到这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">  CryptoLibrary/Makefile</span><br><span class="line">  CryptoLibrary/includes/crypto.h</span><br><span class="line">  ...</span><br><span class="line">Please move or remove them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>你可以通过 <code>checkout -f</code> 来强制切换，但是要小心，如果其中还有未保存的修改，这个命令会把它们覆盖掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -f master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>当你切换回来之后，因为某些原因你得到了一个空的 <code>CryptoLibrary</code> 目录，并且 <code>git submodule update</code> 也无法修复它。 你需要进入到子模块目录中运行 <code>git checkout .</code> 来找回所有的文件。 你也可以通过 <code>submodule foreach</code> 脚本来为多个子模块运行它。</p><p>要特别注意的是，近来子模块会将它们的所有 Git 数据保存在顶级项目的 <code>.git</code> 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失任何提交或分支。</p><p>拥有了这些工具，使用子模块会成为可以在几个相关但却分离的项目上同时开发的相当简单有效的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：分布式</title>
      <link href="/2018/06/09/Git%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2018/06/09/Git%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>你现在拥有了一个远程 Git 版本库，能为所有开发者共享代码提供服务，在一个本地工作流程下，你也已经熟悉了基本 Git 命令。你现在可以学习如何利用 Git 提供的一些分布式工作流程了。</p><p>这一章中，你将会学习如何作为贡献者或整合者，在一个分布式协作的环境中使用 Git。 你会学习为一个项目成功地贡献代码，并接触一些最佳实践方式，让你和项目的维护者能轻松地完成这个过程。另外，你也会学到如何管理有很多开发者提交贡献的项目。</p><a id="more"></a><h3 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h3><p>同传统的集中式版本控制系统（CVCS）不同，Git 的分布式特性使得开发者间的协作变得更加灵活多样。 在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。 而在 Git 中，每个开发者同时扮演着节点和集线器的角色——也就是说，每个开发者既可以将自己的代码贡献到其他的仓库中，同时也能维护自己的公开仓库，让其他人可以在其基础上工作并贡献代码。 由此，Git 的分布式协作可以为你的项目和团队衍生出种种不同的工作流程，接下来的章节会介绍几种利用了 Git 的这种灵活性的常见应用方式。 我们将讨论每种方式的优点以及可能的缺点；你可以选择使用其中的某一种，或者将它们的特性混合搭配使用。</p><h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p>集中式系统中通常使用的是单点协作模型——集中式工作流。 一个中心集线器，或者说仓库，可以接受代码，所有人将自己的工作与之同步。 若干个开发者则作为节点——也就是中心仓库的消费者——并且与其进行同步。</p><p><img src="git-chapter-1/img1.png" alt></p><p>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。 第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。 这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。</p><p>如果在公司或者团队中，你已经习惯了使用这种集中式工作流程，完全可以继续采用这种简单的模式。 只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。Git 不会让用户覆盖彼此的修改。 例如 John 和 Jessica 同时开始工作。 John 完成了他的修改并推送到服务器。 接着 Jessica 尝试提交她自己的修改，却遭到服务器拒绝。 她被告知她的修改正通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。 这种模式的工作流程的使用非常广泛，因为大多数人对其很熟悉也很习惯。</p><p>当然这并不局限于小团队。 利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好地在单个项目上协作。</p><h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h4><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表“官方”项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示：</p><ol><li><p>项目维护者推送到主仓库。</p></li><li><p>贡献者克隆此仓库，做出修改。</p></li><li><p>贡献者将数据推送到自己的公开仓库。</p></li><li><p>贡献者给维护者发送邮件，请求拉取自己的更新。</p></li><li><p>维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。</p></li><li><p>维护者将合并后的修改推送到主仓库。</p></li></ol><p><img src="git-chapter-1/img2.png" alt></p><p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目派生成为自己的公开仓库，向这个仓库推送自己的修改，并为每个人所见。 这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。 贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己的节奏工作。</p><h4 id="司令官与副官工作流"><a href="#司令官与副官工作流" class="headerlink" title="司令官与副官工作流"></a>司令官与副官工作流</h4><p>这其实是多仓库工作流程的变种。 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。 被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。 所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。 司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。 整个流程看起来是这样的：</p><ol><li><p>普通开发者在自己的特性分支上工作，并根据 <code>master</code> 分支进行变基。 这里是司令官的 <code>master</code> 分支。</p></li><li><p>副官将普通开发者的特性分支合并到自己的 <code>master</code> 分支中。</p></li><li><p>司令官将所有副官的 <code>master</code> 分支并入自己的 <code>master</code> 分支中。</p></li><li><p>司令官将集成后的 <code>master</code> 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。</p></li></ol><p><img src="git-chapter-1/img3.png" alt></p><p>这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。 利用这种方式，项目总负责人（即司令官）可以把大量分散的集成工作委托给不同的小组负责人分别处理，然后在不同时刻将大块的代码子集统筹起来，用于之后的整合。</p><h4 id="工作流程总结"><a href="#工作流程总结" class="headerlink" title="工作流程总结"></a>工作流程总结</h4><p>上面介绍了在 Git 等分布式系统中经常使用的工作流程，但是在实际的开发中，你会遇到许多可能适合你的特定工作流程的变种。 现在你应该已经清楚哪种工作流程组合可能比较适合你了，我们会给出一些如何扮演不同工作流程中主要角色的更具体的例子。 下一节我们将会学习为项目做贡献的一些常用模式。</p><h3 id="向一个项目贡献"><a href="#向一个项目贡献" class="headerlink" title="向一个项目贡献"></a>向一个项目贡献</h3><p>描述如何向一个项目贡献的主要困难在于完成贡献有很多不同的方式。 因为 Git 非常灵活，人们可以通过不同的方式来一起工作，所以描述应该如何贡献并不是非常准确——每一个项目都有一点儿不同。 影响因素包括活跃贡献者的数量、选择的工作流程、提交权限与可能包含的外部贡献方法。</p><p>第一个影响因素是活跃贡献者的数量——积极地向这个项目贡献代码的用户数量以及他们的贡献频率。 在许多情况下，你可能会有两三个开发者一天提交几次，对于不活跃的项目可能更少。 对于大一些的公司或项目，开发者的数量可能会是上千，每天都有成百上千次提交。 这很重要，因为随着开发者越来越多，在确保你的代码能干净地应用或轻松地合并时会遇到更多问题。 提交的改动可能表现为过时的，也可能在你正在做改动或者等待改动被批准应用时被合并入的工作严重损坏。 如何保证代码始终是最新的，并且提交始终是有效的？</p><p>下一个影响因素是项目使用的工作流程。 它是中心化的吗，即每一个开发者都对主线代码有相同的写入权限？ 项目是否有一个检查所有补丁的维护者或整合者？ 是否所有的补丁是同行评审后批准的？ 你是否参与了那个过程？ 是否存在副官系统，你必须先将你的工作提交到上面？</p><p>下一个问题是提交权限。 是否有项目的写权限会使向项目贡献所需的流程有极大的不同。 如果没有写权限，项目会选择何种方式接受贡献的工作？ 是否甚至有一个如何贡献的规范？ 你一次贡献多少工作？ 你多久贡献一次？</p><p>所有这些问题都会影响实际如何向一个项目贡献，以及对你来说哪些工作流程更适合或者可用。 我们将会由浅入深，通过一系列用例来讲述其中的每一个方面；从这些例子应该能够建立实际中你需要的特定工作流程。</p><h4 id="提交准则"><a href="#提交准则" class="headerlink" title="提交准则"></a>提交准则</h4><p>在我们开始查看特定的用例前，这里有一个关于提交信息的快速说明。 有一个好的创建提交的准则并且坚持使用会让与 Git 工作和与其他人协作更容易。 Git 项目提供了一个文档，其中列举了关于创建提交到提交补丁的若干好的提示——可以在 Git 源代码中的 <code>Documentation/SubmittingPatches</code> 文件中阅读它。</p><p>首先，你不会想要把空白错误（根据 git help diff 的描述，结合下面给出的图片，空白错误是指行尾的空格、Tab 制表符，和行首空格后跟 Tab 制表符的行为）提交上去。 Git 提供了一个简单的方式来检查这点——在提交前，运行 <code>git diff --check</code>，它将会找到可能的空白错误并将它们为你列出来。</p><p><img src="git-chapter-2/img1.png" alt></p><p>如果在提交前运行那个命令，可以知道提交中是否包含可能会使其他开发者恼怒的空白问题。</p><p>接下来，尝试让每一个提交成为一个逻辑上的独立变更集。 如果可以，尝试让改动可以理解——不要在整个周末编码解决五个问题，然后在周一时将它们提交为一个巨大的提交。 即使在周末期间你无法提交，在周一时使用暂存区域将你的工作最少拆分为每个问题一个提交，并且为每一个提交附带一个有用的信息。 如果其中一些改动修改了同一个文件，尝试使用 <code>git add --patch</code> 来部分暂存文件（在 交互式暂存 中有详细介绍）。 不管你做一个或五个提交，只要所有的改动是在同一时刻添加的，项目分支末端的快照就是独立的，使同事开发者必须审查你的改动时尽量让事情容易些。 当你之后需要时这个方法也会使拉出或还原一个变更集更容易些。 重写历史 描述了重写历史与交互式暂存文件的若干有用的 Git 技巧——在将工作发送给其他人前使用这些工具来帮助生成一个干净又易懂的历史。</p><p>最后一件要牢记的事是提交信息。 有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。 一般情况下，信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。 Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比——这是一个值得遵循的好规则。 在这些信息中使用现在时态祈使语气也是一个好想法。 换句话说，使用命令。 使用 “Add tests for” 而不是 “I added tests for” 或 “Adding tests for”。 这里是一份最初由 Tim Pope 写的模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修改的摘要（50 个字符或更少）</span><br><span class="line"></span><br><span class="line">如果必要的话，加入更详细的解释文字。在</span><br><span class="line">大概 72 个字符的时候换行。在某些情形下，</span><br><span class="line">第一行被当作一封电子邮件的标题，剩下的</span><br><span class="line">文本作为正文。分隔摘要与正文的空行是</span><br><span class="line">必须的（除非你完全省略正文）；如果你将</span><br><span class="line">两者混在一起，那么类似变基等工具无法</span><br><span class="line">正常工作。</span><br><span class="line"></span><br><span class="line">空行接着更进一步的段落。</span><br><span class="line"></span><br><span class="line">  - 句号也是可以的。</span><br><span class="line"></span><br><span class="line">  - 项目符号可以使用典型的连字符或星号</span><br><span class="line">    前面一个空格，之间用空行隔开，</span><br><span class="line">    但是可以依据不同的惯例有所不同。</span><br></pre></td></tr></table></figure><p>如果你所有的提交信息看起来都像这样，对你与跟你工作在一起的其他开发者来说事情会变得非常容易。 Git 项目有一个良好格式化的提交信息——尝试在那儿运行 <code>git log --no-merges</code> 来看看漂亮的格式化的项目提交历史像什么样。</p><p>在接下来的例子中，以及贯穿本书大部分，出于简洁性的原因本书不会有像这样漂亮格式的信息；相反，我们使用 <code>-m</code> 选项的 <code>git commit</code>。 照我们说的做，而不是照我们做的做。</p><h4 id="私有小型团队"><a href="#私有小型团队" class="headerlink" title="私有小型团队"></a>私有小型团队</h4><p>你可能会遇到的最简单的配置是有一两个其他开发者的私有项目。 “私有” 在这个上下文中，意味着闭源——不可以从外面的世界中访问到。 你和其他的开发者都有仓库的推送权限。</p><p>在这个环境下，可以采用一个类似使用 Subversion 或其他集中式的系统时会使用的工作流程。 依然可以得到像离线提交、非常容易地新建分支与合并分支等高级功能，但是工作流程可以是很简单的；主要的区别是合并发生在客户端这边而不是在提交时发生在服务器那边。 让我们看看当两个开发者在一个共享仓库中一起工作时会是什么样子。 第一个开发者，John，克隆了仓库，做了改动，然后本地提交。 （为了缩短这些例子长度，协议信息已被替换为 <code>...</code>。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># John&apos;s Machine</span><br><span class="line">$ git clone john@githost:simplegit.git</span><br><span class="line">Initialized empty Git repository in /home/john/simplegit/.git/</span><br><span class="line">...</span><br><span class="line">$ cd simplegit/</span><br><span class="line">$ vim lib/simplegit.rb</span><br><span class="line">$ git commit -am &apos;removed invalid default value&apos;</span><br><span class="line">[master 738ee87] removed invalid default value</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>第二个开发者，Jessica，做了同样的事情——克隆仓库并提交了一个改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Jessica&apos;s Machine</span><br><span class="line">$ git clone jessica@githost:simplegit.git</span><br><span class="line">Initialized empty Git repository in /home/jessica/simplegit/.git/</span><br><span class="line">...</span><br><span class="line">$ cd simplegit/</span><br><span class="line">$ vim TODO</span><br><span class="line">$ git commit -am &apos;add reset task&apos;</span><br><span class="line">[master fbff5bc] add reset task</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>现在，Jessica 把她的工作推送到服务器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Jessica&apos;s Machine</span><br><span class="line">$ git push origin master</span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   1edee6b..fbff5bc  master -&gt; master</span><br></pre></td></tr></table></figure><p>John 也尝试推送他的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># John&apos;s Machine</span><br><span class="line">$ git push origin master</span><br><span class="line">To john@githost:simplegit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast forward)</span><br><span class="line">error: failed to push some refs to &apos;john@githost:simplegit.git&apos;</span><br></pre></td></tr></table></figure><p>不允许 John 推送是因为在同一时间 Jessica 已经推送了。 如果之前习惯于用 Subversion 那么理解这点特别重要，因为你会注意到两个开发者并没有编辑同一个文件。 尽管 Subversion 会对编辑的不同文件在服务器上自动进行一次合并，但 Git 要求你在本地合并提交。 John 必须抓取 Jessica 的改动并合并它们，才能被允许推送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">...</span><br><span class="line">From john@githost:simplegit</span><br><span class="line"> + 049d078...fbff5bc master     -&gt; origin/master</span><br></pre></td></tr></table></figure><p>在这个时候，John 的本地仓库看起来像这样：</p><p><img src="git-chapter-2/img2.png" alt></p><p>John 有一个引用指向 Jessica 推送上去的改动，但是他必须将它们合并入自己的工作中之后才能被允许推送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">Merge made by recursive.</span><br><span class="line"> TODO |    1 +</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>合并进行地很顺利—— John 的提交历史现在看起来像这样：</p><p><img src="git-chapter-2/img3.png" alt></p><p>现在，John 可以测试代码，确保它依然正常工作，然后他可以把合并的新工作推送到服务器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">...</span><br><span class="line">To john@githost:simplegit.git</span><br><span class="line">   fbff5bc..72bbc59  master -&gt; master</span><br></pre></td></tr></table></figure><p>最终，John 的提交历史看起来像这样：</p><p><img src="git-chapter-2/img4.png" alt></p><p>在此期间，Jessica 在一个特性分支上工作。 她创建了一个称作 issue54 的特性分支并且在那个分支上做了三次提交。 她还没有抓取 John 的改动，所以她的提交历史看起来像这样：</p><p><img src="git-chapter-2/img5.png" alt></p><p>Jessica 想要与 John 同步，所以她进行了抓取操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Jessica&apos;s Machine</span><br><span class="line">$ git fetch origin</span><br><span class="line">...</span><br><span class="line">From jessica@githost:simplegit</span><br><span class="line">   fbff5bc..72bbc59  master     -&gt; origin/master</span><br></pre></td></tr></table></figure><p>那会同时拉取 John 推送的工作。 Jessica 的历史现在看起来像这样：</p><p><img src="git-chapter-2/img6.png" alt></p><p>Jessica 认为她的特性分支已经准备好了，但是她想要知道必须合并什么进入她的工作才能推送。 她运行 <code>git log</code> 来找出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --no-merges issue54..origin/master</span><br><span class="line">commit 738ee872852dfaa9d6634e0dea7a324040193016</span><br><span class="line">Author: John Smith &lt;jsmith@example.com&gt;</span><br><span class="line">Date:   Fri May 29 16:01:27 2009 -0700</span><br><span class="line"></span><br><span class="line">   removed invalid default value</span><br></pre></td></tr></table></figure><p><code>issue54..origin/master</code> 语法是一个日志过滤器，要求 Git 只显示所有在后面分支（在本例中是 <code>origin/master</code>）但不在前面分支（在本例中是 <code>issue54</code>）的提交的列表。 我们将会在 提交区间 中详细介绍这个语法。</p><p>目前，我们可以从输出中看到有一个 John 生成的但是 Jessica 还没有合并入的提交。 如果她合并 <code>origin/master</code>，也就是说将会修改她的本地工作的那个单个提交。</p><p>现在，Jessica 可以合并她的特性工作到她的 <code>master</code> 分支，合并 John 的工作（<code>origin/master</code>）进入她的 <code>master</code> 分支，然后再次推送回服务器。 首先，为了整合所有这些工作她切换回她的 <code>master</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is behind &apos;origin/master&apos; by 2 commits, and can be fast-forwarded.</span><br></pre></td></tr></table></figure><p>她既可以先合并 <code>origin/master</code> 也可以先合并 <code>issue54</code> ——它们都是上游，所以顺序并没有关系。 不论她选择的顺序是什么最终的结果快照是完全一样的；只是历史会有一点轻微的区别。 她选择先合并入 <code>issue54</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge issue54</span><br><span class="line">Updating fbff5bc..4af4298</span><br><span class="line">Fast forward</span><br><span class="line"> README           |    1 +</span><br><span class="line"> lib/simplegit.rb |    6 +++++-</span><br><span class="line"> 2 files changed, 6 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>没有发生问题；如你所见它是一次简单的快进。 现在 Jessica 合并入 John 的工作（<code>origin/master</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">Auto-merging lib/simplegit.rb</span><br><span class="line">Merge made by recursive.</span><br><span class="line"> lib/simplegit.rb |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>每一个文件都干净地合并了，Jessica 的历史看起来像这样：</p><p><img src="git-chapter-2/img7.png" alt></p><p>现在 <code>origin/master</code> 是可以从 Jessica 的 <code>master</code> 分支到达的，所以她应该可以成功地推送（假设同一时间 John 并没有再次推送）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   72bbc59..8059c15  master -&gt; master</span><br></pre></td></tr></table></figure><p>每一个开发者都提交了几次并成功地合并了其他人的工作。</p><p><img src="git-chapter-2/img8.png" alt></p><p>这是一个最简单的工作流程。 你通常在一个特性分支工作一会儿，当它准备好整合时合并回你的 <code>master</code> 分支。 当想要共享工作时，将其合并回你自己的 <code>master</code> 分支，如果有改动的话然后抓取并合并 <code>origin/master</code>，最终推送到服务器上的 <code>master</code> 分支。 通常顺序像这样：</p><p><img src="git-chapter-2/img9.png" alt></p><h4 id="私有管理团队"><a href="#私有管理团队" class="headerlink" title="私有管理团队"></a>私有管理团队</h4><p>在接下来的情形中，你会看到大型私有团队中贡献者的角色。 在你将学习到的这种工作环境中，小组基于特性进行协作，这些团队的贡献将会由其他人整合。</p><p>让我们假设 John 与 Jessica 在一个特性上工作，同时 Jessica 与 Josie 在第二个特性上工作。 在本例中，公司使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合，主仓库的 <code>master</code> 分支只能被那些工程师更新。 在这种情况下，所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起。</p><p>因为 Jessica 在两个特性上工作，并且平行地与两个不同的开发者协作，让我们跟随她的工作流程。 假设她已经克隆了仓库，首先决定在 <code>featureA</code> 上工作。 她为那个特性创建了一个新分支然后在那做了一些工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Jessica&apos;s Machine</span><br><span class="line">$ git checkout -b featureA</span><br><span class="line">Switched to a new branch &apos;featureA&apos;</span><br><span class="line">$ vim lib/simplegit.rb</span><br><span class="line">$ git commit -am &apos;add limit to log function&apos;</span><br><span class="line">[featureA 3300904] add limit to log function</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>在这个时候，她需要将工作共享给 John，所以她推送了 <code>featureA</code> 分支的提交到服务器上。 Jessica 没有 <code>master</code> 分支的推送权限——只有整合者有——所以为了与 John 协作必须推送另一个分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin featureA</span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line"> * [new branch]      featureA -&gt; featureA</span><br></pre></td></tr></table></figure><p>Jessica 向 John 发邮件告诉他已经推送了一些工作到 <code>featureA</code> 分支现在可以看一看。 当她等待 John 的反馈时，Jessica 决定与 Josie 开始在 <code>featureB</code> 上工作。 为了开始工作，她基于服务器的 <code>master</code> 分支开始了一个新分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Jessica&apos;s Machine</span><br><span class="line">$ git fetch origin</span><br><span class="line">$ git checkout -b featureB origin/master</span><br><span class="line">Switched to a new branch &apos;featureB&apos;</span><br></pre></td></tr></table></figure><p>现在，Jessica 在 <code>featureB</code> 分支上创建了几次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim lib/simplegit.rb</span><br><span class="line">$ git commit -am &apos;made the ls-tree function recursive&apos;</span><br><span class="line">[featureB e5b0fdc] made the ls-tree function recursive</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line">$ vim lib/simplegit.rb</span><br><span class="line">$ git commit -am &apos;add ls-files&apos;</span><br><span class="line">[featureB 8512791] add ls-files</span><br><span class="line"> 1 files changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>Jessica 的仓库看起来像这样：</p><p><img src="git-chapter-2/img10.png" alt></p><p>她准备好推送工作了，但是一封来自 Josie 的邮件告知一些初始工作已经被推送到服务器上的 <code>featureBee</code> 上了。 Jessica 在能推送到服务器前首先需要将那些改动与她自己的合并。 然后她可以通过 <code>git fetch</code> 抓取 Josie 的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">...</span><br><span class="line">From jessica@githost:simplegit</span><br><span class="line"> * [new branch]      featureBee -&gt; origin/featureBee</span><br></pre></td></tr></table></figure><p>Jessica 现在可以通过 <code>git merge</code> 将其合并到她做的工作中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/featureBee</span><br><span class="line">Auto-merging lib/simplegit.rb</span><br><span class="line">Merge made by recursive.</span><br><span class="line"> lib/simplegit.rb |    4 ++++</span><br><span class="line"> 1 files changed, 4 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>有点儿问题——她需要将在 <code>featureB</code> 分支上合并的工作推送到服务器上的 <code>featureBee</code> 分支。 她可以通过指定本地分支加上冒号（<code>:</code>）加上远程分支给 <code>git push</code> 命令来这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin featureB:featureBee</span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   fba9af8..cd685d1  featureB -&gt; featureBee</span><br></pre></td></tr></table></figure><p>这称作一个 引用规格。 查看 引用规格 了解关于 Git 引用规格与通过它们可以做的不同的事情的详细讨论。 也要注意 <code>-u</code> 标记；这是 <code>--set-upstream</code> 的简写，该标记会为之后轻松地推送与拉取配置分支。</p><p>紧接着，John 发邮件给 Jessica 说他已经推送了一些改动到 <code>featureA</code> 分支并要求她去验证它们。 她运行一个 <code>git fetch</code> 来拉取下那些改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">...</span><br><span class="line">From jessica@githost:simplegit</span><br><span class="line">   3300904..aad881d  featureA   -&gt; origin/featureA</span><br></pre></td></tr></table></figure><p>然后，通过 <code>git log</code> 她可以看到哪些发生了改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log featureA..origin/featureA</span><br><span class="line">commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6</span><br><span class="line">Author: John Smith &lt;jsmith@example.com&gt;</span><br><span class="line">Date:   Fri May 29 19:57:33 2009 -0700</span><br><span class="line"></span><br><span class="line">    changed log output to 30 from 25</span><br></pre></td></tr></table></figure><p>最终，她合并 John 的工作到她自己的 <code>featureA</code> 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout featureA</span><br><span class="line">Switched to branch &apos;featureA&apos;</span><br><span class="line">$ git merge origin/featureA</span><br><span class="line">Updating 3300904..aad881d</span><br><span class="line">Fast forward</span><br><span class="line"> lib/simplegit.rb |   10 +++++++++-</span><br><span class="line">1 files changed, 9 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>Jessica 想要轻微调整一些东西，所以她再次提交然后将其推送回服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;small tweak&apos;</span><br><span class="line">[featureA 774b3ed] small tweak</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line">$ git push</span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   3300904..774b3ed  featureA -&gt; featureA</span><br></pre></td></tr></table></figure><p>Jessica 的提交历史现在看起来像这样：</p><p><img src="git-chapter-2/img11.png" alt></p><p>Jessica、Josie 与 John 通知整合者在服务器上的 <code>featureA</code> 与 <code>featureBee</code> 分支准备好整合到主线中了。 在整合者合并这些分支到主线后，一次抓取会拿下来一个新的合并提交，使历史看起来像这样：</p><p><img src="git-chapter-2/img12.png" alt></p><p>许多团队切换到 Git 是因为这一允许多个团队并行工作、并在之后合并不同工作的能力。 团队中更小一些的子小组可以通过远程分支协作而不必影响或妨碍整个团队的能力是 Git 的一个巨大优势。 在这儿看到的工作流程顺序类似这样：</p><p><img src="git-chapter-2/img13.png" alt></p><h4 id="派生的公开项目"><a href="#派生的公开项目" class="headerlink" title="派生的公开项目"></a>派生的公开项目</h4><p>向公开项目做贡献有一点儿不同。 因为没有权限直接更新项目的分支，你必须用其他办法将工作给维护者。 第一个例子描述在支持简单派生的 Git 托管上使用派生来做贡献。 许多托管站点支持这个功能（包括 GitHub、BitBucket、Google Code、repo.or.cz 等等），许多项目维护者期望这种风格的贡献。 下一节会讨论偏好通过邮件接受贡献补丁的项目。</p><p>首先，你可能想要克隆主仓库，为计划贡献的补丁或补丁序列创建一个特性分支，然后在那儿做工作。 顺序看起来基本像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone (url)</span><br><span class="line">$ cd project</span><br><span class="line">$ git checkout -b featureA</span><br><span class="line"># (work)</span><br><span class="line">$ git commit</span><br><span class="line"># (work)</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>当你的分支工作完成后准备将其贡献回维护者，去原始项目中然后点击 “Fork” 按钮，创建一份自己的可写的项目派生仓库。 然后需要添加这个新仓库 URL 为第二个远程仓库，在本例中称作 <code>myfork</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add myfork (url)</span><br></pre></td></tr></table></figure><p>然后需要推送工作到上面。 相对于合并到主分支再推送上去，推送你正在工作的特性分支到仓库上更简单。 原因是工作如果不被接受或者是被拣选的，就不必回退你的 <code>master</code> 分支。 如果维护者合并、变基或拣选你的工作，不管怎样你最终会通过拉取他们的仓库找回来你的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u myfork featureA</span><br></pre></td></tr></table></figure><p>当工作已经被推送到你的派生后，你需要通知维护者。 这通常被称作一个拉取请求（pull request），你既可以通过网站生成它—— GitHub 有它自己的 Pull Request 机制，我们将会在 GitHub 介绍——也可以运行 <code>git request-pull</code> 命令然后手动地将输出发送电子邮件给项目的维护者。</p><p><code>request-pull</code> 命令接受特性分支拉入的基础分支，以及它们拉入的 Git 仓库 URL，输出请求拉入的所有修改的总结。 例如，Jessica 想要发送给 John 一个拉取请求，她已经在刚刚推送的分支上做了两次提交。她可以运行这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git request-pull origin/master myfork</span><br><span class="line">The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:</span><br><span class="line">  John Smith (1):</span><br><span class="line">        added a new function</span><br><span class="line"></span><br><span class="line">are available in the git repository at:</span><br><span class="line"></span><br><span class="line">  git://githost/simplegit.git featureA</span><br><span class="line"></span><br><span class="line">Jessica Smith (2):</span><br><span class="line">      add limit to log function</span><br><span class="line">      change log output to 30 from 25</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb |   10 +++++++++-</span><br><span class="line"> 1 files changed, 9 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>这个输出可以被发送给维护者——它告诉他们工作是从哪个分支开始、归纳的提交与从哪里拉入这些工作。</p><p>在一个你不是维护者的项目上，通常有一个总是跟踪 <code>origin/master</code> 的 <code>master</code> 分支会很方便，在特性分支上做工作是因为如果它们被拒绝时你可以轻松地丢弃。 如果同一时间主仓库移动了然后你的提交不再能干净地应用，那么使工作主题独立于特性分支也会使你变基（rebase）工作时更容易。 例如，你想要提供第二个特性工作到项目，不要继续在刚刚推送的特性分支上工作——从主仓库的 <code>master</code> 分支重新开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b featureB origin/master</span><br><span class="line"># (work)</span><br><span class="line">$ git commit</span><br><span class="line">$ git push myfork featureB</span><br><span class="line"># (email maintainer)</span><br><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure><p>现在，每一个特性都保存在一个贮藏库中——类似于补丁队列——可以重写、变基与修改而不会让特性互相干涉或互相依赖，像这样：</p><p><img src="git-chapter-2/img14.png" alt></p><p>假设项目维护者已经拉取了一串其他补丁，然后尝试拉取你的第一个分支，但是没有干净地合并。 在这种情况下，可以尝试变基那个分支到 <code>origin/master</code> 的顶部，为维护者解决冲突，然后重新提交你的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout featureA</span><br><span class="line">$ git rebase origin/master</span><br><span class="line">$ git push -f myfork featureA</span><br></pre></td></tr></table></figure><p>这样会重写你的历史，现在看起来像是 featureA 工作之后的提交历史</p><p><img src="git-chapter-2/img15.png" alt></p><p>因为你将分支变基了，所以必须为推送命令指定 <code>-f</code> 选项，这样才能将服务器上有一个不是它的后代的提交的 <code>featureA</code> 分支替换掉。 一个替代的选项是推送这个新工作到服务器上的一个不同分支（可能称作 <code>featureAv2</code>）。</p><p>让我们看一个更有可能的情况：维护者看到了你的第二个分支上的工作并且很喜欢其中的概念，但是想要你修改一下实现的细节。 你也可以利用这次机会将工作基于项目现在的 <code>master</code> 分支。 你从现在的 <code>origin/master</code> 分支开始一个新分支，在那儿压缩 <code>featureB</code> 的改动，解决任何冲突，改变实现，然后推送它为一个新分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b featureBv2 origin/master</span><br><span class="line">$ git merge --squash featureB</span><br><span class="line"># (change implementation)</span><br><span class="line">$ git commit</span><br><span class="line">$ git push myfork featureBv2</span><br></pre></td></tr></table></figure><p><code>--squash</code> 选项接受被合并的分支上的所有工作，并将其压缩至一个变更集，使仓库变成一个真正的合并发生的状态，而不会真的生成一个合并提交。 这意味着你的未来的提交将会只有一个父提交，并允许你引入另一个分支的所有改动，然后在记录一个新提交前做更多的改动。 同样 <code>--no-commit</code> 选项在默认合并过程中可以用来延迟生成合并提交。</p><p>现在你可以给维护者发送一条消息，表示你已经做了要求的修改然后他们可以在你的 <code>featureBv2</code> 分支上找到那些改动。</p><p><img src="git-chapter-2/img16.png" alt></p><h4 id="通过邮件的公开项目"><a href="#通过邮件的公开项目" class="headerlink" title="通过邮件的公开项目"></a>通过邮件的公开项目</h4><p>许多项目建立了接受补丁的流程——需要检查每一个项目的特定规则，因为它们之间有区别。 因为有几个历史悠久的、大型的项目会通过一个开发者的邮件列表接受补丁，现在我们将会通过一个例子来演示。</p><p>工作流程与之前的用例是类似的——你为工作的每一个补丁序列创建特性分支。 区别是如何提交它们到项目中。 生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表，而不是派生项目然后推送到你自己的可写版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b topicA</span><br><span class="line"># (work)</span><br><span class="line">$ git commit</span><br><span class="line"># (work)</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>现在有两个提交要发送到邮件列表。 使用 <code>git format-patch</code> 来生成可以邮寄到列表的 mbox 格式的文件——它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。 它有一个好处是使用 <code>format-patch</code> 生成的一封电子邮件应用的提交正确地保留了所有的提交信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git format-patch -M origin/master</span><br><span class="line">0001-add-limit-to-log-function.patch</span><br><span class="line">0002-changed-log-output-to-30-from-25.patch</span><br></pre></td></tr></table></figure><p><code>format-patch</code> 命令打印出它创建的补丁文件名字。 <code>-M</code> 开关告诉 Git 查找重命名。 文件最后看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat 0001-add-limit-to-log-function.patch</span><br><span class="line">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">Date: Sun, 6 Apr 2008 10:17:23 -0700</span><br><span class="line">Subject: [PATCH 1/2] add limit to log function</span><br><span class="line"></span><br><span class="line">Limit log functionality to the first 20</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> lib/simplegit.rb |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index 76f47bc..f9815f1 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -14,7 +14,7 @@ class SimpleGit</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def log(treeish = &apos;master&apos;)</span><br><span class="line">-    command(&quot;git log #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 20 #&#123;treeish&#125;&quot;)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def ls_tree(treeish = &apos;master&apos;)</span><br><span class="line">--</span><br><span class="line">2.1.0</span><br></pre></td></tr></table></figure><p>也可以编辑这些补丁文件为邮件列表添加更多不想要在提交信息中显示出来的信息。 如果在 <code>---</code> 行与补丁开头（<code>diff --git</code> 行）之间添加文本，那么开发者就可以阅读它；但是应用补丁时会排除它。</p><p>为了将其邮寄到邮件列表，你既可以将文件粘贴进电子邮件客户端，也可以通过命令行程序发送它。 粘贴文本经常会发生格式化问题，特别是那些不会合适地保留换行符与其他空白的 “更聪明的” 客户端。 幸运的是，Git 提供了一个工具帮助你通过 IMAP 发送正确格式化的补丁，这可能对你更容易些。 我们将会演示如何通过 Gmail 发送一个补丁，它正好是我们所知最好的邮件代理；可以在之前提到的 Git 源代码中的 <code>Documentation/SubmittingPatches</code> 文件的最下面了解一系列邮件程序的详细指令。</p><p>首先，需要在 <code>~/.gitconfig</code> 文件中设置 imap 区块。 可以通过一系列的 <code>git config</code> 命令来分别设置每一个值，或者手动添加它们，不管怎样最后配置文件应该看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[imap]</span><br><span class="line">  folder = &quot;[Gmail]/Drafts&quot;</span><br><span class="line">  host = imaps://imap.gmail.com</span><br><span class="line">  user = user@gmail.com</span><br><span class="line">  pass = p4ssw0rd</span><br><span class="line">  port = 993</span><br><span class="line">  sslverify = false</span><br></pre></td></tr></table></figure><p>如果 IMAP 服务器不使用 SSL，最后两行可能没有必要，host 的值会是 <code>imap://</code> 而不是 <code>imaps://</code>。 当那些设置完成后，可以使用 <code>git imap-send</code> 将补丁序列放在特定 IMAP 服务器的 Drafts 文件夹中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat *.patch |git imap-send</span><br><span class="line">Resolving imap.gmail.com... ok</span><br><span class="line">Connecting to [74.125.142.109]:993... ok</span><br><span class="line">Logging in...</span><br><span class="line">sending 2 messages</span><br><span class="line">100% (2/2) done</span><br></pre></td></tr></table></figure><p>在这个时候，你应该能够到 Drafts 文件夹中，修改收件人字段为想要发送补丁的邮件列表，可能需要抄送给维护者或负责那个部分的人，然后发送。</p><p>你也可以通过一个 SMTP 服务器发送补丁。 同之前一样，你可以通过一系列的 <code>git config</code> 命令来分别设置选项，或者你可以手动地将它们添加到你的 <code>~/.gitconfig</code> 文件的 <code>sendmail</code> 区块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[sendemail]</span><br><span class="line">  smtpencryption = tls</span><br><span class="line">  smtpserver = smtp.gmail.com</span><br><span class="line">  smtpuser = user@gmail.com</span><br><span class="line">  smtpserverport = 587</span><br></pre></td></tr></table></figure><p>当这完成后，你可以使用 <code>git send-email</code> 发送你的补丁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git send-email *.patch</span><br><span class="line">0001-added-limit-to-log-function.patch</span><br><span class="line">0002-changed-log-output-to-30-from-25.patch</span><br><span class="line">Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]</span><br><span class="line">Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">Who should the emails be sent to? jessica@example.com</span><br><span class="line">Message-ID to be used as In-Reply-To for the first email? y</span><br></pre></td></tr></table></figure><p>然后，对于正在发送的每一个补丁，Git 会吐出这样的一串日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from</span><br><span class="line">  \line &apos;From: Jessica Smith &lt;jessica@example.com&gt;&apos;</span><br><span class="line">OK. Log says:</span><br><span class="line">Sendmail: /usr/sbin/sendmail -i jessica@example.com</span><br><span class="line">From: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">To: jessica@example.com</span><br><span class="line">Subject: [PATCH 1/2] added limit to log function</span><br><span class="line">Date: Sat, 30 May 2009 13:29:15 -0700</span><br><span class="line">Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;</span><br><span class="line">X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty</span><br><span class="line">In-Reply-To: &lt;y&gt;</span><br><span class="line">References: &lt;y&gt;</span><br><span class="line"></span><br><span class="line">Result: OK</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个部分介绍了处理可能会遇到的几个迥然不同类型的 Git 项目的一些常见的工作流程，介绍了帮助管理这个过程的一些新工具。 接下来，你会了解到如何在贡献的另一面工作：维护一个 Git 项目。 你将会学习如何成为一个仁慈的独裁者或整合管理者。</p><h3 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h3><p>除了如何有效地参与一个项目的贡献之外，你可能也需要了解如何维护项目。 这包含接受并应用别人使用 <code>format-patch</code> 生成并通过电子邮件发送过来的补丁，或对项目添加的远程版本库分支中的更改进行整合。 但无论是管理版本库，还是帮忙验证、审核收到的补丁，都需要同其他贡献者约定某种长期可持续的工作方式。</p><h4 id="在特性分支中工作"><a href="#在特性分支中工作" class="headerlink" title="在特性分支中工作"></a>在特性分支中工作</h4><p>如果你想向项目中整合一些新东西，最好将这些尝试局限在特性分支——一种通常用来尝试新东西的临时分支中。 这样便于单独调整补丁，如果遇到无法正常工作的情况，可以先不用管，等到有时间的时候再来处理。 如果你基于你所尝试进行工作的特性为分支创建一个简单的名字，比如 <code>ruby_client</code> 或者具有类似描述性的其他名字，这样即使你必须暂时抛弃它，以后回来时也不会忘记。 项目的维护者一般还会为这些分支附带命名空间，比如 <code>sc/ruby_client</code>（其中 sc 是贡献该项工作的人名称的简写）。 你应该记得，可以使用如下方式基于 master 分支建立特性分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch sc/ruby_client master</span><br></pre></td></tr></table></figure><p>或者如果你同时想立刻切换到新分支上的话，可以使用 <code>checkout -b</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sc/ruby_client master</span><br></pre></td></tr></table></figure><p>现在你已经准备好将别人贡献的工作加入到这个特性分支，并考虑是否将其合并到长期分支中去了。</p><h4 id="应用来自邮件的补丁"><a href="#应用来自邮件的补丁" class="headerlink" title="应用来自邮件的补丁"></a>应用来自邮件的补丁</h4><p>如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到特性分支中进行评估。 有两种应用该种补丁的方法：使用 <code>git apply</code>，或者使用 <code>git am</code>。</p><p><strong>使用 apply 命令应用补丁</strong><br>如果你收到了一个使用 <code>git diff</code> 或 <code>Unix diff</code> 命令（不推荐使用这种方式，具体见下一节）创建的补丁，可以使用 <code>git apply</code> 命令来应用。 假设你将补丁保存在了 <code>/tmp/patch-ruby-client.patch</code> 中，可以这样应用补丁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git apply /tmp/patch-ruby-client.patch</span><br></pre></td></tr></table></figure><p>这会修改工作目录中的文件。 它与运行 <code>patch -p1</code> 命令来应用补丁几乎是等效的，但是这种方式更加严格，相对于 <code>patch</code> 来说，它能够接受的模糊匹配更少。 它也能够处理 <code>git diff</code> 格式文件所描述的文件添加、删除和重命名操作，而 <code>patch</code> 则不会。 最后，<code>git apply</code> 命令采用了一种“全部应用，否则就全部撤销（apply all or abort all）”的模型，即补丁只有全部内容都被应用和完全不被应用两个状态，而 <code>patch</code> 可能会导致补丁文件被部分应用，最后使你的工作目录保持在一个比较奇怪的状态。 总体来看，<code>git apply</code> 命令要比 <code>patch</code> 谨慎得多。 并且，它不会为你创建提交——在运行之后，你需要手动暂存并提交补丁所引入的更改。</p><p>在实际应用补丁前，你还可以使用 <code>git apply</code> 来检查补丁是否可以顺利应用——即对补丁运行 <code>git apply --check</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git apply --check 0001-seeing-if-this-helps-the-gem.patch</span><br><span class="line">error: patch failed: ticgit.gemspec:1</span><br><span class="line">error: ticgit.gemspec: patch does not apply</span><br></pre></td></tr></table></figure><p>如果没有产生输出，则该补丁可以顺利应用。 如果检查失败了，该命令还会以一个非零的状态退出，所以需要时你也可以在脚本中使用它。</p><p><strong>使用 am 命令应用补丁</strong><br>如果补丁的贡献者也是一个 Git 用户，并且其能熟练使用 <code>format-patch</code> 命令来生成补丁，这样的话你的工作会变得更加轻松，因为这种补丁中包含了作者信息和提交信息供你参考。 如果可能的话，请鼓励贡献者使用 <code>format-patch</code> 而不是 <code>diff</code> 来为你生成补丁。 而只有对老式的补丁，你才必须使用 <code>git apply</code> 命令。</p><p>要应用一个由 <code>format-patch</code> 命令生成的补丁，你应该使用 <code>git am</code> 命令。 从技术的角度看，<code>git am</code> 是为了读取 mbox 文件而构建的，mbox 是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式。 其大致格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">Date: Sun, 6 Apr 2008 10:17:23 -0700</span><br><span class="line">Subject: [PATCH 1/2] add limit to log function</span><br><span class="line"></span><br><span class="line">Limit log functionality to the first 20</span><br></pre></td></tr></table></figure><p>这其实就是你前面看到的 <code>format-patch</code> 命令输出的开始几行。 而同时它也是有效的 mbox 电子邮件格式。 如果有人使用 <code>git send-email</code> 命令将补丁以电子邮件的形式发送给你，你便可以将它下载为 mbox 格式的文件，之后将 <code>git am</code> 命令指向该文件，它会应用其中包含的所有补丁。 如果你所使用的邮件客户端能够同时将多封邮件保存为 mbox 格式的文件，你甚至能够将一系列补丁打包为单个 mbox 文件，并利用 <code>git am</code> 命令将它们一次性全部应用。</p><p>然而，如果贡献者将 <code>format-patch</code> 生成的补丁文件上传到类似 Request Ticket 的任务处理系统，你可以先将其保存到本地，之后通过 <code>git am</code> 来应用补丁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git am 0001-limit-log-function.patch</span><br><span class="line">Applying: add limit to log function</span><br></pre></td></tr></table></figure><p>你会看到补丁被顺利地应用，并且为你自动创建了一个新的提交。 其中的作者信息来自于电子邮件头部的 <code>From</code> 和 <code>Date</code> 字段，提交消息则取自 <code>Subject</code> 和邮件正文中补丁之前的内容。 比如，应用上面那个 mbox 示例后生成的提交是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=fuller -1</span><br><span class="line">commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0</span><br><span class="line">Author:     Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">AuthorDate: Sun Apr 6 10:17:23 2008 -0700</span><br><span class="line">Commit:     Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">CommitDate: Thu Apr 9 09:19:06 2009 -0700</span><br><span class="line"></span><br><span class="line">   add limit to log function</span><br><span class="line"></span><br><span class="line">   Limit log functionality to the first 20</span><br></pre></td></tr></table></figure><p>其中 <code>Commit</code> 信息表示的是应用补丁的人和应用补丁的时间。 <code>Author</code> 信息则表示补丁的原作者和原本的创建时间。</p><p>但是，有时候无法顺利地应用补丁。 这也许是因为你的主分支和创建补丁的分支相差较多，也有可能是因为这个补丁依赖于其他你尚未应用的补丁。 这种情况下，<code>git am</code> 进程将会报错并且询问你要做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git am 0001-seeing-if-this-helps-the-gem.patch</span><br><span class="line">Applying: seeing if this helps the gem</span><br><span class="line">error: patch failed: ticgit.gemspec:1</span><br><span class="line">error: ticgit.gemspec: patch does not apply</span><br><span class="line">Patch failed at 0001.</span><br><span class="line">When you have resolved this problem run &quot;git am --resolved&quot;.</span><br><span class="line">If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.</span><br><span class="line">To restore the original branch and stop patching run &quot;git am --abort&quot;.</span><br></pre></td></tr></table></figure><p>该命令将会在所有出现问题的文件内加入冲突标记，就和发生冲突的合并或变基操作一样。 而你解决问题的手段很大程度上也是一样的——即手动编辑那些文件来解决冲突，暂存新的文件，之后运行 <code>git am --resolved</code> 继续应用下一个补丁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ (fix the file)</span><br><span class="line">$ git add ticgit.gemspec</span><br><span class="line">$ git am --resolved</span><br><span class="line">Applying: seeing if this helps the gem</span><br></pre></td></tr></table></figure><p>如果你希望 Git 能够尝试以更加智能的方式解决冲突，你可以对其传递 <code>-3</code> 选项来使 Git 尝试进行三方合并。 该选项默认并没有打开，因为如果用于创建补丁的提交并不在你的版本库内的话，这样做是没有用处的。 而如果你确实有那个提交的话——比如补丁是基于某个公共提交的——那么通常 <code>-3</code> 选项对于应用有冲突的补丁是更加明智的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git am -3 0001-seeing-if-this-helps-the-gem.patch</span><br><span class="line">Applying: seeing if this helps the gem</span><br><span class="line">error: patch failed: ticgit.gemspec:1</span><br><span class="line">error: ticgit.gemspec: patch does not apply</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">No changes -- Patch already applied.</span><br></pre></td></tr></table></figure><p>比如上面这种情况，我在之前已经应用过同样的补丁。 如果没有 <code>-3</code> 选项的话，这看起来就像是存在一个冲突。</p><p>如果你正在利用一个 mbox 文件应用多个补丁，也可以在交互模式下运行 <code>am</code> 命令，这样在每个补丁之前，它会停住询问你是否要应用该补丁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git am -3 -i mbox</span><br><span class="line">Commit Body is:</span><br><span class="line">--------------------------</span><br><span class="line">seeing if this helps the gem</span><br><span class="line">--------------------------</span><br><span class="line">Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</span><br></pre></td></tr></table></figure><p>这在你保存的补丁较多时很好用，因为你可以在应用之前查看忘掉内容的补丁，并且跳过已经应用过的补丁。</p><p>当与你的特性相关的所有补丁都被应用并提交到分支中之后，你就可以选择是否以及如何将其整合到更长期的分支中去了。</p><h4 id="检出远程分支"><a href="#检出远程分支" class="headerlink" title="检出远程分支"></a>检出远程分支</h4><p>如果你的贡献者建立了自己的版本库，并且向其中推送了若干修改，之后将版本库的 URL 和包含更改的远程分支发送给你，那么你可以将其添加为一个远程分支，并且在本地进行合并。</p><p>比如 Jessica 向你发送了一封电子邮件，内容是在她的版本库中的 <code>ruby-client</code> 分支中有一个很不错的新功能，为了测试该功能，你可以将其添加为一个远程分支，并在本地检出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add jessica git://github.com/jessica/myproject.git</span><br><span class="line">$ git fetch jessica</span><br><span class="line">$ git checkout -b rubyclient jessica/ruby-client</span><br></pre></td></tr></table></figure><p>如果她再次发邮件说另一个分支中包含另一个优秀功能，因为之前已经设置好远程分支了，你就可以直接进行抓取及检出操作。</p><p>这对于与他人长期合作工作来说很有用。 而对于提交补丁频率较小的贡献者，相对于每个人维护自己的服务器，不断增删远程分支的做法，使用电子邮件来接收可能会比较省时。 况且你也不会想要加入数百个只提供一两个补丁的远程分支。 然而，脚本和托管服务在一定程度上可以简化这些工作——这很大程度上依赖于你和你的贡献者开发的方式。</p><p>这种方式的另一种优点是你可以同时得到提交历史。 虽然代码合并中可能会出现问题，但是你能获知他人的工作是基于你的历史中的具体哪一个位置；所以 Git 会默认进行三方合并，不需要提供 <code>-3</code> 选项，你也不需要担心补丁是基于某个你无法访问的提交生成的。</p><p>对于非持续性的合作，如果你依然想要以这种方式拉取数据的话，你可以对远程版本库的 URL 调用 <code>git pull</code> 命令。 这会执行一个一次性的抓取，而不会将该 URL 存为远程引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull https://github.com/onetimeguy/project</span><br><span class="line">From https://github.com/onetimeguy/project</span><br><span class="line"> * branch            HEAD       -&gt; FETCH_HEAD</span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure><h4 id="确定引入了哪些东西"><a href="#确定引入了哪些东西" class="headerlink" title="确定引入了哪些东西"></a>确定引入了哪些东西</h4><p>你已经有了一个包含其他人贡献的特性分支。 现在你可以决定如何处理它们了。 本节回顾了若干命令，以便于你检查若将其合并入主分支所引入的更改。</p><p>一般来说，你应该对该分支中所有 master 分支尚未包含的提交进行检查。 通过在分支名称前加入 <code>--not</code> 选项，你可以排除 master 分支中的提交。 这和我们之前使用的 <code>master..contrib</code> 格式是一样的。 假设贡献者向你发送了两个补丁，为此你创建了一个名叫 <code>contrib</code> 的分支并在其上应用补丁，你可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log contrib --not master</span><br><span class="line">commit 5b6235bd297351589efc4d73316f0a68d484f118</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Oct 24 09:53:59 2008 -0700</span><br><span class="line"></span><br><span class="line">    seeing if this helps the gem</span><br><span class="line"></span><br><span class="line">commit 7482e0d16d04bea79d0dba8988cc78df655f16a0</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Oct 22 19:38:36 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated the gemspec to hopefully work better</span><br></pre></td></tr></table></figure><p>如果要查看每次提交所引入的具体修改，你应该记得可以给 <code>git log</code> 命令传递 <code>-p</code> 选项，这样它会在每次提交后面附加对应的差异（diff）。</p><p>而要查看将该特性分支与另一个分支合并的完整 diff，你可能需要使用一个有些奇怪的技巧来得到正确的结果。 你可能会想到这种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff master</span><br></pre></td></tr></table></figure><p>这个命令会输出一个 diff，但它可能并不是我们想要的。 如果在你创建特性分支之后，<code>master</code> 分支向前移动了，你获得的结果就会显得有些不对。 这是因为 Git 会直接将该特性分支与 <code>master</code> 分支的最新提交快照进行比较。 比如说你在 <code>master</code> 分支中向某个文件添加了一行内容，那么直接比对最新快照的结果看上去就像是你在特性分支中将这一行删除了。</p><p>如果 <code>master</code> 分支是你的特性分支的直接祖先，其实是没有任何问题的；但是一旦两个分支的历史产生了分叉，上述比对产生的 <code>diff</code> 看上去就像是将特性分支中所有的新东西加入，并且将 <code>master</code> 分支所独有的东西删除。</p><p>而你真正想要检查的东西，实际上仅仅是特性分支所添加的更改——也就是该分支与 <code>master</code> 分支合并所要引入的工作。 要达到此目的，你需要让 Git 对特性分支上最新的提交与该分支与 <code>master</code> 分支的首个公共祖先进行比较。</p><p>从技术的角度讲，你可以以手工的方式找出公共祖先，并对其显式运行 <code>diff</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge-base contrib master</span><br><span class="line">36c7dba2c95e6bbb78dfa822519ecfec6e1ca649</span><br><span class="line">$ git diff 36c7db</span><br></pre></td></tr></table></figure><p>然而，这种做法比较麻烦，所以 Git 提供了一种比较便捷的方式：三点语法。 对于 <code>diff</code> 命令来说，你可以通过把 <code>...</code> 置于另一个分支名后来对该分支的最新提交与两个分支的共同祖先进行比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff master...contrib</span><br></pre></td></tr></table></figure><p>该命令仅会显示自当前特性分支与 master 分支的共同祖先起，该分支中的工作。 这个语法很有用，应该牢记。</p><h4 id="将贡献的工作整合进来"><a href="#将贡献的工作整合进来" class="headerlink" title="将贡献的工作整合进来"></a>将贡献的工作整合进来</h4><p>当特性分支中所有的工作都已经准备好整合进入更靠近主线的分支时，接下来的问题就是如何进行整合了。 此外，还有一个问题是，你想使用怎样的总体工作流来维护你的项目？ 你的选择有很多，我们会介绍其中的一部分。</p><p><strong>合并工作流</strong><br>一种非常简单的工作流会直接将工作合并进入 <code>master</code> 分支。 在这种情况下，<code>master</code> 分支包含的代码是基本稳定的。 当你完成某个特性分支的工作，或审核通过了其他人所贡献的工作时，你会将其合并进入 <code>master</code> 分支，之后将特性分支删除，如此反复。 如果我们的版本库包含类似 包含若干特性分支的提交历史。 的两个名称分别为 <code>ruby_client</code> 和 <code>php_client</code> 的分支，并且我们先合并 <code>ruby_client</code> 分支，之后合并 <code>php_client</code> 分支，那么提交历史最后会变成 合并特性分支之后。 的样子。</p><p><img src="git-chapter-3/img1.png" alt></p><p><img src="git-chapter-3/img2.png" alt></p><p>这也许是最简单的工作流了，但是当项目更大，或更稳定，你对自己所引入的工作更加在意时，它可能会带来问题。</p><p>如果你的项目非常重要，你可能会使用两阶段合并循环。 在这种情况下，你会维护两个长期分支，分别是 <code>master</code> 和 <code>develop</code>，<code>master</code> 分支只会在一个非常稳定的版本发布时才会更新，而所有的新代码会首先整合进入 <code>develop</code> 分支。 你定期将这两个分支推送到公共版本库中。 每次需要合并新的特性分支时（合并特性分支前。），你都应该合并进入 <code>develop</code> 分支（合并特性分支后。）；当打标签发布的时候，你会将 <code>master</code> 分支快进到已经稳定的 <code>develop</code> 分支（一次发布之后）。</p><p><img src="git-chapter-3/img3.png" alt></p><p><img src="git-chapter-3/img4.png" alt></p><p><img src="git-chapter-3/img5.png" alt></p><p>这样当人们克隆你项目的版本库后，既可以检出 <code>master</code> 分支以构建最新的稳定版本并保持更新，也可以检出包含更多新东西的 <code>develop</code> 分支。 你也可以扩展这个概念，维护一个将所有工作合并到一起的整合分支。 当该分支的代码稳定并通过测试之后，将其合并进入 <code>develop</code> 分支；经过一段时间，确认其稳定之后，将其以快进的形式并入 <code>master</code> 分支。</p><p><strong>大项目合并工作流</strong><br>Git 项目包含四个长期分支：<code>master</code>、<code>next</code>，用于新工作的 pu（proposed updates）和用于维护性向后移植工作（maintenance backports）的 <code>maint</code> 分支。 贡献者的新工作会以类似之前所介绍的方式收入特性分支中（见 管理复杂的一系列接收贡献的平行特性分支。）。 之后对特性分支进行测试评估，检查其是否已经能够合并，或者仍需要更多工作。 安全的特性分支会被合并入 <code>next</code> 分支，之后该分支会被推送使得所有人都可以尝试整合到一起的特性。</p><p><img src="git-chapter-3/img6.png" alt></p><p>如果特性分支需要更多工作，它则会被并入 <code>pu</code> 分支。 当它们完全稳定之后，会被再次并入 <code>master</code> 分支。 这意味着 <code>master</code> 分支始终在进行快进，<code>next</code> 分支偶尔会被变基，而 <code>pu</code> 分支的变基比较频繁：</p><p><img src="git-chapter-3/img7.png" alt></p><p>当特性分支最终被并入 <code>master</code> 分支后，便会被从版本库中删除掉。 Git 项目还有一个从上一次发布中派生出来的 <code>maint</code> 分支来提供向后移植过来的补丁以供发布维护更新。 因此，当你克隆 Git 的版本库之后，就会有四个可分别评估该项目开发的不同阶段的可检出的分支，检出哪个分支，取决于你需要多新的版本，或者你想要如何进行贡献；对于维护者来说，这套结构化的工作流能帮助它们审查新的贡献。</p><p><strong>变基与拣选工作流</strong><br>为了保持线性的提交历史，有些维护者更喜欢在 <code>master</code> 分支上对贡献过来的工作进行变基和拣选，而不是直接将其合并。 当你完成了某个特性分支中的工作，并且决定要将其整合的时候，你可以在该分支中运行变基命令，在当前 <code>master</code> 分支（或者是 <code>develop</code> 等分支）的基础上重新构造修改。 如果结果理想的话，你可以快进 <code>master</code> 分支，最后得到一个线性的项目提交历史。</p><p>另一种将引入的工作转移到其他分支的方法是拣选。 Git 中的拣选类似于对特定的某次提交的变基。 它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。 这种方式在你只想引入特性分支中的某个提交，或者特性分支中只有一个提交，而你不想运行变基时很有用。 举个例子，假设你的项目提交历史类似：</p><p><img src="git-chapter-3/img8.png" alt></p><p>如果你希望将提交 <code>e43a6</code> 拉取到 <code>master</code> 分支，你可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf</span><br><span class="line">Finished one cherry-pick.</span><br><span class="line">[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;</span><br><span class="line"> 3 files changed, 17 insertions(+), 3 deletions(-)</span><br></pre></td></tr></table></figure><p>这样会拉取和 <code>e43a6</code> 相同的更改，但是因为应用的日期不同，你会得到一个新的提交 SHA-1 值。 现在你的历史会变成这样：</p><p><img src="git-chapter-3/img9.png" alt></p><p>现在你可以删除这个特性分支，并丢弃不想拉入的提交。</p><p><strong>Rerere</strong><br>如果你在进行大量的合并或变基，或维护一个长期的特性分支，Git 提供的一个叫做“rerere”的功能会有一些帮助。</p><p>Rerere 是“重用已记录的冲突解决方案（reuse recorded resolution）”的意思——它是一种简化冲突解决的方法。 当启用 rerere 时，Git 将会维护一些成功合并之前和之后的镜像，当 Git 发现之前已经修复过类似的冲突时，便会使用之前的修复方案，而不需要你的干预。</p><p>这个功能包含两个部分：一个配置选项和一个命令。 其中的配置选项是 <code>rerere.enabled</code>，把它放在全局配置中就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global rerere.enabled true</span><br></pre></td></tr></table></figure><p>现在每当你进行一次需要解决冲突的合并时，解决方案都会被记录在缓存中，以备之后使用。</p><p>如果你需要和 rerere 的缓存交互，你可以使用 <code>git rerere</code> 命令。 当单独调用它时，Git 会检查解决方案数据库，尝试寻找一个和当前任一冲突相关的匹配项并解决冲突（尽管当 <code>rerere.enabled</code> 被设置为 <code>true</code> 时会自动进行）。 它也有若干子命令，可用来查看记录项，删除特定解决方案和清除缓存全部内容等。 我们将在 Rerere 中详细探讨。</p><h4 id="为发布打标签"><a href="#为发布打标签" class="headerlink" title="为发布打标签"></a>为发布打标签</h4><p>当你决定进行一次发布时，你可能想要留下一个标签，这样在之后的任何一个提交点都可以重新创建该发布。 你在 Git 基础 中已经了解了创建新标签的过程。 作为一个维护者，如果你决定要为标签签名的话，打标签的过程应该是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;</span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">1024-bit DSA key, ID F721C45A, created 2009-02-09</span><br></pre></td></tr></table></figure><p>如果你为标签签名了，你可能会遇到分发用来签名的 PGP 公钥的问题。 Git 项目的维护者已经解决了这一问题，其方法是在版本库中以 blob 对象的形式包含他们的公钥，并添加一个直接指向该内容的标签。 要完成这一任务，首先你可以通过运行 <code>gpg --list-keys</code> 找出你所想要的 key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line">/Users/schacon/.gnupg/pubring.gpg</span><br><span class="line">---------------------------------</span><br><span class="line">pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]</span><br><span class="line">uid                  Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</span><br></pre></td></tr></table></figure><p>之后你可以通过导出 key 并通过管道传递给 <code>git hash-object</code> 来直接将 key 导入到 Git 的数据库中，<code>git hash-object</code> 命令会向 Git 中写入一个包含其内容的新 blob 对象，并向你返回该 blob 对象的 SHA-1 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gpg -a --export F721C45A | git hash-object -w --stdin</span><br><span class="line">659ef797d181633c87ec71ac3f9ba29fe5775b92</span><br></pre></td></tr></table></figure><p>既然 Git 中已经包含你的 key 的内容了，你就可以通过指定由 <code>hash-object</code> 命令给出的新 SHA-1 值来创建一个直接指向它的标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</span><br></pre></td></tr></table></figure><p>如果你运行 <code>git push --tags</code> 命令，那么 <code>maintainer-pgp-pub</code> 标签将会被共享给所有人。 需要校验标签的人可以通过从数据库中直接拉取 blob 对象并导入到 GPG 中来导入 PGP key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show maintainer-pgp-pub | gpg --import</span><br></pre></td></tr></table></figure><p>人们可以使用这个 key 来校验所有由你签名的标签。 另外，如果你在标签信息中包含了一些操作说明，用户可以通过运行 <code>git show &lt;tag&gt;</code> 来获取更多关于标签校验的说明。</p><h4 id="生成一个构建号"><a href="#生成一个构建号" class="headerlink" title="生成一个构建号"></a>生成一个构建号</h4><p>Git 中不存在随每次提交递增的“v123”之类的数字序列，如果你想要为提交附上一个可读的名称，可以对其运行 <code>git describe</code> 命令。 Git 将会给出一个字符串，它由最近的标签名、自该标签之后的提交数目和你所描述的提交的部分 SHA-1 值构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git describe master</span><br><span class="line">v1.6.2-rc1-20-g8c5b85c</span><br></pre></td></tr></table></figure><p>这样你在导出一个快照或构建时，可以给出一个便于人们理解的命名。 实际上，如果你的 Git 是从 Git 自己的版本库克隆下来并构建的，那么 <code>git --version</code> 命令给出的结果是与此类似的。 如果你所描述的提交自身就有一个标签，那么它将只会输出标签名，没有后面两项信息。</p><p>注意 <code>git describe</code> 命令只适用于有注解的标签（即使用 <code>-a</code> 或 <code>-s</code> 选项创建的标签），所以如果你在使用 <code>git describe</code> 命令的话，为了确保能为标签生成合适的名称，打发布标签时都应该采用加注解的方式。 你也可以使用这个字符串来调用 <code>checkout</code> 或 <code>show</code> 命令，但是这依赖于其末尾的简短 SHA-1 值，因此不一定一直有效。 比如，最近 Linux 内核为了保证 SHA-1 值对象的唯一性，将其位数由 8 位扩展到了 10 位，导致以前的 <code>git describe</code> 输出全部失效。`</p><h4 id="准备一次发布"><a href="#准备一次发布" class="headerlink" title="准备一次发布"></a>准备一次发布</h4><p>现在你可以发布一个构建了。 其中一件事情就是为那些不使用 Git 的可怜包们创建一个最新的快照归档。 使用 <code>git archive</code> 命令完成此工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git archive master --prefix=&apos;project/&apos; | gzip &gt; `git describe master`.tar.gz</span><br><span class="line">$ ls *.tar.gz</span><br><span class="line">v1.6.2-rc1-20-g8c5b85c.tar.gz</span><br></pre></td></tr></table></figure><p>如果有人将这个压缩包解压，他就可以得到你的项目文件夹的最新快照。 你也可以以类似的方式创建一个 zip 压缩包，但此时你应该向 <code>git archive</code> 命令传递 <code>--format=zip</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git archive master --prefix=&apos;project/&apos; --format=zip &gt; `git describe master`.zip</span><br></pre></td></tr></table></figure><p>现在你有了本次发布的一个 tar 包和一个 zip 包，可以将其上传到网站或以电子邮件的形式发送给人们。</p><h4 id="制作提交简报"><a href="#制作提交简报" class="headerlink" title="制作提交简报"></a>制作提交简报</h4><p>现在是时候通知邮件列表里那些好奇你的项目发生了什么的人了。 使用 <code>git shortlog</code> 命令可以快速生成一份包含从上次发布之后项目新增内容的修改日志（changelog）类文档。 它会对你给定范围内的所有提交进行总结；比如，你的上一次发布名称是 v1.0.1，那么下面的命令可以给出上次发布以来所有提交的总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git shortlog --no-merges master --not v1.0.1</span><br><span class="line">Chris Wanstrath (8):</span><br><span class="line">      Add support for annotated tags to Grit::Tag</span><br><span class="line">      Add packed-refs annotated tag support.</span><br><span class="line">      Add Grit::Commit#to_patch</span><br><span class="line">      Update version and History.txt</span><br><span class="line">      Remove stray `puts`</span><br><span class="line">      Make ls_tree ignore nils</span><br><span class="line"></span><br><span class="line">Tom Preston-Werner (4):</span><br><span class="line">      fix dates in history</span><br><span class="line">      dynamic version method</span><br><span class="line">      Version bump to 1.0.2</span><br><span class="line">      Regenerated gemspec for version 1.0.2</span><br></pre></td></tr></table></figure><p>这份整洁的总结包括了自 v1.0.1 以来的所有提交，并且已经按照作者分好组，你可以通过电子邮件将其直接发送到列表中。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：服务器</title>
      <link href="/2018/06/08/Git%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/06/08/Git%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，你应该已经有办法使用 Git 来完成日常工作。 然而，为了使用 Git 协作功能，你还需要有远程的 Git 仓库。 尽管在技术上你可以从个人仓库进行推送（push）和拉取（pull）来修改内容，但不鼓励使用这种方法，因为一不留心就很容易弄混其他人的进度。 此外，你希望你的合作者们即使在你的电脑未联机时亦能存取仓库 — 拥有一个更可靠的公用仓库十分有用。 因此，与他人合作的最佳方法即是建立一个你与合作者们都有权利访问，且可从那里推送和拉取资料的共用仓库。</p><a id="more"></a><p>架设一台 Git 服务器并不难。 首先，选择你希望服务器使用的通讯协议。 在本章第一节将介绍可用的协议以及各自优缺点。 下面一节将解释使用那些协议的典型设置及如何在你的服务器上运行。 最后，如果你不介意托管你的代码在其他人的服务器，且不想经历设置与维护自己服务器的麻烦，可以试试我们介绍的几个仓库托管服务。</p><p>如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的帐户然后继续下一章，我们会在那里讨论分散式源码控制环境的林林总总。</p><p>一个远程仓库通常只是一个裸仓库（bare repository）——即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 <code>.git</code> 子目录内容，不包含其他资料。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 在此，我们将会讨论那些协议及哪些情形应该使用（或避免使用）他们。</p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是 本地协议（Local protocol） ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /opt/git/project.git</span><br></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone file:///opt/git/project.git</span><br></pre></td></tr></table></figure><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><p>要增加一个本地版本库到现有的 Git 项目，可以执行如下的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add local_proj /opt/git/project.git</span><br></pre></td></tr></table></figure><p>然后，就可以像在网络上一样从远端版本库推送和拉取更新了。</p><p><strong>优点</strong><br>基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读/写的权限，就可以了， 我们会在 在服务器上搭建 Git 讨论如何导出一个裸版本库。</p><p>这也是快速从别人的工作目录中拉取更新的方法。 如果你和别人一起合作一个项目，他想让你从版本库中拉取更新时，运行类似 <code>git pull /home/john/project</code> 的命令比推送到服务器再取回简单多了。</p><p><strong>缺点</strong><br>这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。</p><p>值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</p><p>最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</p><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><p><strong>智能（Smart） HTTP 协议</strong><br>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>），和你在克隆、推送（如果你有权限）时使用的是一样的。</p><p><strong>哑（Dumb） HTTP 协议</strong><br>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。 下面是设置从 HTTP 访问版本库的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/www/htdocs/</span><br><span class="line">$ git clone --bare /path/to/git_project gitproject.git</span><br><span class="line">$ cd gitproject.git</span><br><span class="line">$ mv hooks/post-update.sample hooks/post-update</span><br><span class="line">$ chmod a+x hooks/post-update</span><br></pre></td></tr></table></figure><p>这样就可以了。 Git 自带的 <code>post-update</code> 挂钩会默认执行合适的命令（<code>git update-server-info</code>），来确保通过 HTTP 的获取和克隆操作正常工作。 这条命令会在你通过 SSH 向版本库推送之后被执行；然后别人就可以通过类似下面的命令来克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://example.com/gitproject.git</span><br></pre></td></tr></table></figure><p>这里我们用了 Apache 里设置了常用的路径 <code>/var/www/htdocs</code>，不过你可以使用任何静态 web 服务器 —— 只需要把裸版本库放到正确的目录下就可以。 Git 的数据是以基本的静态文件形式提供的。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><p><strong>优点</strong><br>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><p><strong>缺点</strong><br>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 凭证存储 如何安全地保存 HTTP 密码。</p><h4 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone ssh://user@server/project.git</span><br></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone user@server:project.git</span><br></pre></td></tr></table></figure><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><p><strong>优势</strong><br>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><p><strong>缺点</strong><br>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><p><strong>优点</strong><br>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><p><strong>缺点</strong><br>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><h3 id="在服务器上搭建-Git"><a href="#在服务器上搭建-Git" class="headerlink" title="在服务器上搭建 Git"></a>在服务器上搭建 Git</h3><p>现在我们将讨论如何在你自己的服务器上搭建 Git 服务来运行这些协议。</p><p>在开始架设 Git 服务器前，需要把现有仓库导出为裸仓库——即一个不包含当前工作目录的仓库。 这通常是很简单的。 为了通过克隆你的仓库来创建一个新的裸仓库，你需要在克隆命令后加上 <code>--bare</code> 选项。 按照惯例，裸仓库目录名以 <code>.git</code> 结尾，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --bare my_project my_project.git</span><br><span class="line">Cloning into bare repository &apos;my_project.git&apos;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure><p>现在，你的 <code>my_project.git</code> 目录中应该有 Git 目录的副本了。</p><p>整体上效果大致相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -Rf my_project/.git my_project.git</span><br></pre></td></tr></table></figure><p>虽然在配置文件中有若干不同，但是对于你的目的来说，这两种方式都是一样的。 它只取出 Git 仓库自身，不要工作目录，然后特别为它单独创建一个目录。</p><h4 id="把裸仓库放到服务器上"><a href="#把裸仓库放到服务器上" class="headerlink" title="把裸仓库放到服务器上"></a>把裸仓库放到服务器上</h4><p>既然你有了裸仓库的副本，剩下要做的就是把裸仓库放到服务器上并设置你的协议。 假设一个域名为 <code>git.example.com</code> 的服务器已经架设好，并可以通过 SSH 连接，你想把所有的 Git 仓库放在 <code>/opt/git</code> 目录下。 假设服务器上存在 <code>/opt/git/</code> 目录，你可以通过以下命令复制你的裸仓库来创建一个新仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r my_project.git user@git.example.com:/opt/git</span><br></pre></td></tr></table></figure><p>此时，其他通过 SSH 连接这台服务器并对 <code>/opt/git</code> 目录拥有可读权限的使用者，通过运行以下命令就可以克隆你的仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone user@git.example.com:/opt/git/my_project.git</span><br></pre></td></tr></table></figure><p>如果一个用户，通过使用 SSH 连接到一个服务器，并且其对 <code>/opt/git/my_project.git</code> 目录拥有可写权限，那么他将自动拥有推送权限。</p><p>如果到该项目目录中运行 <code>git init</code> 命令，并加上 <code>--shared</code> 选项，那么 Git 会自动修改该仓库目录的组权限为可写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@git.example.com</span><br><span class="line">$ cd /opt/git/my_project.git</span><br><span class="line">$ git init --bare --shared</span><br></pre></td></tr></table></figure><p>由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和协作者都有 SSH 访问权的服务器是多么容易。 现在你们已经准备好在同一项目上展开合作了。</p><p>值得注意的是，这的确是架设一个几个人拥有连接权的 Git 服务的全部——只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。 你已经准备好了一切，无需更多。</p><p>下面的几节中，你会了解如何扩展到更复杂的设定。 这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面等等。 然而，请记住这一点，如果只是和几个人在一个私有项目上合作的话，仅仅 是一个 SSH 服务器和裸仓库就足够了。</p><h4 id="小型安装"><a href="#小型安装" class="headerlink" title="小型安装"></a>小型安装</h4><p>如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。 架设 Git 服务最复杂的地方在于用户管理。 如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可安排就会比较困难。</p><h4 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h4><p>如果你有一台所有开发者都可以用 SSH 连接的服务器，架设你的第一个仓库就十分简单了，因为你几乎什么都不用做（正如我们上一节所说的）。 如果你想在你的仓库上设置更复杂的访问控制权限，只要使用服务器操作系统的普通的文件系统权限就行了。</p><p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。 我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。</p><p>有几个方法可以使你给团队每个成员提供访问权。 第一个就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。 或许你不会想要为每个人运行一次 <code>adduser</code> 并且设置临时密码。</p><p>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的 <code>~/.ssh/authorized_keys</code> 文件。 这样一来，所有人都将通过 git 账户访问主机。 这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。</p><p>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。 只要每个用户可以获得主机的 shell 访问权限，任何 SSH 授权机制你都可视为是有效的。</p><h3 id="生成-SSH-公钥"><a href="#生成-SSH-公钥" class="headerlink" title="生成 SSH 公钥"></a>生成 SSH 公钥</h3><p>如前所述，许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code>~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure><p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。在 Linux/Mac 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/schacon/.ssh/id_rsa):</span><br><span class="line">Created directory &apos;/home/schacon/.ssh&apos;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</span><br></pre></td></tr></table></figure><p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。</p><p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure><p>关于在多种操作系统中生成 SSH 密钥的更深入教程，请参阅 GitHub 的 SSH 密钥指南 <a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">https://help.github.com/articles/generating-ssh-keys</a>。</p><h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>我们来看看如何配置服务器端的 SSH 访问。 本例中，我们将使用 <code>authorized_keys</code> 方法来对用户进行认证。 同时我们假设你使用的操作系统是标准的 Linux 发行版，比如 Ubuntu。 首先，创建一个操作系统用户 <code>git</code>，并为其建立一个 <code>.ssh</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br><span class="line">$ su git</span><br><span class="line">$ cd</span><br><span class="line">$ mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>接着，我们需要为系统用户 <code>git</code> 的 <code>authorized_keys</code> 文件添加一些开发者 SSH 公钥。 假设我们已经获得了若干受信任的公钥，并将它们保存在临时文件中。 与前文类似，这些公钥看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/id_rsa.john.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L</span><br><span class="line">ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k</span><br><span class="line">Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez</span><br><span class="line">Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv</span><br><span class="line">O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq</span><br><span class="line">dAv8JggJICUvax2T9va5 gsg-keypair</span><br></pre></td></tr></table></figure><p>将这些公钥加入系统用户 <code>git</code> 的 <code>.ssh</code> 目录下 <code>authorized_keys</code> 文件的末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>现在我们来为开发者新建一个空仓库。可以借助带 <code>--bare</code> 选项的 <code>git init</code> 命令来做到这一点，该命令在初始化仓库时不会创建工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /opt/git</span><br><span class="line">$ mkdir project.git</span><br><span class="line">$ cd project.git</span><br><span class="line">$ git init --bare</span><br><span class="line">Initialized empty Git repository in /opt/git/project.git/</span><br></pre></td></tr></table></figure><p>接着，John、Josie 或者 Jessica 中的任意一人可以将他们项目的最初版本推送到这个仓库中，他只需将此仓库设置为项目的远程仓库并向其推送分支。 请注意，每添加一个新项目，都需要有人登录服务器取得 shell，并创建一个裸仓库。 我们假定这个设置了 <code>git</code> 用户和 Git 仓库的服务器使用 <code>gitserver</code> 作为主机名。 同时，假设该服务器运行在内网，并且你已在 DNS 配置中将 <code>gitserver</code> 指向此服务器。那么我们可以运行如下命令（假定 <code>myproject</code> 是已有项目且其中已包含文件）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># on John&apos;s computer</span><br><span class="line">$ cd myproject</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git remote add origin git@gitserver:/opt/git/project.git</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>此时，其他开发者可以克隆此仓库，并推回各自的改动，步骤很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@gitserver:/opt/git/project.git</span><br><span class="line">$ cd project</span><br><span class="line">$ vim README</span><br><span class="line">$ git commit -am &apos;fix for the README file&apos;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>通过这种方法，你可以快速搭建一个具有读写权限、面向多个开发者的 Git 服务器。</p><p>需要注意的是，目前所有（获得授权的）开发者用户都能以系统用户 <code>git</code> 的身份登录服务器从而获得一个普通 shell。 如果你想对此加以限制，则需要修改 <code>passwd</code> 文件中（<code>git</code> 用户所对应）的 shell 值。</p><p>借助一个名为 <code>git-shell</code> 的受限 shell 工具，你可以方便地将用户 <code>git</code> 的活动限制在与 Git 相关的范围内。该工具随 Git 软件包一同提供。 如果将 <code>git-shell</code> 设置为用户 <code>git</code> 的登录 shell（login shell），那么用户 <code>git</code> 便不能获得此服务器的普通 shell 访问权限。 若要使用 <code>git-shell</code>，需要用它替换掉 bash 或 csh，使其成为系统用户的登录 shell。 为进行上述操作，首先你必须确保 <code>git-shell</code> 已存在于 <code>/etc/shells</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells   # see if `git-shell` is already in there.  If not...</span><br><span class="line">$ which git-shell   # make sure git-shell is installed on your system.</span><br><span class="line">$ sudo vim /etc/shells  # and add the path to git-shell from last command</span><br></pre></td></tr></table></figure><p>现在你可以使用 <code>chsh &lt;username&gt;</code> 命令修改任一系统用户的 shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chsh git  # and enter the path to git-shell, usually: /usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>这样，用户 <code>git</code> 就只能利用 SSH 连接对 Git 仓库进行推送和拉取操作，而不能登录机器并取得普通 shell。 如果试图登录，你会发现尝试被拒绝，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@gitserver</span><br><span class="line">fatal: Interactive git shell is not enabled.</span><br><span class="line">hint: ~/git-shell-commands should exist and have read and execute access.</span><br><span class="line">Connection to gitserver closed.</span><br></pre></td></tr></table></figure><p>现在，网络相关的 Git 命令依然能够正常工作，但是开发者用户已经无法得到一个普通 shell 了。 正如输出信息所提示的，你也可以在 <code>git</code> 用户的家目录下建立一个目录，来对 <code>git-shell</code> 命令进行一定程度的自定义。 比如，你可以限制掉某些本应被服务器接受的 Git 命令，或者对刚才的 SSH 拒绝登录信息进行自定义，这样，当有开发者用户以类似方式尝试登录时，便会看到你的信息。 要了解更多有关自定义 shell 的信息，请运行 <code>git help shell</code>。</p><h3 id="Git-守护进程"><a href="#Git-守护进程" class="headerlink" title="Git 守护进程"></a>Git 守护进程</h3><p>接下来我们将通过 “Git” 协议建立一个基于守护进程的仓库。 对于快速且无需授权的 Git 数据访问，这是一个理想之选。 请注意，因为其不包含授权服务，任何通过该协议管理的内容将在其网络上公开。</p><p>如果运行在防火墙之外的服务器上，它应该只对那些公开的只读项目服务。 如果运行在防火墙之内的服务器上，它可用于支撑大量参与人员或自动系统（用于持续集成或编译的主机）只读访问的项目，这样可以省去逐一配置 SSH 公钥的麻烦。</p><p>无论何时，该 Git 协议都是相对容易设定的。 通常，你只需要以守护进程的形式运行该命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</span><br></pre></td></tr></table></figure><p><code>--reuseaddr</code> 允许服务器在无需等待旧连接超时的情况下重启，<code>--base-path</code> 选项允许用户在未完全指定路径的条件下克隆项目，结尾的路径将告诉 Git 守护进程从何处寻找仓库来导出。 如果有防火墙正在运行，你需要开放端口 9418 的通信权限。</p><p>你可以通过许多方式将该进程以守护进程的方式运行，这主要取决于你所使用的操作系统。 在一台 Ubuntu 机器上，你可以使用一份 Upstart 脚本。 因此，找到如下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/event.d/local-git-daemon</span><br></pre></td></tr></table></figure><p>并添加下列脚本内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start on startup</span><br><span class="line">stop on shutdown</span><br><span class="line">exec /usr/bin/git daemon \</span><br><span class="line">    --user=git --group=git \</span><br><span class="line">    --reuseaddr \</span><br><span class="line">    --base-path=/opt/git/ \</span><br><span class="line">    /opt/git/</span><br><span class="line">respawn</span><br></pre></td></tr></table></figure><p>出于安全考虑，强烈建议使用一个对仓库拥有只读权限的用户身份来运行该守护进程——你可以创建一个新用户 git-ro 并且以该用户身份来运行守护进程。 为简便起见，我们将像 <code>git-shell</code> 一样，同样使用 git 用户来运行它。</p><p>当你重启机器时，你的 Git 守护进程将会自动启动，并且如果进程被意外结束它会自动重新运行。 为了在不重启的情况下直接运行，你可以运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initctl start local-git-daemon</span><br></pre></td></tr></table></figure><p>在其他系统中，你可以使用 <code>sysvinit</code> 系统中的 <code>xinetd</code> 脚本，或者另外的方式来实现——只要你能够将其命令守护进程化并实现监控。</p><p>接下来，你需要告诉 Git 哪些仓库允许基于服务器的无授权访问。 你可以在每个仓库下创建一个名为 <code>git-daemon-export-ok</code> 的文件来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /path/to/project.git</span><br><span class="line">$ touch git-daemon-export-ok</span><br></pre></td></tr></table></figure><p>该文件将允许 Git 提供无需授权的项目访问服务。</p><h3 id="Smart-HTTP"><a href="#Smart-HTTP" class="headerlink" title="Smart HTTP"></a>Smart HTTP</h3><p>我们一般通过 SSH 进行授权访问，通过 <code>git://</code> 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置 Smart HTTP 一般只需要在服务器上启用一个 Git 自带的名为 <code>git-http-backend</code> 的 CGI 脚本。 该 CGI 脚本将会读取由 <code>git fetch</code> 或 <code>git push</code> 命令向 HTTP URL 发送的请求路径和头部信息，来判断该客户端是否支持 HTTP 通信（不低于 1.6.6 版本的客户端支持此特性）。 如果 CGI 发现该客户端支持智能（Smart）模式，它将会以智能模式与它进行通信，否则它将会回落到哑（Dumb）模式下（因此它可以对某些老的客户端实现向下兼容）。</p><p>在完成以上简单的安装步骤后， 我们将用 Apache 来作为 CGI 服务器。 如果你没有安装 Apache，你可以在 Linux 环境下执行如下或类似的命令来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install apache2 apache2-utils</span><br><span class="line">$ a2enmod cgi alias env</span><br></pre></td></tr></table></figure><p>该操作将会启用 <code>mod_cgi</code>， <code>mod_alias</code>， 和 <code>mod_env</code> 等 Apache 模块， 这些模块都是使该功能正常工作所必须的。</p><p>接下来我们要向 Apache 配置文件添加一些内容，来让 <code>git-http-backend</code> 作为 Web 服务器对 <code>/git</code> 路径请求的处理器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SetEnv GIT_PROJECT_ROOT /opt/git</span><br><span class="line">SetEnv GIT_HTTP_EXPORT_ALL</span><br><span class="line">ScriptAlias /git/ /usr/lib/git-core/git-http-backend/</span><br></pre></td></tr></table></figure><p>如果留空 <code>GIT_HTTP_EXPORT_ALL</code> 这个环境变量，Git 将只对无授权客户端提供带 <code>git-daemon-export-ok</code> 文件的版本库，就像 Git 守护进程一样。</p><p>接着你需要让 Apache 接受通过该路径的请求，添加如下的内容至 Apache 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/usr/lib/git-core*&quot;&gt;</span><br><span class="line">   Options ExecCGI Indexes</span><br><span class="line">   Order allow,deny</span><br><span class="line">   Allow from all</span><br><span class="line">   Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>最后，如果想实现写操作授权验证，使用如下的未授权屏蔽配置即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;LocationMatch &quot;^/git/.*/git-receive-pack$&quot;&gt;</span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthName &quot;Git Access&quot;</span><br><span class="line">    AuthUserFile /opt/git/.htpasswd</span><br><span class="line">    Require valid-user</span><br><span class="line">&lt;/LocationMatch&gt;</span><br></pre></td></tr></table></figure><p>这需要你创建一个包含所有合法用户密码的 <code>.htaccess</code> 文件。 以下是一个添加 “schacon” 用户到此文件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ htdigest -c /opt/git/.htpasswd &quot;Git Access&quot; schacon</span><br></pre></td></tr></table></figure><p>你可以通过许多方式添加 Apache 授权用户，选择使用其中一种方式即可。 以上仅仅只是我们可以找到的最简单的一个例子。 如果愿意的话，你也可以通过 SSL 运行它，以保证所有数据是在加密状态下进行传输的。</p><p>我们不想深入去讲解 Apache 配置文件，因为你可能会使用不同的 Web 服务器，或者可能有不同的授权需求。 它的主要原理是使用一个 Git 附带的，名为 <code>git-http-backend</code> 的 CGI。它被引用来处理协商通过 HTTP 发送和接收的数据。 它本身并不包含任何授权功能，但是授权功能可以在 Web 服务器层引用它时被轻松实现。 你可以在任何所有可以处理 CGI 的 Web 服务器上办到这点，所以随便挑一个你最熟悉的 Web 服务器试手吧。</p><h3 id="GitWeb"><a href="#GitWeb" class="headerlink" title="GitWeb"></a>GitWeb</h3><p>如果你对项目有读写权限或只读权限，你可能需要建立起一个基于网页的简易查看器。 Git 提供了一个叫做 GitWeb 的 CGI 脚本来做这项工作。</p><p>如果你想要查看 GitWeb 如何展示你的项目，并且在服务器上安装了轻量级网络服务器比如 <code>lighttpd</code> 或 <code>webrick</code>， Git 提供了一个命令来让你启动一个临时的服务器。 在 Linux 系统的电脑上，<code>lighttpd</code> 通常已经安装了，所以你只需要在项目目录里执行 <code>git instaweb</code> 命令即可。 如果你使用 Mac 系统， Mac OS X Leopard 系统已经预安装了 Ruby，所以 <code>webrick</code> 或许是你最好的选择。 如果不想使用 <code>lighttpd</code> 启动 <code>instaweb</code> 命令，你需要在执行时加入 <code>--httpd</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git instaweb --httpd=webrick</span><br><span class="line">[2009-02-21 10:02:21] INFO  WEBrick 1.3.1</span><br><span class="line">[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</span><br></pre></td></tr></table></figure><p>这个命令启动了一个监听 1234 端口的 HTTP 服务器，并且自动打开了浏览器。 这对你来说十分方便。 当你已经完成了工作并想关闭这个服务器，你可以执行同一个命令，并加上 <code>--stop</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git instaweb --httpd=webrick --stop</span><br></pre></td></tr></table></figure><p>如果你现在想为你的团队或你托管的开源项目持续的运行这个页面，你需要通过普通的 Web 服务器来设置 CGI 脚本。 一些 Linux 发行版的软件库有 <code>gitweb</code> 包，可以通过 <code>apt</code> 或 <code>yum</code> 来安装，你可以先试试。 接下来我们来快速的了解一下如何手动安装 GitWeb。 首先，你需要获得 Git 的源代码，它包含了 GitWeb ，并可以生成自定义的 CGI 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://git.kernel.org/pub/scm/git/git.git</span><br><span class="line">$ cd git/</span><br><span class="line">$ make GITWEB_PROJECTROOT=&quot;/opt/git&quot; prefix=/usr gitweb</span><br><span class="line">    SUBDIR gitweb</span><br><span class="line">    SUBDIR ../</span><br><span class="line">make[2]: `GIT-VERSION-FILE&apos; is up to date.</span><br><span class="line">    GEN gitweb.cgi</span><br><span class="line">    GEN static/gitweb.js</span><br><span class="line">$ sudo cp -Rf gitweb /var/www/</span><br></pre></td></tr></table></figure><p>需要注意的是，你需要在命令中指定 <code>GITWEB_PROJECTROOT</code> 变量来让程序知道你的 Git 版本库的位置。 现在，你需要在 Apache 中使用这个 CGI 脚本，你需要为此添加一个虚拟主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName gitserver</span><br><span class="line">    DocumentRoot /var/www/gitweb</span><br><span class="line">    &lt;Directory /var/www/gitweb&gt;</span><br><span class="line">        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch</span><br><span class="line">        AllowOverride All</span><br><span class="line">        order allow,deny</span><br><span class="line">        Allow from all</span><br><span class="line">        AddHandler cgi-script cgi</span><br><span class="line">        DirectoryIndex gitweb.cgi</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>再次提醒，GitWeb 可以通过任何一个支持 CGI 或 Perl 的网络服务器架设；如果你需要的话，架设起来应该不会很困难。 现在，你可以访问 <code>http://gitserver/</code> 在线查看你的版本库。</p><h3 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h3><p>虽然 GitWeb 相当简单。 但如果你正在寻找一个更现代，功能更全的 Git 服务器，这里有几个开源的解决方案可供你选择安装。 因为 GitLab 是其中最出名的一个，我们将它作为示例并讨论它的安装和使用。 这比 GitWeb 要复杂的多并且需要更多的维护，但它的确是一个功能更全的选择。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>GitLab 是一个数据库支持的 web 应用，所以相比于其他 git 服务器，它的安装过程涉及到更多的东西。 幸运的是，这个过程有非常详细的文档说明和支持。</p><p>这里有一些可参考的方法帮你安装 GitLab 。 为了更快速的启动和运行，你可以下载虚拟机镜像或者在 <a href="https://bitnami.com/stack/gitlab" target="_blank" rel="noopener">https://bitnami.com/stack/gitlab</a> 上获取一键安装包，同时调整配置使之符合你特定的环境。 Bitnami 的一个优点在于它的登录界面（通过 alt-&amp;rarr 键进入）；它会告诉你安装好的 GitLab 的 IP 地址以及默认的用户名和密码。</p><p><img src="git-chapter-8/img1.png" alt></p><p>无论如何，跟着 GitLab 社区版的 readme 文件一步步来，你可以在这里找到它 <a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-ce/tree/master</a> 。 在这里你将会在主菜单中找到安装 GitLab 的帮助，一个可以在 Digital Ocean 上运行的虚拟机，以及 RPM 和 DEB 包（都是测试版）。 这里还有 “非官方” 的引导让 GitLab 运行在非标准的操作系统和数据库上，一个全手动的安装脚本，以及许多其他的话题。</p><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>GitLab 的管理界面是通过网络进入的。 将你的浏览器转到已经安装 GitLab 的 主机名或 IP 地址，然后以管理员身份登录即可。 默认的用户名是 <code>admin@local.host</code>，默认的密码是 <code>5iveL!fe</code>（你会得到类似 请登录后尽快更换密码 的提示）。 登录后，点击主栏上方靠右位置的 “Admin area” 图标进行管理。</p><p><img src="git-chapter-8/img2.png" alt></p><p><strong>使用者</strong><br>GitLab 上的用户指的是对应协作者的帐号。 用户帐号没有很多复杂的地方，主要是包含登录数据的用户信息集合。 每一个用户账号都有一个 命名空间 ，即该用户项目的逻辑集合。 如果一个叫 <code>jane</code> 的用户拥有一个名称是 <code>project</code> 的项目，那么这个项目的 url 会是 <a href="http://server/jane/project" target="_blank" rel="noopener">http://server/jane/project</a> 。</p><p><img src="git-chapter-8/img3.png" alt></p><p>移除一个用户有两种方法。 “屏蔽（Blocking）” 一个用户阻止他登录 GitLab 实例，但是该用户命名空间下的所有数据仍然会被保存，并且仍可以通过该用户提交对应的登录邮箱链接回他的个人信息页。</p><p>而另一方面，“销毁（Destroying）” 一个用户，会彻底的将他从数据库和文件系统中移除。 他命名空间下的所有项目和数据都会被删除，拥有的任何组也会被移除。 这显然是一个更永久且更具破坏力的行为，所以很少用到这种方法。</p><p><strong>组</strong><br>一个 GitLab 的组是一些项目的集合，连同关于多少用户可以访问这些项目的数据。 每一个组都有一个项目命名空间（与用户一样），所以如果一个叫 <code>training</code> 的组拥有一个名称是 <code>materials</code> 的项目，那么这个项目的 url 会是 <a href="http://server/training/materials" target="_blank" rel="noopener">http://server/training/materials</a> 。</p><p><img src="git-chapter-8/img4.png" alt></p><p>每一个组都有许多用户与之关联，每一个用户对组中的项目以及组本身的权限都有级别区分。 权限的范围从 “访客”（仅能提问题和讨论） 到 “拥有者”（完全控制组、成员和项目）。 权限的种类太多以至于难以在这里一一列举，不过在 GitLab 的管理界面上有帮助链接。</p><p><strong>项目</strong><br>一个 GitLab 的项目相当于 git 的版本库。 每一个项目都属于一个用户或者一个组的单个命名空间。 如果这个项目属于一个用户，那么这个拥有者对所有可以获取这个项目的人拥有直接管理权；如果这个项目属于一个组，那么该组中用户级别的权限也会起作用。</p><p>每一个项目都有一个可视级别，控制着谁可以看到这个项目页面和仓库。 如果一个项目是 私有 的，这个项目的拥有者必须明确授权从而使特定的用户可以访问。 一个 内部 的项目可以被所有登录的人看到，而一个 公开 的项目则是对所有人可见的。 注意，这种控制既包括 git “fetch” 的使用也包括对项目 web 用户界面的访问。</p><p><strong>钩子</strong><br>GitLab 在项目和系统级别上都支持钩子程序。 对任意级别，当有相关事件发生时，GitLab 的服务器会执行一个包含描述性 JSON 数据的 HTTP 请求。 这是自动化连接你的 git 版本库和 GitLab 实例到其他的开发工具，比如 CI 服务器，聊天室，或者部署工具的一个极好方法。</p><h4 id="基本用途"><a href="#基本用途" class="headerlink" title="基本用途"></a>基本用途</h4><p>你想要在 GitLab 做的第一件事就是建立一个新项目。 这通过点击工具栏上的 “+” 图标完成。 你会被要求填写项目名称，也就是这个项目所属的命名空间，以及它的可视层级。 绝大多数的设定并不是永久的，可以通过设置界面重新调整。 点击 “Create Project”，你就完成了。</p><p>项目存在后，你可能会想将它与本地的 Git 版本库连接。 每一个项目都可以通过 HTTPS 或者 SSH 连接，任意两者都可以被用来配置远程 Git。 在项目主页的顶栏可以看到这个项目的 URLs。 对于一个存在的本地版本库，这个命令将会向主机位置添加一个叫 <code>gitlab</code> 的远程仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add gitlab https://server/namespace/project.git</span><br></pre></td></tr></table></figure><p>如果你的本地没有版本库的副本，你可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://server/namespace/project.git</span><br></pre></td></tr></table></figure><p>web 用户界面提供了几个有用的获取版本库信息的网页。 每一个项目的主页都显示了最近的活动，并且通过顶部的链接可以使你浏览项目文件以及提交日志。</p><h4 id="一起工作"><a href="#一起工作" class="headerlink" title="一起工作"></a>一起工作</h4><p>在一个 GitLab 项目上一起工作的最简单方法就是赋予协作者对 git 版本库的直接 push 权限。 你可以通过项目设定的 “Members（成员）” 部分向一个项目添加写作者，并且将这个新的协作者与一个访问级别关联（不同的访问级别在 组 中已简单讨论）。 通过赋予一个协作者 “Developer（开发者）” 或者更高的访问级别，这个用户就可以毫无约束地直接向版本库或者向分支进行提交。</p><p>另外一个让合作更解耦的方法就是使用合并请求。 它的优点在于让任何能够看到这个项目的协作者在被管控的情况下对这个项目作出贡献。 可以直接访问的协作者能够简单的创建一个分支，向这个分支进行提交，也可以开启一个向 <code>master</code> 或者其他任何一个分支的合并请求。 对版本库没有推送权限的协作者则可以 “fork” 这个版本库（即创建属于自己的这个库的副本），向 那个 副本进行提交，然后从那个副本开启一个到主项目的合并请求。 这个模型使得项目拥有者完全控制着向版本库的提交，以及什么时候允许加入陌生协作者的贡献。</p><p>在 GitLab 中合并请求和问题是一个长久讨论的主要部分。 每一个合并请求都允许在提出改变的行进行讨论（它支持一个轻量级的代码审查），也允许对一个总体性话题进行讨论。 两者都可以被分配给用户，或者组织到 milestones（里程碑） 界面。</p><p>这个部分主要聚焦于在 GitLab 中与 Git 相关的特性，但是 GitLab 作为一个成熟的系统，它提供了许多其他产品来帮助你协同工作，例如项目 wiki 与系统维护工具。 GitLab 的一个优点在于，服务器设置和运行以后，你将很少需要调整配置文件或通过 SSH 连接服务器；绝大多数的管理和日常使用都可以在浏览器界面中完成。</p><h3 id="第三方托管的选择"><a href="#第三方托管的选择" class="headerlink" title="第三方托管的选择"></a>第三方托管的选择</h3><p>如果不想设立自己的 Git 服务器，你可以选择将你的 Git 项目托管到一个外部专业的托管网站。 这带来了一些好处：一个托管网站可以用来快速建立并开始项目，且无需进行服务器维护和监控工作。 即使你在内部设立并且运行了自己的服务器，你仍然可以把你的开源代码托管在公共托管网站——这通常更有助于开源社区来发现和帮助你。</p><p>现在，有非常多的托管供你选择，每个选择都有不同的优缺点。 欲查看最新列表，请浏览 Git 维基的 GitHosting 页面 <a href="https://git.wiki.kernel.org/index.php/GitHosting" target="_blank" rel="noopener">https://git.wiki.kernel.org/index.php/GitHosting</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：分支</title>
      <link href="/2018/06/07/Git%EF%BC%9A%E5%88%86%E6%94%AF/"/>
      <url>/2018/06/07/Git%EF%BC%9A%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p><p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p><a id="more"></a><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。</p><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &apos;The initial commit of my project&apos;</span><br></pre></td></tr></table></figure><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><img src="git-chapter-1/img1.png" alt></p><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p><img src="git-chapter-1/img2.png" alt></p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p><p><img src="git-chapter-1/img3.png" alt></p><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p>这会在当前所在的提交对象上创建一个指针。</p><p><img src="git-chapter-1/img4.png" alt></p><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。</p><p><img src="git-chapter-1/img5.png" alt></p><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="git-chapter-1/img6.png" alt></p><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made a change&apos;</span><br></pre></td></tr></table></figure><p><img src="git-chapter-1/img7.png" alt></p><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p><img src="git-chapter-1/img8.png" alt></p><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made other changes&apos;</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="git-chapter-1/img9.png" alt></p><p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p><p>接下来，让我们看看你为什么应该这样做。</p><h3 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li><p>开发某个网站。</p></li><li><p>为实现某个新的需求，创建一个分支。</p></li><li><p>在这个分支上开展工作。</p></li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li><p>切换到你的线上分支（production branch）。</p></li><li><p>为这个紧急任务新建一个分支，并在其中修复它。</p></li><li><p>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</p></li><li><p>切换回你最初工作的分支上，继续工作。</p></li></ol><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p><img src="git-chapter-2/img1.png" alt></p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="git-chapter-2/img2.png" alt></p><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;added a new footer [issue 53]&apos;</span><br></pre></td></tr></table></figure><p><img src="git-chapter-2/img3.png" alt></p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch &apos;hotfix&apos;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;fixed the broken email address&apos;</span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p><img src="git-chapter-2/img4.png" alt></p><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="git-chapter-2/img5.png" alt></p><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;finished the new footer [issue 53]&apos;</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="git-chapter-2/img6.png" alt></p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h4 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h4><p>假设你已经修正了 <code>#53</code> 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge iss53</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="git-chapter-2/img7.png" alt></p><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="git-chapter-2/img8.png" alt></p><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d iss53</span><br></pre></td></tr></table></figure><h4 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 <code>merge</code> 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because &apos;merge.tool&apos; is not configured.</span><br><span class="line">See &apos;git mergetool --tool-help&apos; or &apos;git help config&apos; for more details.</span><br><span class="line">&apos;git mergetool&apos; will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &apos;index.html&apos;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure><p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code> 做为默认的合并工具，因为作者在 Mac 上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &apos;iss53&apos;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#.git/MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># All conflicts fixed but you are still merging.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   index.html</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &apos;iss53&apos;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch &apos;testing&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D testing&apos;.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="git-chapter-3/img1.png" alt></p><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="git-chapter-3/img2.png" alt></p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h4 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h4><p>特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（<code>context-switch</code>）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="git-chapter-3/img3.png" alt></p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="git-chapter-3/img4.png" alt></p><p>我们将会在 <a href="http://pengzhenjin.top/2018/06/09/Git：分布式">分布式 Git</a> 中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。</p><p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote (remote)</code> 来显式地获得远程引用的完整列表，或者通过 <code>git remote show (remote)</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p><p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p><p>它们以 <code>(remote)/(branch)</code> 形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p><p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据，创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 <code>origin</code> 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><p><img src="git-chapter-4/img1.png" alt></p><p>如果你在本地的 <code>master</code> 分支做了一些工作，与此同时，其他人推送提交到 <code>git.ourcompany.com</code> 并更新了它的 <code>master</code> 分支，那么你的提交历史将向不同的方向前进。 另外，只要你不与 <code>origin</code> 服务器连接，你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="git-chapter-4/img2.png" alt></p><p>如果要同步你的工作，运行 <code>git fetch origin</code> 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针指向新的、更新后的位置。</p><p><img src="git-chapter-4/img3.png" alt></p><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a href="http://pengzhenjin.top/2018/06/06/Git：基础">Git 基础</a> 中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为整个 URL 的缩写。</p><p><img src="git-chapter-4/img4.png" alt></p><p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p><p><img src="git-chapter-4/img5.png" alt></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push (remote) (branch)</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 <code>serverfix</code> 分支来更新远程仓库上的 <code>serverfix</code> 分支。” 我们将会详细学习 <a href="http://pengzhenjin.top/2018/06/12/Git：内部原理">Git 内部原理</a> 的 <code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行 <code>git push origin serverfix:serverfix</code>，它会做同样的事——也就是说“推送本地的 <code>serverfix</code> 分支，将其作为远程仓库的 <code>serverfix</code> 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;sf&apos;</span><br></pre></td></tr></table></figure><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：<code>$ git fetch --all; git branch -vv</code></p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h4 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h4><p>请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><p><img src="git-chapter-5/img1.png" alt></p><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="git-chapter-5/img2.png" alt></p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 变基。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p><p><img src="git-chapter-5/img3.png" alt></p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure><p><img src="git-chapter-5/img4.png" alt></p><p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h4 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h4><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个特性分支里再分出一个特性分支的提交历史 中的例子那样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="git-chapter-5/img5.png" alt></p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p><p><img src="git-chapter-5/img6.png" alt></p><p>现在可以快进合并 <code>master</code> 分支了。（如下图 快进合并 master 分支，使之包含来自 client 分支的修改）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge client</span><br></pre></td></tr></table></figure><p><img src="git-chapter-5/img7.png" alt></p><p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure><p>如下图 将 server 中的修改变基到 master 上 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p><p><img src="git-chapter-5/img8.png" alt></p><p>然后就可以快进合并主分支 <code>master</code> 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge server</span><br></pre></td></tr></table></figure><p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成下图 最终的提交历史 中的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d client</span><br><span class="line">$ git branch -d server</span><br></pre></td></tr></table></figure><p><img src="git-chapter-5/img9.png" alt></p><h4 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h4><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="git-chapter-5/img10.png" alt></p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="git-chapter-5/img11.png" alt></p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="git-chapter-5/img12.png" alt></p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="git-chapter-5/img13.png" alt></p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h4 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h4><p>如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p><ul><li><p>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</p></li><li><p>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</p></li><li><p>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</p></li><li><p>把查到的这些提交应用在 <code>teamone/master</code> 上面</p></li></ul><p>从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如下图 在一个被变基然后强制推送的分支上再次执行变基 所示。</p><p><img src="git-chapter-5/img14.png" alt></p><p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h4 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h4><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：基础</title>
      <link href="/2018/06/06/Git%EF%BC%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/06/06/Git%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>在你开始使用 Git 前，需要将它安装在你的计算机上。 即便已经安装，最好将它升级到最新的版本。 你可以通过软件包或者其它安装程序来安装，或者下载源码编译安装。</p><h4 id="在-Linux-上安装"><a href="#在-Linux-上安装" class="headerlink" title="在 Linux 上安装"></a>在 Linux 上安装</h4><p>如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果以 Fedora 上为例，你可以使用 yum：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure><p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a href="https://git-scm.com/download/linux" target="_blank" rel="noopener">https://git-scm.com/download/linux</a>。</p><h4 id="在-Mac-上安装"><a href="#在-Mac-上安装" class="headerlink" title="在 Mac 上安装"></a>在 Mac 上安装</h4><p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 git 命令即可。 如果没有安装过命令行开发者工具，将会提示你安装。</p><p>如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="https://git-scm.com/download/mac" target="_blank" rel="noopener">https://git-scm.com/download/mac</a>。</p><p><img src="git-chapter-1/img1.png" alt></p><p>Figure 7. Git OS X 安装程序.<br>你也可以将它作为 GitHub for Mac 的一部分来安装。 它们的图形化 Git 工具有一个安装命令行工具的选项。 你可以从 GitHub for Mac 网站下载该工具，网址为 <a href="http://mac.github.com" target="_blank" rel="noopener">http://mac.github.com</a>。</p><h4 id="在-Windows-上安装"><a href="#在-Windows-上安装" class="headerlink" title="在 Windows 上安装"></a>在 Windows 上安装</h4><p>在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <a href="http://git-scm.com/download/win" target="_blank" rel="noopener">http://git-scm.com/download/win</a>，下载会自动开始。 要注意这是一个名为 Git for Windows 的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <a href="http://gitforwindows.org" target="_blank" rel="noopener">http://gitforwindows.org</a>。</p><p>另一个简单的方法是安装 GitHub for Windows。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 <a href="http://windows.github.com" target="_blank" rel="noopener">http://windows.github.com</a>。</p><h4 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h4><p>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。</p><p>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有 libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">  openssl-devel zlib-devel</span><br><span class="line">$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">  libz-dev libssl-dev</span><br></pre></td></tr></table></figure><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install asciidoc xmlto docbook2x</span><br><span class="line">$ sudo apt-get install asciidoc xmlto docbook2x</span><br></pre></td></tr></table></figure><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href="https://www.kernel.org/pub/software/scm/git" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git</a>，或从 GitHub 网站上的镜像来获得，网址为 <a href="https://github.com/git/git/releases" target="_blank" rel="noopener">https://github.com/git/git/releases</a>。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。</p><p>接着，编译并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxf git-2.0.0.tar.gz</span><br><span class="line">$ cd git-2.0.0</span><br><span class="line">$ make configure</span><br><span class="line">$ ./configure --prefix=/usr</span><br><span class="line">$ make all doc info</span><br><span class="line">$ sudo make install install-doc install-html install-info</span><br></pre></td></tr></table></figure><p>完成后，你可以使用 Git 来获取 Git 的升级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://git.kernel.org/pub/scm/git/git.git</span><br></pre></td></tr></table></figure><h3 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h3><p>既然已经在系统上安装了 Git，你会想要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次，程序升级时会保留配置信息。 你可以在任何时候再次通过运行命令来修改它们。</p><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：      </p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li></ol><p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p><h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。</p><p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p><h4 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h4><p>既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure><h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>例如，要想获得 config 命令的手册，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure><p>这些命令很棒，因为你随时随地可以使用而无需联网。 如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器（ irc.freenode.net ）的 <code>#git</code> 或 <code>#github</code> 频道寻求帮助。 这些频道经常有上百人在线，他们都精通 Git 并且乐于助人。</p><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。</p><h4 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h4><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 (参见 Git <a href="http://pengzhenjin.top/2018/06/12/Git：内部原理">内部原理</a> 来了解更多关于到底 <code>.git</code> 文件夹中包含了哪些文件的信息。)</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 <code>git add</code> 命令来实现对指定文件的跟踪，然后执行 <code>git commit</code> 提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br></pre></td></tr></table></figure><p>稍后我们再逐一解释每一条指令的意思。 现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的 Git 仓库。</p><h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。 如果你对其它的 VCS 系统（比如说 Subversion）很熟悉，请留心一下你所使用的命令是”clone”而不是”checkout”。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在，详见 <a href="http://pengzhenjin.top/2018/06/08/Git：服务器">在服务器上搭建 Git</a> ）。</p><p>克隆仓库的命令格式是 <code>git clone [url]</code>。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 <code>mylibgit</code>。</p><p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。 <a href="http://pengzhenjin.top/2018/06/08/Git：服务器">在服务器上搭建 Git</a> 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。</p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。 接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：<br><img src="git-chapter-5/img1.png" alt><br>Figure 8. 文件的状态变化周期</p><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。 我们在 <a href="http://pengzhenjin.top/2018/06/07/Git：分支">Git 分支</a> 会详细讨论分支和引用。</p><p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;My Project&apos; &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure><p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add (files)</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将”CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vim CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本， 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。 运行 <code>git status -s</code> ，状态报告输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 来看一个实际的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li><p>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</p></li><li><p>可以使用标准的 glob 模式匹配。</p></li><li><p>匹配模式可以以（/）开头防止递归。</p></li><li><p>匹配模式可以以（/）结尾指定目录。</p></li><li><p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p></li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号 (*)匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号 (*) 表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或 a/b/c/z 等。</p><p>我们再看一个 .gitignore 文件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># no .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in the build/ directory</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>如果 <code>git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 稍后我们会详细介绍 <code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ 尽管 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code> 将通过文件补丁的格式显示具体哪些行发生了改变。</p><p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&apos;re contributing</span><br><span class="line"> in the first place, you&apos;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&apos;s</span><br></pre></td></tr></table></figure><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..03902a1</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+My Project</span><br></pre></td></tr></table></figure><p>请注意，<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p><p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本。 如果我们的环境（终端输出）看起来如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ echo &apos;# test line&apos; &gt;&gt; CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>现在运行 <code>git diff</code> 看暂存前后的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 643e24f..87f08c8 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -119,3 +119,4 @@ at the</span><br><span class="line"> ## Starter Projects</span><br><span class="line"></span><br><span class="line"> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).</span><br><span class="line">+# test line</span><br></pre></td></tr></table></figure><p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：（<code>--staged</code> 和 <code>--cached</code> 是同义词）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&apos;re contributing</span><br><span class="line"> in the first place, you&apos;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&apos;s</span><br></pre></td></tr></table></figure><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。</p><p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#new file:   README</span><br><span class="line">#modified:   CONTRIBUTING.md</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 （如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code> 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p><p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;</span><br><span class="line">[master 463dc4f] Story 182: Fix benchmarks for speed</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">$ git commit -a -m &apos;added new benchmarks&apos;</span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line"> 1 file changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>看到了吗？提交之前不再需要 <code>git add</code> 文件“CONTRIBUTING.md”了。</p><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm &apos;PROJECTS.md&apos;</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></table></figure><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm \*~</span><br></pre></td></tr></table></figure><p>该命令为删除以 <code>~</code> 结尾的所有文件。</p><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p><p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code> 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p>接下来的例子会用我专门用于演示的 simplegit 项目， 运行下面的命令获取该项目源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure><p>然后在此项目中运行 <code>git log</code>，应该会看到下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。</p><p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。 你也可以加上 <code>-2</code> 来仅显示最近两次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p -2</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gee-mail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如说，如果你想看到每次提交的简略的统计信息，你可以使用 <code>--stat</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure><p>正如你所看到的，<code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure><p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure><p><code>git log --pretty=format</code> 常用的选项 列出了常用的格式占位符写法及其代表的意义。</p><div class="note default">            <p><code>git log --pretty=format</code> 常用的选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者（committer）的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table>          </div><p>你一定奇怪 作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 <a href="http://pengzhenjin.top/2018/06/09/Git：分布式">分布式 Git</a> 再详细介绍两者之间的细微差别。</p><p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h %s&quot; --graph</span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method for getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support for heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time for xmlschema</span><br><span class="line">*  11d191e Merge branch &apos;defunkt&apos; into local</span><br></pre></td></tr></table></figure><p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p><p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <code>git log</code> 的常用选项 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p><div class="note default">            <p><code>git log</code> 的常用选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>按补丁格式显示每个更新之间的差异</td></tr><tr><td>–stat</td><td>显示每次更新的文件修改统计信息</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数修改添加移除统计</td></tr><tr><td>–name-only</td><td>仅在提交信息后显示已修改的文件清单</td></tr><tr><td>–name-status</td><td>显示新增、修改、删除的文件清单</td></tr><tr><td>–abbrev-commit</td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符</td></tr><tr><td>–relative-date</td><td>使用较短的相对时间显示（比如，“2 weeks ago”）</td></tr><tr><td>–graph</td><td>显示 ASCII 图形表示的分支合并历史</td></tr><tr><td>–pretty</td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）</td></tr></tbody></table>          </div><h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 <code>-2</code> 了，它只显示最近的两条提交， 实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的若干条提交。 不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p><p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和 <code>--until</code> 也很有用。 例如，下面的命令列出所有最近两周内的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --since=2.weeks</span><br></pre></td></tr></table></figure><p>这个命令可以在多种格式下工作，比如说具体的某一天 <code>&quot;2008-01-15&quot;</code>，或者是相对地多久以前 <code>&quot;2 years 1 day 3 minutes ago&quot;</code>。</p><p>还可以给出若干搜索条件，列出符合的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。 （请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 <code>--all-match</code> 选项。否则，满足任意一个条件的提交都会被匹配出来）</p><p>另一个非常有用的筛选选项是 <code>-S</code>，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log -Sfunction_name</span><br></pre></td></tr></table></figure><p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 <code>git log</code> 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p><p>在 限制 <code>git log</code> 输出的选项 中列出了常用的选项</p><div class="note default">            <p>限制 <code>git log</code> 输出的选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-(n)</td><td>仅显示最近的 n 条提交</td></tr><tr><td>–since, –after</td><td>仅显示指定时间之后的提交</td></tr><tr><td>–until, –before</td><td>仅显示指定时间之前的提交</td></tr><tr><td>–author</td><td>仅显示指定作者相关的提交</td></tr><tr><td>–committer</td><td>仅显示指定提交者相关的提交</td></tr><tr><td>–grep</td><td>仅显示含指定关键字的提交</td></tr><tr><td>-S</td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table>          </div><p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \</span><br><span class="line">   --before=&quot;2008-11-01&quot; --no-merges -- t/</span><br><span class="line">5610e3b - Fix testcase failure when extended attributes are in use</span><br><span class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic link HEAD</span><br><span class="line">d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths</span><br><span class="line">51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD</span><br><span class="line">b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</span><br></pre></td></tr></table></figure><p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p><h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD CONTRIBUTING.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MCONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p><p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code> 命令了解的全部。我们将会在 重置揭密 中了解 <code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p><h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>可以看到那些修改已经被撤消了。</p><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="https://pengzhenjin.top/2018/06/07/Git：分支">Git 分支</a> 介绍保存进度与分支；这些通常是更好的做法。</p><p>记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p><h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/schacon/ticgit</span><br><span class="line">Cloning into &apos;ticgit&apos;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">$ cd ticgit</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure><p>这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p><p>注意这些远程仓库使用了不同的协议；我们将会在 <a href="http://pengzhenjin.top/2018/06/08/Git：服务器">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="http://pengzhenjin.top/2018/06/07/Git：分支">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支（阅读 <a href="http://pengzhenjin.top/2018/06/07/Git：分支">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 <a href="http://pengzhenjin.top/2018/06/07/Git：分支">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p><h4 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &apos;git pull&apos;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &apos;git push&apos;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &apos;git remote prune&apos; to remove)</span><br><span class="line">  Local branches configured for &apos;git pull&apos;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &apos;git push&apos;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure><p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p><h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote rm</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure><p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l &apos;v1.8.5*&apos;</span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。</p><p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p><p>通过使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4-lw</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &apos;experiment&apos;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &apos;experiment&apos;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><p>可以看到你已经在那次提交上打上标签了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"></span><br><span class="line">$ git show v1.2</span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin [tagname]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.4-lw</span><br><span class="line">Deleted tag &apos;v1.4-lw&apos; (was e7d5add)</span><br></pre></td></tr></table></figure><p>应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v1.4-lw</span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 2.0.0</span><br><span class="line">Note: checking out &apos;2.0.0&apos;.</span><br><span class="line"></span><br><span class="line">You are in &apos;detached HEAD&apos; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line"></span><br><span class="line">$ git checkout 2.0-beta-0.1</span><br><span class="line">Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line">HEAD is now at df3f601... add atlas.json and cover image</span><br></pre></td></tr></table></figure><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b version2 v2.0.0</span><br><span class="line">Switched to a new branch &apos;version2&apos;</span><br></pre></td></tr></table></figure><p>当然，如果在这之后又进行了一次提交，<code>version2</code> 分支会因为这个改动向前移动，<code>version2</code> 分支就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p><h3 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h3><p>在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p><p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br></pre></td></tr></table></figure><p>这会使下面的两个命令等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD -- fileA</span><br></pre></td></tr></table></figure><p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure><p>这样，可以轻松地看到最后一次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.visual &apos;!gitk&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
