<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>彭真进的博客</title>
  
  <subtitle>业精于勤荒于嬉，行成于思毁于随</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pengzhenjin.top/"/>
  <updated>2019-10-17T07:35:13.684Z</updated>
  <id>http://pengzhenjin.top/</id>
  
  <author>
    <name>彭真进</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站导航</title>
    <link href="http://pengzhenjin.top/2019/08/23/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/"/>
    <id>http://pengzhenjin.top/2019/08/23/网站导航/</id>
    <published>2019-08-22T16:00:00.000Z</published>
    <updated>2019-10-17T07:35:13.684Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在线学习&quot;&gt;&lt;a href=&quot;#在线学习&quot; class=&quot;headerlink&quot; title=&quot;在线学习&quot;&gt;&lt;/a&gt;在线学习&lt;/h3&gt;&lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;&lt;a href=&quot;https://study.163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网易云课堂&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ke.qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯课堂&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://edu.aliyun.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里云大学&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://chuanke.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度传课&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.imooc.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://edu.51cto.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;51CTO学院&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jikexueyuan.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客学院&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.maiziedu.com&quot; title=&quot;麦子学院&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;麦子学院&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.icourse163.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国大学MOOC&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.mooc.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MOOC中国&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.xuetangx.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;学堂在线&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.duobei.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多贝公开课&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://cn.udacity.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;优达学城&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.udemy.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Udemy&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.coursera.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;coursera&lt;/a&gt;                                                               &lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="网站导航" scheme="http://pengzhenjin.top/categories/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/"/>
    
    
      <category term="在线学习" scheme="http://pengzhenjin.top/tags/%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="在线课堂" scheme="http://pengzhenjin.top/tags/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82/"/>
    
  </entry>
  
  <entry>
    <title>Android-Jetpack组件：WorkManager</title>
    <link href="http://pengzhenjin.top/2019/05/25/Android-Jetpack%E7%BB%84%E4%BB%B6%EF%BC%9AWorkManager/"/>
    <id>http://pengzhenjin.top/2019/05/25/Android-Jetpack组件：WorkManager/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-10-14T11:33:13.449Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;官方文档：&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/workmanager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WorkManager&lt;/a&gt;&lt;br&gt;谷歌实验室：&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-workmanager-kt/#0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方教程&lt;/a&gt;&lt;br&gt;官方案例：&lt;a href=&quot;https://github.com/googlecodelabs/android-workmanager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;android-workmanager&lt;/a&gt;&lt;br&gt;WorkManger 介绍视频：&lt;a href=&quot;https://www.bilibili.com/video/av56276889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文官方介绍视频&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;br&gt;WorkManager 是用来执行后台任务的，正如官方介绍：&lt;/p&gt;&lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;WorkManager, a compatible, flexible and simple library for deferrable background work.&lt;br&gt;WorkManger是一个可兼容、灵活和简单的延迟后台任务。&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="Android" scheme="http://pengzhenjin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://pengzhenjin.top/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://pengzhenjin.top/tags/Jetpack/"/>
    
      <category term="WorkManager" scheme="http://pengzhenjin.top/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Android-Jetpack组件：Paging</title>
    <link href="http://pengzhenjin.top/2019/05/24/Android-Jetpack%E7%BB%84%E4%BB%B6%EF%BC%9APaging/"/>
    <id>http://pengzhenjin.top/2019/05/24/Android-Jetpack组件：Paging/</id>
    <published>2019-05-23T16:00:00.000Z</published>
    <updated>2019-10-14T10:52:13.363Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;官方文档：&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/paging&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Paging&lt;/a&gt;&lt;br&gt;谷歌实验室：官方教程&lt;br&gt;官方Demo：&lt;a href=&quot;https://github.com/android/architecture-components-samples/tree/master/PagingWithNetworkSample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络方式&lt;/a&gt;，&lt;a href=&quot;https://github.com/android/architecture-components-samples/tree/master/PagingSample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库方式&lt;/a&gt;&lt;/p&gt;&lt;p&gt;谷歌官方的介绍：&lt;/p&gt;&lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;The Paging Library helps you load and display small chunks of data at a time. Loading partial data on demand reduces usage of network bandwidth and system resources.&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="Android" scheme="http://pengzhenjin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://pengzhenjin.top/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://pengzhenjin.top/tags/Jetpack/"/>
    
      <category term="Paging" scheme="http://pengzhenjin.top/tags/Paging/"/>
    
  </entry>
  
  <entry>
    <title>Android-Jetpack组件：Room</title>
    <link href="http://pengzhenjin.top/2019/05/23/Android-Jetpack%E7%BB%84%E4%BB%B6%EF%BC%9ARoom/"/>
    <id>http://pengzhenjin.top/2019/05/23/Android-Jetpack组件：Room/</id>
    <published>2019-05-22T16:00:00.000Z</published>
    <updated>2019-10-14T06:56:09.614Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;官方文档：&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/room&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Room&lt;/a&gt;&lt;br&gt;谷歌实验室：&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin/#0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方教程&lt;/a&gt;&lt;br&gt;SQL语法：&lt;a href=&quot;https://www.runoob.com/sqlite/sqlite-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SQLite教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;谷歌官方的介绍：&lt;/p&gt;&lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite.&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="Android" scheme="http://pengzhenjin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://pengzhenjin.top/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://pengzhenjin.top/tags/Jetpack/"/>
    
      <category term="Room" scheme="http://pengzhenjin.top/tags/Room/"/>
    
  </entry>
  
  <entry>
    <title>Android-Jetpack组件：ViewModel和LiveData</title>
    <link href="http://pengzhenjin.top/2019/05/22/Android-Jetpack%E7%BB%84%E4%BB%B6%EF%BC%9AViewModel%E5%92%8CLiveData/"/>
    <id>http://pengzhenjin.top/2019/05/22/Android-Jetpack组件：ViewModel和LiveData/</id>
    <published>2019-05-21T16:00:00.000Z</published>
    <updated>2019-10-13T12:32:13.311Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LiveData&quot;&gt;&lt;a href=&quot;#LiveData&quot; class=&quot;headerlink&quot; title=&quot;LiveData&quot;&gt;&lt;/a&gt;LiveData&lt;/h3&gt;&lt;p&gt;官方文档：&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/livedata.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LiveData&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在讲 LiveData 之前，我们先看看 LiveData 和 ViewModel 的作用：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;viewmodel-livedata-chapter-1/img1.png&quot; alt&gt;&lt;/p&gt;&lt;p&gt;从这一张图，我们可以看出 ViewModel 和 LiveData 在整个MVVM架构中担当数据驱动的职责，这也是 MVVM 模式中 ViewModel 层的作用。&lt;/p&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;
    
    </summary>
    
      <category term="Android" scheme="http://pengzhenjin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://pengzhenjin.top/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://pengzhenjin.top/tags/Jetpack/"/>
    
      <category term="ViewModel" scheme="http://pengzhenjin.top/tags/ViewModel/"/>
    
      <category term="LiveData" scheme="http://pengzhenjin.top/tags/LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Android-Jetpack组件：DataBinding</title>
    <link href="http://pengzhenjin.top/2019/05/21/Android-Jetpack%E7%BB%84%E4%BB%B6%EF%BC%9ADataBinding/"/>
    <id>http://pengzhenjin.top/2019/05/21/Android-Jetpack组件：DataBinding/</id>
    <published>2019-05-20T16:00:00.000Z</published>
    <updated>2019-10-11T10:16:50.778Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;h4 id=&quot;MVVM-介绍&quot;&gt;&lt;a href=&quot;#MVVM-介绍&quot; class=&quot;headerlink&quot; title=&quot;MVVM 介绍&quot;&gt;&lt;/a&gt;MVVM 介绍&lt;/h4&gt;&lt;p&gt;MVVM（全称 Model-View-ViewModel）同 MVC 和 MVP 一样，是逻辑分层解偶的模式（如果你还不了解 MVC 和 MVP，建议还是提前了解一下）。&lt;/p&gt;&lt;p&gt;结构图：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;databinding-chapter-1/img1.png&quot; alt&gt;&lt;/p&gt;&lt;p&gt;从上图我们可以了解到MVVM的三要素，他们分别是：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;View 层：xml、Activity、Fragment、Adapter 和 View 等&lt;/li&gt;
&lt;li&gt;Model 层：数据源（本地数据和网络数据等）&lt;/li&gt;
&lt;li&gt;ViewModel 层：View 层处理数据以及逻辑处理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://pengzhenjin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://pengzhenjin.top/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://pengzhenjin.top/tags/Jetpack/"/>
    
      <category term="DataBinding" scheme="http://pengzhenjin.top/tags/DataBinding/"/>
    
  </entry>
  
  <entry>
    <title>Android-Jetpack组件：Navigation</title>
    <link href="http://pengzhenjin.top/2019/05/20/Android-Jetpack%E7%BB%84%E4%BB%B6%EF%BC%9ANavigation/"/>
    <id>http://pengzhenjin.top/2019/05/20/Android-Jetpack组件：Navigation/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-10-11T09:15:53.124Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;Navigation 是什么呢？谷歌的介绍视频上说：&lt;/p&gt;&lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Navigation 是一个可简化Android导航的库和插件&lt;/p&gt;
          &lt;/div&gt;&lt;p&gt;更确切的来说，Navigation 是用来管理 Fragment 的切换，并且可以通过可视化的方式，看见 App 的交互流程。这完美的契合了 Jake Wharton 大神单 Activity 的建议。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://pengzhenjin.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://pengzhenjin.top/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://pengzhenjin.top/tags/Jetpack/"/>
    
      <category term="Navigation" scheme="http://pengzhenjin.top/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理详解</title>
    <link href="http://pengzhenjin.top/2018/10/21/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://pengzhenjin.top/2018/10/21/Java动态代理详解/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2019-10-15T03:17:40.488Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;动态代理在 Java 中有着广泛的应用，比如 Spring AOP、Hibernate 数据查询、测试框架的后端 mock、RPC 远程调用、Java 注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。&lt;/p&gt;&lt;p&gt;本文主要介绍 Java 中两种常见的动态代理方式：JDK 原生动态代理和 CGLIB 动态代理。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="proxy" scheme="http://pengzhenjin.top/tags/proxy/"/>
    
      <category term="动态代理" scheme="http://pengzhenjin.top/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制详解</title>
    <link href="http://pengzhenjin.top/2018/10/20/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://pengzhenjin.top/2018/10/20/Java反射机制详解/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2019-10-15T03:17:46.121Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;对于一般的开发者，很少需要直接使用 Java 反射机制来完成功能开发，但是反射是很多框架譬如 Spring， Mybatis 实现的核心，反射虽小，能量却很大。&lt;/p&gt;&lt;p&gt;本文主要介绍反射相关的概念以及 API 的使用。&lt;/p&gt;&lt;h3 id=&quot;反射的介绍&quot;&gt;&lt;a href=&quot;#反射的介绍&quot; class=&quot;headerlink&quot; title=&quot;反射的介绍&quot;&gt;&lt;/a&gt;反射的介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;反射(Reflection)&lt;/strong&gt; 是 Java 在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="reflect" scheme="http://pengzhenjin.top/tags/reflect/"/>
    
      <category term="反射" scheme="http://pengzhenjin.top/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java队列详解</title>
    <link href="http://pengzhenjin.top/2018/10/18/Java%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
    <id>http://pengzhenjin.top/2018/10/18/Java队列详解/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2019-09-03T02:54:21.435Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;队列简述&quot;&gt;&lt;a href=&quot;#队列简述&quot; class=&quot;headerlink&quot; title=&quot;队列简述&quot;&gt;&lt;/a&gt;队列简述&lt;/h3&gt;&lt;p&gt;Queue：基本上，一个队列就是一个先入先出（FIFO）的数据结构。&lt;/p&gt;&lt;p&gt;Queue 接口与 List、Set 同一级别，都是继承了 Collection 接口。LinkedList 实现了 Deque接口。&lt;/p&gt;&lt;p&gt;在并发队列上 JDK 提供了两套实现，一个是以 ConcurrentLinkedQueue 为代表的高性能队列非阻塞，一个是以 BlockingQueue 接口为代表的阻塞队列，无论哪种都继承自 Queue 接口。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="queue" scheme="http://pengzhenjin.top/tags/queue/"/>
    
      <category term="队列" scheme="http://pengzhenjin.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的实现原理</title>
    <link href="http://pengzhenjin.top/2018/10/16/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://pengzhenjin.top/2018/10/16/HashMap的实现原理/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2019-09-03T06:45:36.292Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-中的-hashCode-和-equals&quot;&gt;&lt;a href=&quot;#Java-中的-hashCode-和-equals&quot; class=&quot;headerlink&quot; title=&quot;Java 中的 hashCode 和 equals&quot;&gt;&lt;/a&gt;Java 中的 hashCode 和 equals&lt;/h3&gt;&lt;h4 id=&quot;关于-hashCode&quot;&gt;&lt;a href=&quot;#关于-hashCode&quot; class=&quot;headerlink&quot; title=&quot;关于 hashCode&quot;&gt;&lt;/a&gt;关于 hashCode&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，hashCode 是用来在散列存储结构中确定对象的存储地址的。&lt;/li&gt;
&lt;li&gt;如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同。&lt;/li&gt;
&lt;li&gt;如果对象的 equals 方法被重写，那么对象的 hashCode 也尽量重写，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，否则就会违反上面提到的第 2 点。&lt;/li&gt;
&lt;li&gt;两个对象的 hashCode 相同，并不一定表示两个对象就相同，也就是不一定适用于 equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如 Hashtable，他们“存放在同一个篮子里“。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="HashMap" scheme="http://pengzhenjin.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程详解</title>
    <link href="http://pengzhenjin.top/2018/10/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://pengzhenjin.top/2018/10/06/Java多线程详解/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2019-09-02T09:59:57.227Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;线程对象是可以产生线程的对象。比如在 Java 平台中 Thread 对象 、Runnable 对象。线程，是指正在执行的一个指点令序列。在 Java 平台上是指从一个线程对象的 start() 方法开始，运行 run() 方法体中的那一段相对独立的过程。相比于多进程，多线程的优势有：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;进程之间不能共享数据，线程可以；&lt;/li&gt;
&lt;li&gt;系统创建进程需要为该进程重新分配系统资源，故创建线程代价比较小；&lt;/li&gt;
&lt;li&gt;Java 语言内置了多线程功能支持，简化了 Java 多线程编程。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="thread" scheme="http://pengzhenjin.top/tags/thread/"/>
    
      <category term="多线程" scheme="http://pengzhenjin.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（四）：虚拟机类加载机制</title>
    <link href="http://pengzhenjin.top/2018/09/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://pengzhenjin.top/2018/09/04/Java虚拟机（四）：虚拟机类加载机制/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2019-09-02T02:01:51.259Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。&lt;/p&gt;&lt;p&gt;在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。&lt;/p&gt;&lt;h3 id=&quot;类加载时机&quot;&gt;&lt;a href=&quot;#类加载时机&quot; class=&quot;headerlink&quot; title=&quot;类加载时机&quot;&gt;&lt;/a&gt;类加载时机&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;jvm-chapter-4/img1.jpg&quot; alt&gt;&lt;/p&gt;&lt;p&gt;其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="jvm" scheme="http://pengzhenjin.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（三）：Java内存模型与线程</title>
    <link href="http://pengzhenjin.top/2018/09/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://pengzhenjin.top/2018/09/03/Java虚拟机（三）：Java内存模型与线程/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2019-09-02T02:01:59.204Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;jvm-chapter-3/img1.jpg&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;Java-内存模型&quot;&gt;&lt;a href=&quot;#Java-内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java 内存模型&quot;&gt;&lt;/a&gt;Java 内存模型&lt;/h3&gt;&lt;p&gt;屏蔽掉各种硬件和操作系统的内存访问差异。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;jvm-chapter-3/img2.jpg&quot; alt&gt;&lt;/p&gt;&lt;h4 id=&quot;主内存和工作内存之间的交互&quot;&gt;&lt;a href=&quot;#主内存和工作内存之间的交互&quot; class=&quot;headerlink&quot; title=&quot;主内存和工作内存之间的交互&quot;&gt;&lt;/a&gt;主内存和工作内存之间的交互&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;作用对象&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;lock&lt;/td&gt;
&lt;td&gt;主内存&lt;/td&gt;
&lt;td&gt;把一个变量标识为一条线程独占的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unlock&lt;/td&gt;
&lt;td&gt;主内存&lt;/td&gt;
&lt;td&gt;把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;主内存&lt;/td&gt;
&lt;td&gt;把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load&lt;/td&gt;
&lt;td&gt;工作内存&lt;/td&gt;
&lt;td&gt;把 read 操作从主内存中得到的变量值放入工作内存中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;use&lt;/td&gt;
&lt;td&gt;工作内存&lt;/td&gt;
&lt;td&gt;把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;assign&lt;/td&gt;
&lt;td&gt;工作内存&lt;/td&gt;
&lt;td&gt;把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;store&lt;/td&gt;
&lt;td&gt;工作内存&lt;/td&gt;
&lt;td&gt;把工作内存中的一个变量的值传送到主内存中，以便 write 操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;工作内存&lt;/td&gt;
&lt;td&gt;把 store 操作从工作内存中得到的变量的值放入主内存的变量中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="jvm" scheme="http://pengzhenjin.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（二）：垃圾回收器与内存分配策略</title>
    <link href="http://pengzhenjin.top/2018/09/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://pengzhenjin.top/2018/09/02/Java虚拟机（二）：垃圾回收器与内存分配策略/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2019-09-02T02:02:08.973Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="jvm" scheme="http://pengzhenjin.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（一）：Java内存区域与内存溢出异常</title>
    <link href="http://pengzhenjin.top/2018/09/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://pengzhenjin.top/2018/09/01/Java虚拟机（一）：Java内存区域与内存溢出异常/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2019-09-02T02:02:17.526Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别&quot;&gt;&lt;/a&gt;进程和线程的区别&lt;/h3&gt;&lt;p&gt;进程是资源分配的最小单位，线程是程序执行的最小单位。&lt;/p&gt;&lt;p&gt;进程有自己的独立地址空间，每启动一个进程，系统就会为它分配一个地址空间、建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费要比进程小很多，同时创建一个线程的开销也要比进程小很多。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://pengzhenjin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://pengzhenjin.top/tags/java/"/>
    
      <category term="jvm" scheme="http://pengzhenjin.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令详解</title>
    <link href="http://pengzhenjin.top/2018/08/20/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://pengzhenjin.top/2018/08/20/Hexo常用命令详解/</id>
    <published>2018-08-19T16:00:00.000Z</published>
    <updated>2019-08-25T14:42:08.236Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init [folder]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。&lt;/p&gt;&lt;h3 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new&quot;&gt;&lt;/a&gt;new&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new [layout] &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://pengzhenjin.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://pengzhenjin.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客（三）：主题美化</title>
    <link href="http://pengzhenjin.top/2018/08/17/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <id>http://pengzhenjin.top/2018/08/17/Hexo搭建个人博客（三）：主题美化/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2019-08-26T09:01:43.048Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自定样式&quot;&gt;&lt;a href=&quot;#自定样式&quot; class=&quot;headerlink&quot; title=&quot;自定样式&quot;&gt;&lt;/a&gt;自定样式&lt;/h3&gt;&lt;p&gt;您可以将所有自定义样式文件放在 &lt;code&gt;hexo-size/source/_data&lt;/code&gt; 目录下。&lt;br&gt;编辑 主题配置文件 &lt;code&gt;_config.yml&lt;/code&gt; ，取消 &lt;code&gt;custom_file_path&lt;/code&gt; 前面的注释。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;custom_file_path:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #head: source/_data/head.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #header: source/_data/header.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #sidebar: source/_data/sidebar.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #postMeta: source/_data/post-meta.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #postBodyEnd: source/_data/post-body-end.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #footer: source/_data/footer.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #bodyEnd: source/_data/body-end.swig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #variable: source/_data/variables.styl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #mixin: source/_data/mixins.styl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  style: source/_data/styles.styl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://pengzhenjin.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://pengzhenjin.top/tags/Hexo/"/>
    
      <category term="博客" scheme="http://pengzhenjin.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="NexT" scheme="http://pengzhenjin.top/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客（二）：主题配置</title>
    <link href="http://pengzhenjin.top/2018/08/16/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>http://pengzhenjin.top/2018/08/16/Hexo搭建个人博客（二）：主题配置/</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2019-08-28T05:41:36.038Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-NexT-？&quot;&gt;&lt;a href=&quot;#什么是-NexT-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 NexT ？&quot;&gt;&lt;/a&gt;什么是 NexT ？&lt;/h3&gt;&lt;p&gt;Next 是专门为 Hexo 而定制的一款主题。它简单、清新、优雅，一个主题，三种外观，而且还支持多种语言，选您所好。&lt;/p&gt;&lt;h3 id=&quot;配置文件说明&quot;&gt;&lt;a href=&quot;#配置文件说明&quot; class=&quot;headerlink&quot; title=&quot;配置文件说明&quot;&gt;&lt;/a&gt;配置文件说明&lt;/h3&gt;&lt;p&gt;在 Hexo 中有两份主要的配置文件，其名称都是 &lt;code&gt;_config.yml&lt;/code&gt;。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://pengzhenjin.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://pengzhenjin.top/tags/Hexo/"/>
    
      <category term="博客" scheme="http://pengzhenjin.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="NexT" scheme="http://pengzhenjin.top/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客（一）：基础安装</title>
    <link href="http://pengzhenjin.top/2018/08/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/"/>
    <id>http://pengzhenjin.top/2018/08/15/Hexo搭建个人博客（一）：基础安装/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2019-08-26T10:12:55.777Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着互联网浪潮的翻腾，国内外已经涌现出越来越多优秀的社交网站让用户分享信息更加便捷。然而，如果你是一个不甘堕落的工程狮或程序猿，是否也想要拥有一个属于自己的博客网站呢？如果你曾经或者现在正有这样的想法，那就请跟随这篇文章，发挥你的Geek精神，让你快速拥有自己的博客网站。文章内容如果有错误，请在文章下面的评论中留言指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://pengzhenjin.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://pengzhenjin.top/tags/Hexo/"/>
    
      <category term="博客" scheme="http://pengzhenjin.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="NexT" scheme="http://pengzhenjin.top/tags/NexT/"/>
    
  </entry>
  
</feed>
